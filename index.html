<!DOCTYPE html>
<html lang='en-US'>
<head>
    <meta charset='UTF-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Risk Assessment Buddy Smart (2.0)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'Segoe UI', 'Roboto', 'Arial', 'sans-serif'],
                    },
                },
            },
        }
    </script>
    

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.1.6/purify.min.js"></script>
    <script async src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js"></script>
    <script src="lib/face-api.min.js"></script> 
    <script src="lib/jszip.min.js"></script>
    <script src="lib/pdfkit.min.js"></script>
    <script src="lib/blob-stream.min.js"></script>

    <style>
/* Smooth Modal Entry */
@keyframes modalFadeIn {
    from { opacity: 0; transform: scale(0.95); }
    to { opacity: 1; transform: scale(1); }
}
.gy-modal-content, .modal-content {
    animation: modalFadeIn 0.2s ease-out;
}

/* --- NEW: Split Layout for Drag & Drop --- */
.gy-split-container {
    display: flex;
    gap: 20px;
    height: 60vh; /* Fixed height to enable internal scrolling */
    border-top: 1px solid #e2e8f0;
    padding-top: 20px;
    margin-top: 20px;
}

/* Left Side: Source Gallery */
.gy-source-panel {
    width: 300px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    border-right: 1px solid #e2e8f0;
    padding-right: 15px;
}

.gy-source-scroll {
    overflow-y: auto;
    flex-grow: 1;
    padding: 5px;
}

/* Right Side: Cards List */
.gy-cards-panel {
    flex-grow: 1;
    overflow-y: auto; /* Independent scrolling */
    padding-right: 10px;
    position: relative;
}

/* Gallery Grid Tweak */
/* Gallery Grid Container */
        #gySourceGrid { 
            display: grid; 
            grid-template-columns: repeat(2, 1fr); /* 2 columns */
            gap: 0.75rem; 
            overflow-y: auto; 
            align-content: start; 
            padding: 0.25rem;
            flex: 1;       /* CRITICAL: Fills the remaining vertical space */
            min-height: 0; /* CRITICAL: Allows scrolling inside a flex container */
        }
        
        /* Gallery Item Card */
        .gy-source-item { 
            position: relative; 
            height: 8rem; /* CRITICAL: Explicit height (approx 128px) prevents collapse */
            width: 100%; 
            background: white; 
            border-radius: 0.5rem; 
            border: 1px solid #e2e8f0; 
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); 
            overflow: hidden; 
            cursor: grab; 
            transition: all 0.2s; 
        }
        .gy-source-item:hover { border-color: #a5b4fc; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
        
        /* The Image Inside */
        .gy-source-item img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Ensures image fills the box perfectly */
            pointer-events: none;
        }

/* Drag Auto-Scroll Hotzones */
.scroll-zone {
    position: absolute; left: 0; right: 0; height: 50px; z-index: 20;
    pointer-events: none; /* Let clicks pass through */
}
.scroll-top { top: 0; background: linear-gradient(to bottom, rgba(0,0,0,0.1), transparent); }
.scroll-bottom { bottom: 0; background: linear-gradient(to top, rgba(0,0,0,0.1), transparent); }

/* Modern Scrollbars */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}
::-webkit-scrollbar-track {
    background: #f1f5f9; 
}
::-webkit-scrollbar-thumb {
    background: #cbd5e1; 
    border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
    background: #94a3b8; 
}

/* Risk Badge Classes (can be applied via JS) */
.badge {
    display: inline-flex;
    align-items: center;
    padding: 0.125rem 0.625rem;
    border-radius: 9999px;
    font-size: 0.75rem;
    font-weight: 600;
}
.badge-critical { background-color: #fee2e2; color: #991b1b; }
.badge-high { background-color: #ffedd5; color: #9a3412; }
.badge-medium { background-color: #fef9c3; color: #854d0e; }
.badge-low { background-color: #dcfce7; color: #166534; }

        /* ADD TO YOUR CSS */
.gy-modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.5); z-index: 9999;
    display: flex; justify-content: center; align-items: center;
}
.gy-modal-content {
    background: white; width: 95%; max-width: 1600px; height: 90%; 
    border-radius: 16px; padding: 40px; overflow-y: auto; position: relative;
    box-shadow: 0 20px 40px rgba(0,0,0,0.3); font-family: 'Segoe UI', sans-serif;
}
.gy-close-modal {
    position: absolute; top: 15px; right: 20px; font-size: 30px; border: none; 
    background: none; cursor: pointer; color: #666;
}
.gy-dashboard { display: grid; grid-template-columns: 300px 1fr; gap: 25px; margin-bottom: 30px; }
.gy-dropzone {
    border: 3px dashed #27ae60; border-radius: 10px; padding: 20px; text-align: center; background: #f0fff4; 
    cursor: pointer; display: flex; flex-direction: column; justify-content: center; align-items: center;
    transition: all 0.2s; height: 100%; box-sizing: border-box;
}
.gy-dropzone:hover { background: #e8f8f0; border-color: #219150; transform: translateY(-2px); }
.gy-mapper-box { background: #f8f9fa; border: 1px solid #e9ecef; padding: 20px; border-radius: 10px; }
.gy-mapper-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 2px solid #e9ecef; padding-bottom: 10px; }
.gy-mapper-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 10px; }
.gy-map-field input { width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; text-align: center; font-weight: bold; }
#gyRefreshBtn { background: #3498db; color: white; border: none; padding: 6px 12px; border-radius: 15px; cursor: pointer; }
.gy-grid-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 25px; margin-top: 20px; }
.gy-card { border: 1px solid #e0e0e0; border-radius: 10px; overflow: hidden; background: white; display: flex; flex-direction: column; position: relative; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
.gy-card-img { height: 200px; background: #f8f9fa; display: flex; align-items: center; justify-content: center; position: relative; border-bottom: 1px solid #eee; overflow: hidden; }
.gy-card-img img { max-width: 100%; max-height: 100%; object-fit: contain; }
.gy-row-badge { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.6); color: white; padding: 4px 10px; border-radius: 4px; font-size: 11px; pointer-events: none; z-index: 5; }
.gy-action-btn { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; z-index: 10; display: flex; align-items: center; justify-content: center; border: none; position: absolute; top: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
.gy-down-btn { right: 80px; background: #10b981; color: white; }
.gy-down-btn:hover { background: #059669; transform: scale(1.1); }
.gy-del-btn { right: 10px; background: #e74c3c; color: white; }
.gy-rep-btn { right: 45px; background: #3498db; color: white; }
.gy-card-body { padding: 15px; display: flex; flex-direction: column; gap: 10px; }
.gy-textarea { width: 100%; box-sizing: border-box; border: 1px solid #e0e0e0; border-radius: 6px; padding: 8px; font-size: 0.9rem; min-height: 50px; background: #fafafa; }
.gy-main-btn { background: #27ae60; color: white; border: none; padding: 15px 40px; font-size: 1.2rem; border-radius: 50px; cursor: pointer; }
        .btn-indigo { background: linear-gradient(135deg, #4f46e5 0%, #4338ca 100%); color: white; border: none; padding: 12px 24px; font-weight: 600; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(79, 70, 229, 0.3); }
        .btn-indigo:hover { background: linear-gradient(135deg, #4338ca 0%, #3730a3 100%); transform: translateY(-2px); box-shadow: 0 6px 20px rgba(79, 70, 229, 0.4); }
        .btn-indigo:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-white { background: white; color: #4f46e5; border: 2px solid #4f46e5; padding: 10px 20px; font-weight: 600; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; }
        .btn-white:hover { background: #f5f3ff; border-color: #4338ca; }


        /* Custom styles for Google Charts transparency */
        #riskChart div, #hazardChart div { background-color: transparent !important; }
        /* Fix for lightbox drag-and-drop */
        #lightboxGallery img.dragging { opacity: 0.5; cursor: grabbing; }
        .gallery-item.dragging { opacity: 0.5; cursor: grabbing; }
        /* Style for hidden file input */
        input[type="file"].hidden-file-input {
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            position: absolute;
            z-index: -1;
        }
        /* Ensure translate widgets don't overflow */
         .skiptranslate { overflow: hidden; }
         .goog-te-gadget { white-space: nowrap; }
        /* Deleted / struck-through row styling */
        .deleted-row td { text-decoration: line-through; opacity: 0.55; }
        .delete-btn { background:#ef4444; color:#fff; padding:6px 8px; border-radius:6px; border:none; cursor:pointer; }
        .restore-btn { background:#10b981; color:#fff; padding:6px 8px; border-radius:6px; border:none; cursor:pointer; }
        
        /* Hide extra spacing for hidden language sections */
        details[style*="display: none"] {
            margin: 0 !important;
            padding: 0 !important;
            border: none !important;
            display: none !important;
        }

    </style>
</head>
<body class="bg-slate-100 font-sans text-slate-800">
    <main class="mx-auto px-4 sm:px-6 lg:px-8 py-4 sm:py-8 space-y-8">
<div id="howToUseContainer">
<details class="bg-indigo-50 rounded-lg border border-indigo-200 mb-8 group overflow-hidden" id="howToUse-en" data-lang="en" style="display: block;">
    <summary class="p-6 flex justify-between items-center cursor-pointer list-none">
        <h2 class="text-xl font-semibold text-indigo-900">How to Use This App üöÄ</h2>
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-indigo-700 transform transition-transform duration-200 group-open:rotate-180" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
        </svg>
    </summary>

    <div class="px-6 pb-6 pt-0 space-y-4">
        <p class="text-indigo-700 font-semibold mb-4">Risk Assessment Buddy is a field accelerator tool that helps accelerate and streamline your risk assessment projects. There are three workflows for using this app:</p>

        <!-- Workflow 1: Image/Video First -->
        <div class="bg-white rounded-lg border border-indigo-200 p-4">
            <h3 class="font-bold text-slate-800 text-lg mb-3">üé• Workflow 1: Start Fresh with Rich Media (Images/Videos)</h3>
            <ul class="list-disc list-inside text-sm text-slate-600 space-y-2">
                <li>Upload images or videos of your risk assessment project.</li>
                <li>Faces are automatically detected and blurred. If auto-detection fails, manually blur faces by clicking with the mouse.</li>
                <li>Add details to each image, preferably sitting with your operational leads:
                    <ul class="list-circle list-inside ml-4 mt-1 space-y-1 text-slate-600">
                        <li><strong>Description</strong>: Explain what is happening in the image</li>
                        <li><strong>Hazards</strong>: Identify potential hazards (optional rating: 1-5)</li>
                        <li><strong>Controls</strong>: Suggest mitigations or controls</li>
                    </ul>
                </li>
                <li>Once image notes are complete, click <strong class="font-medium">"Generate AI Risk Assessment from Image Notes"</strong></li>
                <li>AI will process your notes:
                    <ul class="list-circle list-inside ml-4 mt-1 space-y-1 text-slate-600">
                        <li>If you added a manual risk rating, AI will preserve it</li>
                        <li>If there are additional hazards, AI will identify and populate them (marked as <strong>AI</strong>)</li>
                    </ul>
                </li>
                <li>Review and edit the table as needed. Delete any steps that are not required.</li>
                <li>Once satisfied, click <strong class="font-medium">"Download Project Zip"</strong> to download all project files to your PC.</li>
            </ul>
        </div>

        <!-- Workflow 2: Text First -->
        <div class="bg-white rounded-lg border border-indigo-200 p-4">
            <h3 class="font-bold text-slate-800 text-lg mb-3">üìù Workflow 2: Describe the Task in Plain Language</h3>
            <ul class="list-disc list-inside text-sm text-slate-600 space-y-2">
                <li>Go to <strong class="font-medium">"1. Describe the Task"</strong> section.</li>
                <li>Type a plain language description of your task or process.</li>
                <li>Click <strong class="font-medium">"Generate Task Breakdown"</strong></li>
                <li>AI will automatically split it and generate a standard risk assessment table for you.</li>
            </ul>
        </div>

        <!-- Workflow 3: Legacy Risk Assessment -->
        <div class="bg-white rounded-lg border border-indigo-200 p-4">
            <h3 class="font-bold text-slate-800 text-lg mb-3">üìä Workflow 3: Format Legacy Risk Assessments</h3>
            <ul class="list-disc list-inside text-sm text-slate-600 space-y-2">
                <li>Upload your legacy risk assessment Excel file.</li>
                <li>Use the <strong class="font-medium">Column Mapper</strong> to map columns to the new format.</li>
                <li>Handle images:
                    <ul class="list-circle list-inside ml-4 mt-1 space-y-1 text-slate-600">
                        <li>Replace outdated images with new ones</li>
                        <li>Embedded images from your Excel sheet are available on the left pane</li>
                        <li>Drag and drop images to steps as needed</li>
                        <li>Delete unnecessary images and clean up</li>
                    </ul>
                </li>
                <li>Once satisfied, load the Excel data as a new project.</li>
                <li>Click <strong class="font-medium">"Generate AI Risk Assessment from Image Notes"</strong> to generate your Risk Assessment table.</li>
            </ul>
        </div>

        <!-- Important Notes -->
        <div class="bg-blue-50 rounded-lg border border-blue-200 p-4 mt-4">
            <h3 class="font-bold text-blue-900 mb-3">‚ö†Ô∏è Important Notes</h3>
            <ul class="list-disc list-inside text-sm text-blue-800 space-y-2">
                <li><strong>No Cloud Storage:</strong> No data is saved in the cloud. All your files are downloaded locally.</li>
                <li><strong>Save and Resume:</strong> You can save your project file and resume work by loading it back into the app.</li>
                <li><strong>Browser Refresh Warning:</strong> If you refresh your browser, your data in memory is lost. You will need to restart from the beginning or load your saved project file.</li>
                <li><strong>Language Support:</strong> You can read all dropdowns and hazard options in French or German by using the üåê Language selector at the top right of the app.</li>
            </ul>
        </div>
    </div>
</details>

<!-- FRENCH VERSION -->
<details class="bg-indigo-50 rounded-lg border border-indigo-200 mb-8 group overflow-hidden" id="howToUse-fr" data-lang="fr" style="display: none;">
    <summary class="p-6 flex justify-between items-center cursor-pointer list-none">
        <h2 class="text-xl font-semibold text-indigo-900">Comment utiliser cette application üöÄ</h2>
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-indigo-700 transform transition-transform duration-200 group-open:rotate-180" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
        </svg>
    </summary>

    <div class="px-6 pb-6 pt-0 space-y-4">
        <p class="text-indigo-700 font-semibold mb-4">Risk Assessment Buddy est un outil acc√©l√©rateur sur le terrain qui vous aide √† acc√©l√©rer et rationaliser vos projets d'√©valuation des risques. Il existe trois flux de travail pour utiliser cette application:</p>

        <!-- Workflow 1: Image/Video First -->
        <div class="bg-white rounded-lg border border-indigo-200 p-4">
            <h3 class="font-bold text-slate-800 text-lg mb-3">üé• Flux de travail 1 : Commencez de z√©ro avec des m√©dias riches (images/vid√©os)</h3>
            <ul class="list-disc list-inside text-sm text-slate-600 space-y-2">
                <li>T√©l√©chargez des images ou des vid√©os de votre projet d'√©valuation des risques.</li>
                <li>Les visages sont automatiquement d√©tect√©s et flout√©s. Si la d√©tection automatique √©choue, floutez manuellement les visages en cliquant avec la souris.</li>
                <li>Ajoutez des d√©tails √† chaque image, de pr√©f√©rence en discutant avec vos responsables op√©rationnels:
                    <ul class="list-circle list-inside ml-4 mt-1 space-y-1 text-slate-600">
                        <li><strong>Description</strong>: Expliquez ce qui se passe dans l'image</li>
                        <li><strong>Dangers</strong>: Identifiez les dangers potentiels (√©valuation optionnelle: 1-5)</li>
                        <li><strong>Contr√¥les</strong>: Sugg√©rez des mesures d'att√©nuation ou des contr√¥les</li>
                    </ul>
                </li>
                <li>Une fois les notes d'image termin√©es, cliquez sur <strong class="font-medium">"G√©n√©rer une √©valuation des risques IA √† partir des notes d'image"</strong></li>
                <li>L'IA traitera vos notes:
                    <ul class="list-circle list-inside ml-4 mt-1 space-y-1 text-slate-600">
                        <li>Si vous avez ajout√© une √©valuation des risques manuelle, l'IA la pr√©servera</li>
                        <li>S'il y a d'autres dangers, l'IA les identifiera et les remplira (marqu√©s comme <strong>IA</strong>)</li>
                    </ul>
                </li>
                <li>Passez en revue et modifiez le tableau selon vos besoins. Supprimez les √©tapes qui ne sont pas requises.</li>
                <li>Une fois satisfait, cliquez sur <strong class="font-medium">"T√©l√©charger le ZIP du projet"</strong> pour t√©l√©charger tous les fichiers du projet sur votre PC.</li>
            </ul>
        </div>

        <!-- Workflow 2: Text First -->
        <div class="bg-white rounded-lg border border-indigo-200 p-4">
            <h3 class="font-bold text-slate-800 text-lg mb-3">üìù Flux de travail 2 : D√©crivez la t√¢che en langage simple</h3>
            <ul class="list-disc list-inside text-sm text-slate-600 space-y-2">
                <li>Acc√©dez √† la section <strong class="font-medium">"1. D√©crivez la t√¢che"</strong>.</li>
                <li>Tapez une description en langage simple de votre t√¢che ou processus.</li>
                <li>Cliquez sur <strong class="font-medium">"G√©n√©rer la d√©composition des t√¢ches"</strong></li>
                <li>L'IA divisera automatiquement et g√©n√©rera un tableau d'√©valuation des risques standard pour vous.</li>
            </ul>
        </div>

        <!-- Workflow 3: Legacy Risk Assessment -->
        <div class="bg-white rounded-lg border border-indigo-200 p-4">
            <h3 class="font-bold text-slate-800 text-lg mb-3">üìä Flux de travail 3 : Formater les √©valuations des risques h√©rit√©es</h3>
            <ul class="list-disc list-inside text-sm text-slate-600 space-y-2">
                <li>T√©l√©chargez votre fichier Excel d'√©valuation des risques h√©rit√©.</li>
                <li>Utilisez le <strong class="font-medium">Mappeur de colonnes</strong> pour mapper les colonnes au nouveau format.</li>
                <li>G√©rez les images:
                    <ul class="list-circle list-inside ml-4 mt-1 space-y-1 text-slate-600">
                        <li>Remplacez les images obsol√®tes par de nouvelles</li>
                        <li>Les images int√©gr√©es de votre feuille Excel sont disponibles dans le volet gauche</li>
                        <li>Glissez-d√©posez les images selon vos besoins</li>
                        <li>Supprimez les images inutiles et nettoyez</li>
                    </ul>
                </li>
                <li>Une fois satisfait, chargez les donn√©es Excel en tant que nouveau projet.</li>
                <li>Cliquez sur <strong class="font-medium">"G√©n√©rer une √©valuation des risques IA √† partir des notes d'image"</strong> pour g√©n√©rer votre tableau d'√©valuation des risques.</li>
            </ul>
        </div>

        <!-- Important Notes -->
        <div class="bg-blue-50 rounded-lg border border-blue-200 p-4 mt-4">
            <h3 class="font-bold text-blue-900 mb-3">‚ö†Ô∏è Notes Importantes</h3>
            <ul class="list-disc list-inside text-sm text-blue-800 space-y-2">
                <li><strong>Pas de stockage cloud:</strong> Aucune donn√©e n'est enregistr√©e dans le cloud. Tous vos fichiers sont t√©l√©charg√©s localement.</li>
                <li><strong>Enregistrer et reprendre:</strong> Vous pouvez enregistrer votre fichier de projet et reprendre le travail en le rechargeant dans l'application.</li>
                <li><strong>Avertissement d'actualisation du navigateur:</strong> Si vous actualisez votre navigateur, vos donn√©es en m√©moire sont perdues. Vous devrez recommencer depuis le d√©but ou charger votre fichier de projet enregistr√©.</li>
                <li><strong>Support multilingue:</strong> Vous pouvez lire tous les menus d√©roulants et les options de dangers en anglais, fran√ßais ou allemand en utilisant le s√©lecteur de langue üåê en haut √† droite de l'application.</li>
            </ul>
        </div>
    </div>
</details>

<!-- GERMAN VERSION -->
<details class="bg-indigo-50 rounded-lg border border-indigo-200 mb-8 group overflow-hidden" id="howToUse-de" data-lang="de" style="display: none;">
    <summary class="p-6 flex justify-between items-center cursor-pointer list-none">
        <h2 class="text-xl font-semibold text-indigo-900">Verwendung dieser Anwendung üöÄ</h2>
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-indigo-700 transform transition-transform duration-200 group-open:rotate-180" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
        </svg>
    </summary>

    <div class="px-6 pb-6 pt-0 space-y-4">
        <p class="text-indigo-700 font-semibold mb-4">Risk Assessment Buddy ist ein feldgest√ºtztes Beschleunigungstool, das Ihnen dabei hilft, Ihre Risikobewertungsprojekte zu beschleunigen und zu rationalisieren. Es gibt drei Workflows f√ºr die Verwendung dieser Anwendung:</p>

        <!-- Workflow 1: Image/Video First -->
        <div class="bg-white rounded-lg border border-indigo-200 p-4">
            <h3 class="font-bold text-slate-800 text-lg mb-3">üé• Arbeitsablauf 1: Beginnen Sie von vorne mit Rich Media (Bilder/Videos)</h3>
            <ul class="list-disc list-inside text-sm text-slate-600 space-y-2">
                <li>Laden Sie Bilder oder Videos Ihres Risikobewertungsprojekts hoch.</li>
                <li>Gesichter werden automatisch erkannt und unsch√§rfer. Wenn die automatische Erkennung fehlschl√§gt, k√∂nnen Sie Gesichter manuell verbergen, indem Sie mit der Maus klicken.</li>
                <li>F√ºgen Sie Details zu jedem Bild hinzu, vorzugsweise in Diskussion mit Ihren operativen Leitern:
                    <ul class="list-circle list-inside ml-4 mt-1 space-y-1 text-slate-600">
                        <li><strong>Beschreibung</strong>: Erkl√§ren Sie, was auf dem Bild passiert</li>
                        <li><strong>Gefahren</strong>: Identifizieren Sie potenzielle Gefahren (optionale Bewertung: 1-5)</li>
                        <li><strong>Kontrollen</strong>: Schlagen Sie Abhilfe- oder Kontrollma√ünahmen vor</li>
                    </ul>
                </li>
                <li>Klicken Sie nach Abschluss der Bildbeschreibungen auf <strong class="font-medium">"KI-Risikobewertung aus Bildnotizen generieren"</strong></li>
                <li>Die KI wird Ihre Notizen verarbeiten:
                    <ul class="list-circle list-inside ml-4 mt-1 space-y-1 text-slate-600">
                        <li>Wenn Sie eine manuelle Risikobewertung hinzugef√ºgt haben, wird die KI diese beibehalten</li>
                        <li>Wenn es zus√§tzliche Gefahren gibt, werden diese von der KI identifiziert und aufgelistet (gekennzeichnet als <strong>KI</strong>)</li>
                    </ul>
                </li>
                <li>√úberpr√ºfen und bearbeiten Sie die Tabelle nach Bedarf. L√∂schen Sie nicht erforderliche Schritte.</li>
                <li>Klicken Sie auf <strong class="font-medium">"Projekt-ZIP herunterladen"</strong>, um alle Projektdateien auf Ihren PC herunterzuladen.</li>
            </ul>
        </div>

        <!-- Workflow 2: Text First -->
        <div class="bg-white rounded-lg border border-indigo-200 p-4">
            <h3 class="font-bold text-slate-800 text-lg mb-3">üìù Arbeitsablauf 2: Beschreiben Sie die Aufgabe in einfacher Sprache</h3>
            <ul class="list-disc list-inside text-sm text-slate-600 space-y-2">
                <li>Gehen Sie zum Abschnitt <strong class="font-medium">"1. Aufgabe beschreiben"</strong>.</li>
                <li>Geben Sie eine umgangssprachliche Beschreibung Ihrer Aufgabe oder Ihres Prozesses ein.</li>
                <li>Klicken Sie auf <strong class="font-medium">"Task-Aufschl√ºsselung generieren"</strong></li>
                <li>Die KI teilt dies automatisch auf und generiert eine standardisierte Risikobewertungstabelle f√ºr Sie.</li>
            </ul>
        </div>

        <!-- Workflow 3: Legacy Risk Assessment -->
        <div class="bg-white rounded-lg border border-indigo-200 p-4">
            <h3 class="font-bold text-slate-800 text-lg mb-3">üìä Arbeitsablauf 3: Formatieren Sie √§ltere Risikobewertungen</h3>
            <ul class="list-disc list-inside text-sm text-slate-600 space-y-2">
                <li>Laden Sie Ihre Excel-Datei zur veralteten Risikobewertung hoch.</li>
                <li>Verwenden Sie den <strong class="font-medium">Spaltenmapper</strong>, um Spalten dem neuen Format zuzuordnen.</li>
                <li>Verwalten Sie Bilder:
                    <ul class="list-circle list-inside ml-4 mt-1 space-y-1 text-slate-600">
                        <li>Ersetzen Sie veraltete Bilder durch neue</li>
                        <li>In Ihr Excel-Blatt eingebettete Bilder sind im linken Bereich verf√ºgbar</li>
                        <li>Ziehen Sie Bilder nach Bedarf ab</li>
                        <li>L√∂schen Sie unn√∂tige Bilder und r√§umen Sie auf</li>
                    </ul>
                </li>
                <li>Laden Sie nach Fertigstellung die Excel-Daten als neues Projekt.</li>
                <li>Klicken Sie auf <strong class="font-medium">"KI-Risikobewertung aus Bildnotizen generieren"</strong>, um Ihre Risikobewertungstabelle zu generieren.</li>
            </ul>
        </div>

        <!-- Important Notes -->
        <div class="bg-blue-50 rounded-lg border border-blue-200 p-4 mt-4">
            <h3 class="font-bold text-blue-900 mb-3">‚ö†Ô∏è Wichtige Hinweise</h3>
            <ul class="list-disc list-inside text-sm text-blue-800 space-y-2">
                <li><strong>Keine Cloud-Speicherung:</strong> Keine Daten werden in der Cloud gespeichert. Alle Dateien werden lokal heruntergeladen.</li>
                <li><strong>Speichern und fortfahren:</strong> Sie k√∂nnen Ihre Projektdatei speichern und die Arbeit fortsetzen, indem Sie sie zur√ºck in die Anwendung laden.</li>
                <li><strong>Browseraktualisierungswarnung:</strong> Wenn Sie Ihren Browser aktualisieren, gehen Ihre im Speicher befindlichen Daten verloren. Sie m√ºssen von vorne beginnen oder Ihre gespeicherte Projektdatei laden.</li>
                <li><strong>Mehrsprachige Unterst√ºtzung:</strong> Sie k√∂nnen alle Dropdowns und Gefahrenoptionen auf Englisch, Franz√∂sisch oder Deutsch lesen, indem Sie den Sprachw√§hler üåê oben rechts in der Anwendung verwenden.</li>
            </ul>
        </div>
    </div>
</details>
</div>
        <!-- Modern Tab Interface Header -->
        <section class="bg-gradient-to-r from-indigo-600 to-blue-700 rounded-t-2xl shadow-lg overflow-hidden">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 p-6 sm:p-8 text-white">
                <div>
                    <h1 class="text-3xl sm:text-4xl font-bold mb-2">Risk Assessment Buddy (SMART 2.0)</h1>
                    <p class="text-indigo-100">Choose your workflow to get started</p>
                </div>
                <div class="bg-white/20 backdrop-blur-md p-4 rounded-lg border border-white/30">
                    <label for="langSelect" class="block text-sm font-semibold text-white mb-2">üåê Language:</label>
                    <select id="langSelect" class="w-full p-2 border border-white/40 rounded-md bg-white/90 focus:ring-2 focus:ring-yellow-300 transition font-medium text-slate-800">
                        <option value="en">English</option>
                        <option value="fr">Fran√ßais (French)</option>
                        <option value="de">Deutsch (German)</option>
                    </select>
                </div>
            </div>

            <!-- Tab Navigation -->
            <div class="flex border-t border-white/20 bg-gradient-to-r from-indigo-700 to-blue-800">
                <button id="tab-rich-media" class="tab-btn flex-1 sm:flex-none px-6 py-4 text-white font-semibold text-sm sm:text-base hover:bg-white/10 transition border-b-4 border-yellow-400 bg-white/10 flex items-center justify-center gap-2" onclick="switchTab('rich-media')">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>
                    Rich Media
                </button>
                <button id="tab-free-text" class="tab-btn flex-1 sm:flex-none px-6 py-4 text-white font-semibold text-sm sm:text-base hover:bg-white/10 transition border-b-4 border-transparent flex items-center justify-center gap-2" onclick="switchTab('free-text')">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
                    Free Text
                </button>
                <button id="tab-excel" class="tab-btn flex-1 sm:flex-none px-6 py-4 text-white font-semibold text-sm sm:text-base hover:bg-white/10 transition border-b-4 border-transparent flex items-center justify-center gap-2" onclick="switchTab('excel')">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4" /></svg>
                    Excel Sheet
                </button>
            </div>
        </section>

        <!-- Tab Content Panels -->
        <section id="tab-content-rich-media" class="tab-content bg-white rounded-b-2xl shadow-xl p-6 sm:p-8 space-y-6">
            <!-- Rich Media Stream Content -->
            <div id="face-blurrer-app">
                <h2 class="text-2xl font-bold text-slate-900 mb-4">üì∏ Upload Images & Videos</h2>
                <p class="text-slate-600 mb-6">Upload media files. Faces will be automatically blurred. Click thumbnails to add risk descriptions, hazards, and controls.</p>
                
                <div class="space-y-6">
                    <div>
                        <label for="imageUpload" class="w-full bg-gradient-to-br from-indigo-50 to-blue-50 border-2 border-dashed border-indigo-300 rounded-lg p-8 flex flex-col items-center justify-center cursor-pointer hover:bg-indigo-100 transition duration-300">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-indigo-500 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                            </svg>
                            <span class="font-semibold text-indigo-900">Click to upload or drag and drop</span>
                            <span class="text-sm text-indigo-700">Images or Videos</span>
                        </label>
                        <input type="file" id="imageUpload" multiple accept="image/png, image/jpeg, video/mp4, video/quicktime, video/x-msvideo, video/x-matroska, .mov, .avi, .mkv, .webm" class="hidden-file-input">
                    </div>
                    <div id="progress-container" class="hidden space-y-2">
                        <label for="progressBar" class="font-semibold text-sm text-slate-700">Overall Progress:</label>
                        <progress id="progressBar" value="0" max="100" class="w-full [&::-webkit-progress-bar]:rounded-lg [&::-webkit-progress-value]:rounded-lg [&::-webkit-progress-bar]:bg-slate-200 [&::-webkit-progress-value]:bg-indigo-600 [&::-moz-progress-bar]:bg-indigo-600"></progress>
                    </div>
                    
                    <div id="status" class="text-center font-semibold text-slate-600 bg-slate-100 p-4 rounded-lg">Loading AI models... üß†</div>
                    <div id="results" class="hidden max-h-40 overflow-y-auto bg-slate-50 p-4 rounded-lg border border-slate-200 text-sm"></div>
                    <div id="manual-blur-info" class="hidden text-center text-sm font-medium text-indigo-800 bg-indigo-100 p-4 rounded-lg border border-indigo-200">
                        Click a thumbnail below to open the large preview for manual blurring and to add risk notes. You can also drag-and-drop to reorder images.
                    </div>
                    <button id="processBtn" disabled class="w-full bg-indigo-600 text-white font-semibold py-3 px-5 rounded-lg shadow-md hover:bg-indigo-700 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">Process Files</button>
                </div>
                <div id="videoSection" class="hidden mt-8">
                    <h3 class="text-xl font-semibold text-slate-800 mb-4">Uploaded Videos (Capture frames below)</h3>
                    <div id="videoGallery" class="bg-slate-50 p-4 rounded-lg border border-slate-200 flex flex-wrap gap-4 justify-center">
                        <p class="text-slate-500">Uploaded videos will appear here...</p>
                    </div>
                </div>
                <div id="imageGallery" class="mt-8 grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10 gap-4 bg-slate-50 p-4 rounded-lg border border-slate-200 min-h-[120px]">
                    <p class="text-slate-500 col-span-full text-center">Processed images/frames will appear here...</p>
                </div>
                <div class="mt-6 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
                    <button id="downloadBtn" style="display: none;" class="w-full bg-green-600 text-white font-semibold py-3 px-5 rounded-lg shadow-md hover:bg-green-700 transition duration-300 disabled:opacity-50">Download All Images and Reports as ZIP</button>
                    <button id="generateAiReportBtn" style="display: none;" class="w-full bg-amber-500 text-black font-semibold py-3 px-5 rounded-lg shadow-md hover:bg-amber-600 transition duration-300 disabled:opacity-50">Generate AI Risk Assessment from Image Notes</button>
                    <button id="saveProjectBtn" style="display: none;" class="w-full bg-blue-600 text-white font-semibold py-3 px-5 rounded-lg shadow-md hover:bg-blue-700 transition duration-300">Save Project</button>
                    <button id="loadProjectBtn" class="w-full bg-purple-600 text-white font-semibold py-3 px-5 rounded-lg shadow-md hover:bg-purple-700 transition duration-300">Load Project</button>
                </div>
                <input type="file" id="projectFileInput" accept=".json" class="hidden">
                <canvas id="manualBlurCanvas" style="display: none;"></canvas>
            </div>
        </section>

        <section id="tab-content-free-text" class="tab-content bg-white rounded-2xl shadow-xl p-6 sm:p-8 space-y-6 hidden">
            <!-- Free Text Stream Content -->
            <h2 class="text-2xl font-bold text-slate-900">‚úçÔ∏è Describe Your Task</h2>
            <p class="text-slate-600">Write a detailed description of the work process. Mention any previous incidents for better risk scoring.</p>
            
            <div class="bg-gradient-to-br from-indigo-50 to-blue-50 p-6 rounded-lg border border-indigo-200">
                <textarea id="freeTextInput" rows="6" placeholder="Start writing here... e.g., 'Every morning, I use a forklift to get a heavy pallet from the warehouse...'" class="w-full p-4 border border-indigo-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition font-medium"></textarea>
                <button id="generateTasksBtn" class="mt-4 w-full bg-indigo-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-indigo-700 transition duration-300 disabled:opacity-50">Generate Task Breakdown</button>
            </div>
        </section>

        <section id="tab-content-excel" class="tab-content bg-white rounded-2xl shadow-xl p-6 sm:p-8 space-y-6 hidden">
            <!-- Excel Sheet Stream Content -->
            <h2 class="text-2xl font-bold text-slate-900">üìä Import Excel File</h2>
            <p class="text-slate-600">Upload an Excel file containing risk data. The system will parse and convert it to risk assessment format.</p>
            
            <div class="bg-gradient-to-br from-green-50 to-emerald-50 p-6 rounded-lg border-2 border-dashed border-green-300 text-center cursor-pointer hover:bg-green-100 transition">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 text-green-600 mx-auto mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
                <input type="file" id="excelUpload" accept=".xlsx,.xls,.csv" class="hidden" />
                <label for="excelUpload" class="cursor-pointer">
                    <p class="text-lg font-semibold text-green-900">Click to select Excel file</p>
                    <p class="text-sm text-green-700 mt-1">Supported: .xlsx, .xls, .csv</p>
                </label>
            </div>
            <button onclick="document.getElementById('excelImportModal').style.display='flex'" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition">üìÇ Advanced Import / Convert</button>
        </section>
        
        <hr class="border-t-2 border-dashed border-slate-300 my-8 sm:my-12">

        <!-- Risk Assessment Section (Works across all tabs) -->
        <section id="risk-generator-app" class="bg-white rounded-2xl shadow-xl overflow-hidden">
            <div class="p-6 sm:p-8 space-y-6">
                <div class="grid grid-cols-1 lg:grid-cols-1 gap-6">
                        <div class="bg-gradient-to-br from-amber-50 to-orange-50 p-6 rounded-lg border border-amber-200">
                        <h3 class="text-lg font-bold text-amber-900 mb-3">üí° Pro Tips</h3>
                        <ul class="space-y-2 text-sm text-amber-800">
                            <li>‚Ä¢ Mention past incidents for more accurate scoring</li>
                            <li>‚Ä¢ Add detailed hazard descriptions in notes</li>
                            <li>‚Ä¢ Review AI suggestions before finalizing</li>
                            <li>‚Ä¢ Save your Project and resume your work </li>
                        </ul>
                    </div>
                </div>
            <div id="dashboard-container" style="display: none;">
                <h1 class="text-3xl font-bold text-white bg-gradient-to-r from-indigo-700 to-blue-800 p-6 sm:p-8 flex flex-col sm:flex-row items-center justify-center gap-4 text-center">

                    RISK ASSESSMENT
                </h1>
                
                <div class="p-6 sm:p-8 bg-slate-50 grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-white p-4 rounded-lg shadow-md border border-slate-200">
                        <div id="riskChart"></div>
                        <div id="chartError" class="hidden text-red-600 text-center p-4">Could not load risk chart.</div>
                    </div>
                    <div class="bg-white p-4 rounded-lg shadow-md border border-slate-200">
                        <div id="hazardChart"></div>
                        <div id="hazardChartError" class="hidden text-red-600 text-center p-4">Could not load hazard chart.</div>
                    </div>
                </div>
                <div class="p-6 sm:p-8 bg-white">
                    <div class="overflow-x-auto">
                        <table class="w-full text-left">
                            <thead>
                                <tr class="bg-slate-100">
                                    <th class="p-4 font-semibold text-slate-700 rounded-l-lg">Average Risk Score</th>
                                    <th class="p-4 font-semibold text-slate-700">Highest Risk Details</th>
                                    <th class="p-4 font-semibold text-slate-700 rounded-r-lg">Last Reviewed</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="border-b border-slate-100">
                                    <td class="p-4 text-slate-600"><span id="avgScore" class="text-2xl font-bold text-indigo-700"></span></td>
                                    <td class="p-4 text-slate-600" id="highestCard"></td>
                                    <td class="p-4 text-slate-600"><span id="lastReviewed"></span></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
               <div class="p-6 sm:p-8 bg-slate-50">
            <h2 class="text-2xl font-bold text-slate-900 mb-4">2. Generate AI Recommendations</h2>
            
            <div class="flex flex-col sm:flex-row gap-4 items-center">
                <button class="w-full sm:w-auto bg-green-600 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-green-700 transition duration-300" onclick="generateRecommendations()">Generate AI Recommendations & Visuals</button>
                
                <div class="w-full sm:w-auto">
                    <label for="recCountSelect" class="text-sm font-medium text-slate-700 mr-2">For the:</label>
                    <select id="recCountSelect" class="w-auto p-2 border border-slate-300 rounded-md bg-white focus:ring-2 focus:ring-indigo-500 transition">
                        <option value="5" selected>Top 5 Risks</option>
                        <option value="10">Top 10 Risks</option>
                        <option value="all">All High/Medium Risks</option>
                    </select>
                </div>
            </div>

            <div id="recommendations" class="mt-4 bg-white p-6 rounded-lg shadow-inner border border-slate-200 min-h-[100px]">
                <p class="text-slate-500 italic">Click the button above to generate mitigation advice for the highest-risk tasks.</p>
            </div>
        </div>
                <div class="p-6 sm:p-8 bg-white border-t border-slate-200">
                    <div class="flex flex-col sm:flex-row justify-between items-center gap-4">

                        <div class="flex gap-4 w-full sm:w-auto flex-wrap">
                            <button class="flex-1 sm:flex-none bg-slate-600 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-slate-700 transition duration-300" onclick="window.print();">Print</button>
                            <button id="translateTableBtn" class="flex-1 sm:flex-none bg-amber-600 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-amber-700 transition duration-300">Translate Table</button>
                            <button id="downloadProjectZipBtn" class="flex-1 sm:flex-none bg-blue-600 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-blue-700 transition duration-300">Download Project ZIP</button>
                            
                        </div>
                </div>
                <div class="table-wrapper overflow-x-auto" id="table-container">
                    </div>
            </div>
        </section>
    </main>
    <footer class="text-center py-8 text-slate-500">
        <button id="privacyBtn" class="text-indigo-600 hover:text-indigo-800 hover:underline font-medium transition">Privacy Policy</button>
    </footer>
    <div id="lightboxModal" class="lightbox-overlay hidden fixed inset-0 z-50 bg-black/80 backdrop-blur-sm p-4 items-center justify-center" style="display: none;">
        <span id="closeLightbox" class="absolute top-4 right-6 text-white text-5xl font-bold cursor-pointer hover:text-slate-300 transition">&times;</span>
        
        <span id="prevArrow" class="lightbox-arrow absolute left-4 top-1/2 -translate-y-1/2 text-white text-3xl p-4 cursor-pointer hover:bg-black/20 rounded-full transition">&#10094;</span>
        
        <div class="lightbox-content w-full max-w-6xl">
            <div class="lightbox-main-area flex flex-col md:flex-row gap-6">
                <div class="image-wrapper flex-auto w-full md:w-2/3">
                    <img id="lightboxImage" alt="Large preview for blurring" class="w-full h-auto max-h-[75vh] object-contain rounded-lg shadow-xl cursor-crosshair bg-black">
                </div>
                <div class="lightbox-form-wrapper flex-none w-full md:w-1/3 bg-white p-6 rounded-lg shadow-lg max-h-[75vh] overflow-y-auto">
                    <form id="lightboxForm" onsubmit="return false;" class="space-y-4">
    <div class="relative">
        <label for="stepDescription" class="block text-sm font-semibold text-slate-700 mb-1">Description of step:</label>
        <textarea id="stepDescription" rows="4" class="w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition pr-10"></textarea>
        <button type="button" class="speech-btn absolute bottom-2 right-2 bg-indigo-600 text-white p-2 rounded-full hover:bg-indigo-700 transition focus:outline-none" data-target="stepDescription">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
            </svg>
        </button>
    </div>
    <div class="relative">
        <label for="spotHazards" class="block text-sm font-semibold text-slate-700 mb-1">What can go wrong / spot hazards:</label>
        <textarea id="spotHazards" rows="4" class="w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition pr-10"></textarea>
        <button type="button" class="speech-btn absolute bottom-2 right-2 bg-indigo-600 text-white p-2 rounded-full hover:bg-indigo-700 transition focus:outline-none" data-target="spotHazards">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
            </svg>
        </button>
    </div>
    <div class="relative">
        <label for="existingControls" class="block text-sm font-semibold text-slate-700 mb-1">Any existing controls:</label>
        <textarea id="existingControls" rows="4" class="w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition pr-10"></textarea>
        <button type="button" class="speech-btn absolute bottom-2 right-2 bg-indigo-600 text-white p-2 rounded-full hover:bg-indigo-700 transition focus:outline-none" data-target="existingControls">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
            </svg>
        </button>
    </div>

    <!-- Optional: User-defined Risk Ratings -->
    <div class="border-t border-slate-200 pt-4 mt-4">
        <p class="text-xs font-semibold text-slate-600 mb-3 uppercase">Optional: Set Risk Rating (AI will enhance)</p>
        <div class="grid grid-cols-3 gap-2">
            <div>
                <label for="userFrequency" class="block text-xs font-medium text-slate-700 mb-1">Frequency:</label>
                <select id="userFrequency" class="w-full p-2 text-xs border border-slate-300 rounded-md bg-white focus:ring-1 focus:ring-indigo-500 transition">
                    <option value="">Not set</option>
                    <option value="1">1 - RARELY</option>
                    <option value="1.25">1.25 - OCCASIONAL</option>
                    <option value="1.5">1.5 - INTERMEDIATE</option>
                    <option value="1.75">1.75 - FREQUENTLY</option>
                    <option value="2">2 - PERMANENT</option>
                </select>
            </div>
            <div>
                <label for="userSeverity" class="block text-xs font-medium text-slate-700 mb-1">Severity:</label>
                <select id="userSeverity" class="w-full p-2 text-xs border border-slate-300 rounded-md bg-white focus:ring-1 focus:ring-indigo-500 transition">
                    <option value="">Not set</option>
                    <option value="1">1 - No potential of injury</option>
                    <option value="3">3 - Potential of FIRST AID</option>
                    <option value="5">5 - Potential of MEDICAL TREATMENT</option>
                    <option value="7">7 - Potential of DART</option>
                    <option value="9">9 - Potential of SIA</option>
                    <option value="10">10 - Potential of Fatality</option>
                </select>
            </div>
            <div>
                <label for="userLikelihood" class="block text-xs font-medium text-slate-700 mb-1">Likelihood:</label>
                <select id="userLikelihood" class="w-full p-2 text-xs border border-slate-300 rounded-md bg-white focus:ring-1 focus:ring-indigo-500 transition">
                    <option value="">Not set</option>
                    <option value="1">1 - Almost impossible</option>
                    <option value="3">3 - Very unlikely</option>
                    <option value="5">5 - Possible to happen</option>
                    <option value="8">8 - Likely to happen</option>
                    <option value="10">10 - Very likely to happen</option>
                </select>
            </div>
        </div>
    </div>
</form>
                </div>
            </div>
            
            <div class="lightbox-controls mt-4 flex flex-col sm:flex-row gap-4 justify-center">
                <button id="undoBlurBtn" disabled class="bg-amber-500 text-black font-semibold py-2 px-5 rounded-lg shadow-md hover:bg-amber-600 transition duration-300 disabled:opacity-50">Undo Last Manual Blur</button>
                
                <button id="replaceImageBtn" class="bg-blue-600 text-white font-semibold py-2 px-5 rounded-lg shadow-md hover:bg-blue-700 transition duration-300">Replace Image</button>
                <input type="file" id="replaceImageInput" accept="image/*" class="hidden">

                <button id="deleteLightboxBtn" class="bg-red-600 text-white font-semibold py-2 px-5 rounded-lg shadow-md hover:bg-red-700 transition duration-300">Delete Image</button>
            </div>
            <div id="lightboxGallery" class="mt-6 flex gap-2 justify-center p-3 overflow-x-auto bg-black/20 rounded-lg">
                </div>
        </div>
        
        <span id="nextArrow" class="lightbox-arrow absolute right-4 top-1/2 -translate-y-1/2 text-white text-3xl p-4 cursor-pointer hover:bg-black/20 rounded-full transition">&#10095;</span>
    </div>
    <div id="privacyModal" class="modal-overlay hidden fixed inset-0 z-[100] bg-black/60 backdrop-blur-sm p-4 items-center justify-center" style="display: none;">
        <div class="modal-content bg-white m-auto p-6 sm:p-8 rounded-lg shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-y-auto relative">
            <span id="closeModal" class="close-btn absolute top-4 right-5 text-slate-400 text-3xl font-bold cursor-pointer hover:text-slate-600 transition">&times;</span>
            <h2 class="text-2xl font-bold text-slate-900 mb-6">Privacy Policy</h2>
            
<div class="space-y-6 text-slate-700">
    <div class="p-4 bg-green-50 border border-green-200 rounded-lg">
        <h3 class="text-lg font-semibold text-green-900 mb-2">1. Face Blurrer & File Processing</h3>
        <ul class="list-disc list-inside space-y-1">
            <li>üö´ <strong class="font-semibold">No Server Uploads:</strong> Your images and videos are <strong class="font-semibold">NEVER</strong> uploaded to any server.</li>
            <li>üíª <strong class="font-semibold">100% Local Processing:</strong> All processing, including face detection, blurring, resizing, PDF/LaTeX/JSON report generation, and .zip file creation, happens entirely within your web browser on your own device using local libraries and models.</li>
            <li>üîí <strong class="font-semibold">Data Control:</strong> Your files and entered data (descriptions, hazards, controls) never leave your computer unless you explicitly download and share the ZIP or JSON files yourself. Data is stored temporarily in browser memory/cache; clear your browser to delete it.</li>
        </ul>
    </div>
  
    <div class="p-4 bg-amber-50 border border-amber-200 rounded-lg">
        <h3 class="text-lg font-semibold text-amber-900 mb-2">2. AI Risk Assessment Generator</h3>
        <ul class="list-disc list-inside space-y-1">
            <li>üì§ <strong class="font-semibold">External API Call:</strong> For AI-powered task breakdowns and recommendations, only text-based risk assessment data is sent to a third-party AI service (OpenRouter). This includes: step descriptions, hazard identifications, control measures, and user-provided ratings (Frequency, Severity, Likelihood). No images or videos are sent. Data is subject to <a href="https://openrouter.ai/privacy" target="_blank">OpenRouter's Privacy Policy</a>.</li>
            <li>üì¶ <strong class="font-semibold">Batching:</strong> Multiple assessment entries may be processed together in batches to improve efficiency.</li>
            <li>‚ö†Ô∏è <strong class="font-semibold">Do Not Include Sensitive Data:</strong> Avoid including personal info (names, addresses, employee names, etc.) in text fields, as it's processed externally.</li>
            <li><strong class="font-semibold">Anonymous Data:</strong> Text is not tied to your identity; however, the service may log IP addresses.</li>
        </ul>
    </div>
    <div class="p-4 bg-blue-50 border border-blue-200 rounded-lg">
        <h3 class="text-lg font-semibold text-blue-900 mb-2">3. Save/Load Project</h3>
        <ul class="list-disc list-inside space-y-1">
            <li>üíæ <strong class="font-semibold">Local JSON Files:</strong> Saving projects creates a JSON file with your notes and base64-encoded images‚Äîall processed locally. Loading reads from your device only.</li>
            <li>‚ö†Ô∏è <strong class="font-semibold">Sharing Risks:</strong> If you share the JSON file, it includes your notes and images (encoded); review before sharing.</li>
        </ul>
    </div>
    <div class="p-4 bg-blue-50 border border-blue-200 rounded-lg">
        <h3 class="text-lg font-semibold text-blue-900 mb-2">4. Table Translation</h3>
        <ul class="list-disc list-inside space-y-1">
            <li>üåê <strong class="font-semibold">Optional Feature:</strong> This is an optional feature that translates table columns into multiple languages using MyMemory Translation API.</li>
            <li><strong class="font-semibold">Data Sent:</strong> If used, only the text content from selected table columns (Steps, Hazard Source, Current Control) is sent to MyMemory's translation service. No images or sensitive identifiers are sent.</li>
            <li><strong class="font-semibold">Data Usage:</strong> MyMemory Translation API is a free, open-source service. Review <a href="https://mymemory.translated.net/" target="_blank">MyMemory's privacy information</a> for details on how they handle data.</li>
        </ul>
    </div>
    <div class="p-4 bg-indigo-50 border border-indigo-200 rounded-lg">
        <h3 class="text-lg font-semibold text-indigo-900 mb-2">5. External Libraries and Services</h3>
        <ul class="list-disc list-inside space-y-1">
            <li>üìö <strong class="font-semibold">CDNs and Scripts:</strong> Libraries like Tailwind CSS, DOMPurify, face-api.js, JSZip, PDFKit, and blob-stream are loaded from CDNs/local for functionality. They may collect minimal data (e.g., IP for delivery). Review their policies if concerned.</li>
            <li>üìä <strong class="font-semibold">Google Charts:</strong> Used for dashboards; may send anonymized data to Google. See <a href="https://policies.google.com/privacy" target="_blank">Google's Policy</a>.</li>
        </ul>
    </div>
    <div class="p-4 bg-slate-50 border border-slate-200 rounded-lg">
        <h3 class="text-lg font-semibold text-slate-900 mb-2">6. General</h3>
        <ul class="list-disc list-inside space-y-1">
            <li>üç™ <strong class="font-semibold">No Cookies or Tracking:</strong> No cookies, trackers, or analytics are used.</li>
        </ul>
    </div>
    <div class="p-4 bg-purple-50 border border-purple-200 rounded-lg">
        <h3 class="text-lg font-semibold text-purple-900 mb-2">7. Risks and Limitations</h3>
        <ul class="list-disc list-inside space-y-1">
            <li>‚ö†Ô∏è Browser extensions or malware could access local data‚Äîuse secure devices.</li>
            <li>ZIP/JSON files may contain metadata; remove if sensitive before sharing.</li>
            <li>AI outputs are suggestions; always verify for safety compliance.</li>
        </ul>
    </div>
   

</div>
        </div>
    </div>

    <!-- Translation Dialog Modal -->
    <div id="translationModal" class="modal-overlay hidden fixed inset-0 z-[100] bg-black/60 backdrop-blur-sm p-4 flex items-center justify-center" style="display: none;">
        <div class="modal-content bg-white rounded-lg shadow-2xl p-6 max-w-md w-full">
            <h2 class="text-2xl font-bold text-slate-900 mb-4">Translate Table Columns</h2>
            
            <!-- Language Selector -->
            <div class="mb-6">
                <label class="block text-sm font-semibold text-slate-700 mb-2">Target Language:</label>
                <select id="translationLangSelect" class="w-full p-2 border border-slate-300 rounded-md bg-white focus:ring-2 focus:ring-indigo-500 transition">
                    <option value="en">English (no translation)</option>
                    <option value="fr">Fran√ßais (French)</option>
                    <option value="de">Deutsch (German)</option>
                    <option value="es">Espa√±ol (Spanish)</option>
                    <option value="it">Italiano (Italian)</option>
                    <option value="pt">Portugu√™s (Portuguese)</option>
                </select>
            </div>

            <!-- Column Selection Checkboxes -->
            <div class="mb-6">
                <label class="block text-sm font-semibold text-slate-700 mb-3">Select columns to translate:</label>
                <div class="space-y-2">
                    <label class="flex items-center">
                        <input type="checkbox" id="translateSteps" class="translation-checkbox w-4 h-4 text-indigo-600 rounded focus:ring-2 focus:ring-indigo-500" checked>
                        <span class="ml-2 text-slate-700">Steps</span>
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" id="translateHazardSource" class="translation-checkbox w-4 h-4 text-indigo-600 rounded focus:ring-2 focus:ring-indigo-500" checked>
                        <span class="ml-2 text-slate-700">Hazard Source</span>
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" id="translateCurrentControl" class="translation-checkbox w-4 h-4 text-indigo-600 rounded focus:ring-2 focus:ring-indigo-500" checked>
                        <span class="ml-2 text-slate-700">Current Control</span>
                    </label>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex gap-2 flex-col">
                <div class="flex gap-2">
                    <button id="translateConfirmBtn" class="flex-1 bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300">Translate</button>
                    <button id="translateCancelBtn" class="flex-1 bg-slate-400 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-500 transition duration-300">Cancel</button>
                </div>
                <button id="revertTranslationsBtn" class="w-full bg-orange-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-orange-700 transition duration-300" title="Revert all translations to original values">Revert All Translations</button>
            </div>
            <div id="translationStatus" class="mt-4 text-sm text-slate-600 text-center hidden"></div>
        </div>
    </div>
    </div>
    <div id="tableImageModal" class="modal-overlay hidden fixed inset-0 z-[100] bg-black/70 backdrop-blur-sm p-4 items-center justify-center" style="display: none;">
    <div class="modal-content bg-white m-auto p-6 sm:p-8 rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] overflow-y-auto relative flex flex-col md:flex-row gap-6">
        <span id="closeTableImageModal" class="close-btn absolute top-3 right-4 text-slate-400 text-4xl font-bold cursor-pointer hover:text-slate-600 transition">&times;</span>

        <div class="w-full md:w-1/2 flex-shrink-0">
            <h3 class="text-lg font-semibold text-slate-800 mb-2">Image Preview</h3>
            <img id="modalEnlargedImage" src="" alt="Enlarged step image" class="w-full h-auto max-h-[70vh] object-contain rounded border border-slate-300 bg-slate-100">
        </div>

        <div class="w-full md:w-1/2 space-y-3 overflow-y-auto">
             <h3 class="text-lg font-semibold text-slate-800 mb-2">Risk Details</h3>
             <div id="modalRiskDetails" class="text-sm text-slate-700 space-y-2">
                 <p>Loading details...</p>
             </div>
        </div>
    </div>
</div>
</div>
¬† ¬† </div>

<div id="toast-container" class="fixed top-4 right-4 z-[200] w-full max-w-xs space-y-3">
    </div>

<div id="confirmModal" class="modal-overlay hidden fixed inset-0 z-[150] bg-black/60 backdrop-blur-sm p-4 items-center justify-center" style="display: none;">
    <div class="modal-content bg-white m-auto p-6 rounded-lg shadow-2xl w-full max-w-sm">
        <h2 id="confirmTitle" class="text-lg font-semibold text-slate-900 mb-4">Are you sure?</h2>
        <p id="confirmMessage" class="text-slate-600 mb-6">This action cannot be undone.</p>
        <div class="flex justify-end gap-4">
            <button id="confirmCancelBtn" class="bg-slate-200 text-slate-800 font-semibold py-2 px-5 rounded-lg hover:bg-slate-300 transition">
                Cancel
            </button>
            <button id="confirmOkBtn" class="bg-red-600 text-white font-semibold py-2 px-5 rounded-lg hover:bg-red-700 transition">
                Confirm
            </button>
        </div>
    </div>
</div>

<script>
    // --- Tab Switching Function (Modern UI) ---
    function switchTab(tabName) {
        // Hide all tab content
        const tabContents = document.querySelectorAll('.tab-content');
        tabContents.forEach(tab => tab.classList.add('hidden'));
        
        // Remove active state from all tab buttons
        const tabButtons = document.querySelectorAll('.tab-btn');
        tabButtons.forEach(btn => {
            btn.classList.remove('bg-white/10', 'border-yellow-400');
            btn.classList.add('border-transparent');
        });
        
        // Show selected tab content
        const selectedContent = document.getElementById(`tab-content-${tabName}`);
        if (selectedContent) {
            selectedContent.classList.remove('hidden');
        }
        
        // Highlight selected tab button
        const selectedButton = document.getElementById(`tab-${tabName}`);
        if (selectedButton) {
            selectedButton.classList.add('bg-white/10', 'border-yellow-400');
            selectedButton.classList.remove('border-transparent');
        }
        
        console.debug(`Switched to tab: ${tabName}`);
    }

    // Initialize first tab on page load
    document.addEventListener('DOMContentLoaded', function() {
        switchTab('rich-media');
    });

    // Make switchTab globally accessible for other functions
    window.switchTab = switchTab;

    // --- Global Google Translate Initializer ---
    // Moved outside IIFEs to be globally accessible

    // --- Make deterministic filename generator global ---
    // Produces the same `final_###_sanitized.ext` name used when creating ZIP files.
    function createFinalFileName(originalFileName, index) {
        const lastDotIndex = (originalFileName || '').lastIndexOf('.');
        const baseName = lastDotIndex !== -1 ? originalFileName.substring(0, lastDotIndex) : (originalFileName || `image`);
        const extension = lastDotIndex !== -1 ? originalFileName.substring(lastDotIndex) : '.jpg';
        const sanitizedBase = baseName.replace(/[^a-zA-Z0-9_-]/g, '_') || 'image';
        return `final_${String(index + 1).padStart(3, '0')}_${sanitizedBase}${extension}`;
    }
    // --- APP 1 (RISK GENERATOR) SCRIPT ---
    (function() {

        const spinnerSVG = `<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
        // --- FIX: Attach click listener to the 'Generate Task Breakdown' button ---
        document.addEventListener('DOMContentLoaded', () => {
            const genBtn = document.getElementById('generateTasksBtn');
            if (genBtn) {
                // We link it to window.processFreeText, which is defined just below
                genBtn.addEventListener('click', window.processFreeText);
            } else {
                console.error("Could not find 'generateTasksBtn' to attach listener.");
            }
        });
        // --- END FIX ---
        // --- CONFIGURATION ---
        
    // NOTE: API key included for testing in this local copy. For production,
    // move this key to a secure server-side proxy or environment variable.
    const API_KEY = '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';
        
        const API_URL = 'https://openrouter.ai/api/v1/chat/completions';
        const PRIMARY_FREE_MODEL = 'mistralai/mistral-7b-instruct:free';
        const SECONDARY_FREE_MODEL = 'google/gemma-7b-it:free';
        const PAID_MODEL = 'openai/gpt-4o-mini'; // Faster model: ~3-5x speed vs gpt-4o, excellent for task breakdown

        // --- MULTILINGUAL TRANSLATIONS (English, French, German) ---
        const TRANSLATIONS = {
  en: {
    // Hazard Groups (English defaults)
    "Mechanical / Machinery hazards": "Mechanical / Machinery hazards",
    "Workplace / Infrastructure Design": "Workplace / Infrastructure Design",
    "Physical health hazards": "Physical health hazards",
    "Chemical hazards": "Chemical hazards",
    "Hazardous Energy": "Hazardous Energy",
    "Transportation": "Transportation",
    "Ergonomic hazards": "Ergonomic hazards",
    "Organizational and Psychosocial": "Organizational and Psychosocial",
    "Biological hazard": "Biological hazard",
    "Fire and explosion": "Fire and explosion",
    // Frequency Scale
    "RARELY (<30 min/day)": "RARELY (<30 min/day)",
    "OCCASIONAL (<2 hrs/wk)": "OCCASIONAL (<2 hrs/wk)",
    "INTERMEDIATE (2-8 hrs/wk)": "INTERMEDIATE (2-8 hrs/wk)",
    "FREQUENTLY (1-3 days/wk)": "FREQUENTLY (1-3 days/wk)",
    "PERMANENT (>3 days/wk)": "PERMANENT (>3 days/wk)",
    // Severity Scale
    "No potential of injury": "No potential of injury",
    "Potential of FIRST AID": "Potential of FIRST AID",
    "Potential of MEDICAL TREATMENT": "Potential of MEDICAL TREATMENT",
    "Potential of DART": "Potential of DART",
    "Potential of SIA": "Potential of SIA",
    "Potential of Fatality": "Potential of Fatality",
    // Likelihood Scale
    "Almost impossible": "Almost impossible",
    "Very unlikely": "Very unlikely",
    "Possible to happen": "Possible to happen",
    "Likely to happen": "Likely to happen",
    "Very likely to happen": "Very likely to happen",
    // Hazard List Items (English)
    "Hand tools (cut, impact, puncture, etc.)": "Hand tools (cut, impact, puncture, etc.)",
    "Powered tools": "Powered tools",
    "Pinch / nip points": "Pinch / nip points",
    "Rotating parts (entanglement)": "Rotating parts (entanglement)",
    "Moving parts (cutting)": "Moving parts (cutting)",
    "Moving parts (crushing)": "Moving parts (crushing)",
    "Ejection (parts, materials)": "Ejection (parts, materials)",
    "Angular, sharp and cutting elements": "Angular, sharp and cutting elements",
    "Degraded or malfunctioning equipment": "Degraded or malfunctioning equipment",
    "Equipment failure": "Equipment failure",
    "Improper use of tools/machines": "Improper use of tools/machines",
    "Inadequate guarding": "Inadequate guarding",
    "Use of lifting equipment and accessories": "Use of lifting equipment and accessories",
    "Use of suspension equipment (jacks, etc.)": "Use of suspension equipment (jacks, etc.)",
    "Acceleration / deceleration": "Acceleration / deceleration",
    "Slips, trips, and falls (same level or height)": "Slips, trips, and falls (same level or height)",
    "Slippery, uneven, unstable or damaged floor": "Slippery, uneven, unstable or damaged floor",
    "Congested or obstructed workplace": "Congested or obstructed workplace",
    "Clutter / Mess": "Clutter / Mess",
    "Protrusion (bump, puncture, cut, etc.)": "Protrusion (bump, puncture, cut, etc.)",
    "Hot surface": "Hot surface",
    "Cold surface": "Cold surface",
    "Rough surface": "Rough surface",
    "Unsecured items at height": "Unsecured items at height",
    "Work at height (<1.2m - <4 feet)": "Work at height (<1.2m - <4 feet)",
    "Work at height (‚â•1.2m - ‚â•4 feet)": "Work at height (‚â•1.2m - ‚â•4 feet)",
    "Poor ventilation": "Poor ventilation",
    "Extreme heat": "Extreme heat",
    "Extreme cold": "Extreme cold",
    "Snow or ice": "Snow or ice",
    "Extreme wind": "Extreme wind",
    "Other adverse weather conditions": "Other adverse weather conditions",
    "Confined spaces": "Confined spaces",
    "Lone work": "Lone work",
    "Temporary works or unstable structures": "Temporary works or unstable structures",
    "Engulfment": "Engulfment",
    "Inclined surface": "Inclined surface",
    "Poor visibility": "Poor visibility",
    "Coactivity area": "Coactivity area",
    "Noise exposure": "Noise exposure",
    "Vibration / Impact (hand-arm, whole-body)": "Vibration / Impact (hand-arm, whole-body)",
    "Heat stress": "Heat stress",
    "Cold stress": "Cold stress",
    "Poor lighting (intensity, glare, reflection)": "Poor lighting (intensity, glare, reflection)",
    "Electro-magnetic fields": "Electro-magnetic fields",
    "Ionizing radiation (X-rays, radioactive elements)": "Ionizing radiation (X-rays, radioactive elements)",
    "Non-ionizing radiation (UV, microwave, laser, welding radiations)": "Non-ionizing radiation (UV, microwave, laser, welding radiations)",
    "Severe draft (e.g. cold air current)": "Severe draft (e.g. cold air current)",
    "Smoke and fumes": "Smoke and fumes",
    "Physical health [Generic]": "Physical health [Generic]",
    "Explosive materials": "Explosive materials",
    "Flammable materials": "Flammable materials",
    "Oxidising materials": "Oxidising materials",
    "Corrosive materials": "Corrosive materials",
    "Acute toxicity materials": "Acute toxicity materials",
    "Health hazard, sensitizers, allergens materials": "Health hazard, sensitizers, allergens materials",
    "Carcinogens, mutagens, reprotoxic (CMRs) materials": "Carcinogens, mutagens, reprotoxic (CMRs) materials",
    "Gas under pressure": "Gas under pressure",
    "Asbestos": "Asbestos",
    "Fibers other than asbestos": "Fibers other than asbestos",
    "Oil": "Oil",
    "Crystalline silica": "Crystalline silica",
    "Organic peroxides": "Organic peroxides",
    "Nanomaterials": "Nanomaterials",
    "Endocrine disrupters": "Endocrine disrupters",
    "Lead-containing material": "Lead-containing material",
    "Particulate material (dust, smoke, fog, aerosol)": "Particulate material (dust, smoke, fog, aerosol)",
    "Improper labeling or storage": "Improper labeling or storage",
    "Incompatible chemical reactions": "Incompatible chemical reactions",
    "Chemical spills or leaks": "Chemical spills or leaks",
    "Water reactive substances": "Water reactive substances",
    "Shock / vibration sensitive substances": "Shock / vibration sensitive substances",
    "Chemicals [Generic]": "Chemicals [Generic]",
    "Electricity": "Electricity",
    "Electrostatic": "Electrostatic",
    "Electromagnetic fields": "Electromagnetic fields",
    "Arc flash": "Arc flash",
    "Magnetic": "Magnetic",
    "Equipment under pressure": "Equipment under pressure",
    "Compressed air": "Compressed air",
    "Vacuum": "Vacuum",
    "Hydraulic": "Hydraulic",
    "Pneumatic": "Pneumatic",
    "Thermal energy (steam, heated surfaces)": "Thermal energy (steam, heated surfaces)",
    "Kinetic energy": "Kinetic energy",
    "Gravity": "Gravity",
    "Stored energy (pneumatic, hydraulic, mechanical, electrical)": "Stored energy (pneumatic, hydraulic, mechanical, electrical)",
    "Exothermic chemical reaction": "Exothermic chemical reaction",
    "Hazardous Energy [Generic]": "Hazardous Energy [Generic]",
    "Interaction pedestrian/pedestrian": "Interaction pedestrian/pedestrian",
    "Interaction pedestrian/bicycle": "Interaction pedestrian/bicycle",
    "Interaction pedestrian/Vehicle": "Interaction pedestrian/Vehicle",
    "Interaction bicycle/bicycle": "Interaction bicycle/bicycle",
    "Interaction bicycle/Vehicle": "Interaction bicycle/Vehicle",
    "Interaction Vehicle/Vehicle": "Interaction Vehicle/Vehicle",
    "Interaction Vehicle/Stationary items": "Interaction Vehicle/Stationary items",
    "Poor road or yard conditions": "Poor road or yard conditions",
    "Unintentional vehicle movement": "Unintentional vehicle movement",
    "High speed vehicle, tire grip loss": "High speed vehicle, tire grip loss",
    "Inadequate load securing": "Inadequate load securing",
    "Traffic [Generic]": "Traffic [Generic]",
    "Postures (Hit list)": "Postures (Hit list)",
    "Force": "Force",
    "Lifting/Lowering": "Lifting/Lowering",
    "Pushing": "Pushing",
    "Pulling": "Pulling",
    "Carrying": "Carrying",
    "Soft tissue compression": "Soft tissue compression",
    "Ill-fitting gloves": "Ill-fitting gloves",
    "Standing or Sitting for long periods": "Standing or Sitting for long periods",
    "Computer workstation / Screen": "Computer workstation / Screen",
    "Inadequate tool or workstation design": "Inadequate tool or workstation design",
    "Poor ergonomics [Generic]": "Poor ergonomics [Generic]",
    "Ambiguity of the roles and responsibilities": "Ambiguity of the roles and responsibilities",
    "Inadequate staffing": "Inadequate staffing",
    "High job demands (physical or mental workload)": "High job demands (physical or mental workload)",
    "Low job control or autonomy": "Low job control or autonomy",
    "Monotonous or repetitive tasks": "Monotonous or repetitive tasks",
    "Unclear job roles or expectations": "Unclear job roles or expectations",
    "Job insecurity or precarious employment": "Job insecurity or precarious employment",
    "Long working hours or shift work": "Long working hours or shift work",
    "Unrealistic deadlines": "Unrealistic deadlines",
    "Coactivity": "Coactivity",
    "Unfamiliar work": "Unfamiliar work",
    "New hire / temporary worker": "New hire / temporary worker",
    "Insufficient / inadequate training": "Insufficient / inadequate training",
    "Violations of rules": "Violations of rules",
    "Misuse of computer systems / equipment": "Misuse of computer systems / equipment",
    "Lack of adherence to standard": "Lack of adherence to standard",
    "Lack of standard": "Lack of standard",
    "Disrupted sleep pattern (shift work)": "Disrupted sleep pattern (shift work)",
    "Incompatible simultaneous activities": "Incompatible simultaneous activities",
    "Distraction": "Distraction",
    "Isolation (especially in remote work or lone working roles)": "Isolation (especially in remote work or lone working roles)",
    "Workplace bullying or harassment": "Workplace bullying or harassment",
    "Discrimination (e.g. gender, race, age)": "Discrimination (e.g. gender, race, age)",
    "Poor supervisor or managerial support": "Poor supervisor or managerial support",
    "Inconsistent communication during organizational change": "Inconsistent communication during organizational change",
    "Lack of transparency or trust in leadership": "Lack of transparency or trust in leadership",
    "Poor organizational justice (unfair treatment)": "Poor organizational justice (unfair treatment)",
    "Lack of recognition or reward": "Lack of recognition or reward",
    "Lack of communication or feedback": "Lack of communication or feedback",
    "Lack of employee involvement in decision-making": "Lack of employee involvement in decision-making",
    "Dealing with aggressive or violent people": "Dealing with aggressive or violent people",
    "Exposure to distressing situations (e.g. emergency services, healthcare, customer complaints)": "Exposure to distressing situations (e.g. emergency services, healthcare, customer complaints)",
    "Lack of privacy or personal space": "Lack of privacy or personal space",
    "Inadequate rest areas": "Inadequate rest areas",
    "Overcrowded or chaotic workspaces": "Overcrowded or chaotic workspaces",
    "Remote Work Specific Hazards": "Remote Work Specific Hazards",
    "Work-Life Balance": "Work-Life Balance",
    "Employment restriction (e.g. Pregnant/breastfeeding, handicap)": "Employment restriction (e.g. Pregnant/breastfeeding, handicap)",
    "Viruses, bacteria, fungi": "Viruses, bacteria, fungi",
    "Legionella (specific bacteria)": "Legionella (specific bacteria)",
    "Molds or allergens": "Molds or allergens",
    "Handling human or animal bodily fluids": "Handling human or animal bodily fluids",
    "Bloodborne pathogens": "Bloodborne pathogens",
    "Contaminated waste or biological material": "Contaminated waste or biological material",
    "Potability of water": "Potability of water",
    "Food hygiene": "Food hygiene",
    "Animal or insect bites/stings": "Animal or insect bites/stings",
    "Animal waste": "Animal waste",
    "Hazardous vegetation": "Hazardous vegetation",
    "Flammable and combustible materials": "Flammable and combustible materials",
    "Ignition sources": "Ignition sources",
    "Ignition sources (open flames, sparks, static)": "Ignition sources (open flames, sparks, static)",
    "Dust explosions (e.g., coal, wood, metal dust)": "Dust explosions (e.g., coal, wood, metal dust)",
    "Oxygen-enriched environments": "Oxygen-enriched environments",
    // Risk/Consequences (English)
    "Abrasion, Scratches": "Abrasion, Scratches",
    "Allergic Reaction": "Allergic Reaction",
    "Amputation": "Amputation",
    "Asphyxiation": "Asphyxiation",
    "Burn - Chemical": "Burn - Chemical",
    "Burn - Electrical/Electrocution": "Burn - Electrical/Electrocution",
    "Burn or Scald (thermal)": "Burn or Scald (thermal)",
    "Chemical exposure": "Chemical exposure",
    "Concussion": "Concussion",
    "Contusion, Bruise": "Contusion, Bruise",
    "Crushing injury": "Crushing injury",
    "Laceration, Cut, Open wound": "Laceration, Cut, Open wound",
    "Fracture": "Fracture",
    "Frostbite / Hypothermia": "Frostbite / Hypothermia",
    "Hearing loss, or impairment": "Hearing loss, or impairment",
    "Heat Stress / Exhaustion / Stroke": "Heat Stress / Exhaustion / Stroke",
    "Hernia": "Hernia",
    "Mental Stress / Work-related Mental Health Condition": "Mental Stress / Work-related Mental Health Condition",
    "Musculoskeletal Disorder (MSD)": "Musculoskeletal Disorder (MSD)",
    "Poisoning": "Poisoning",
    "Puncture": "Puncture",
    "Repetitive motion injury": "Repetitive motion injury",
    "Respiratory irritation (e.g. Asthma)": "Respiratory irritation (e.g. Asthma)",
    "Sprain": "Sprain",
    "Strain": "Strain",
    // Instruction and Helper Text (English)
    "Upload media files. Faces will be automatically blurred. Click thumbnails to add risk descriptions, hazards, and controls.": "Upload media files. Faces will be automatically blurred. Click thumbnails to add risk descriptions, hazards, and controls.",
    "Write a detailed description of the work process. Mention any previous incidents for better risk scoring.": "Write a detailed description of the work process. Mention any previous incidents for better risk scoring.",
    "Upload an Excel file containing risk data. The system will parse and convert it to risk assessment format.": "Upload an Excel file containing risk data. The system will parse and convert it to risk assessment format.",
    "Click a thumbnail below to open the large preview for manual blurring and to add risk notes. You can also drag-and-drop to reorder images.": "Click a thumbnail below to open the large preview for manual blurring and to add risk notes. You can also drag-and-drop to reorder images.",
    "Uploaded videos will appear here...": "Uploaded videos will appear here...",
    "Processed images/frames will appear here...": "Processed images/frames will appear here...",
    "Click to select Excel file": "Click to select Excel file",
    "Supported: .xlsx, .xls, .csv": "Supported: .xlsx, .xls, .csv",
    "Finish uploading and describing your task/images": "Finish uploading and describing your task/images",
    "Review the risk assessment table": "Review the risk assessment table",
    "Generate AI recommendations": "Generate AI recommendations",
    "Download your complete report": "Download your complete report",
    "Mention past incidents for more accurate scoring": "Mention past incidents for more accurate scoring",
    "Add detailed hazard descriptions in notes": "Add detailed hazard descriptions in notes",
    "Review AI suggestions before finalizing": "Review AI suggestions before finalizing",
    "Export to PDF for stakeholder review": "Export to PDF for stakeholder review",
    "Loading AI models... üß†": "Loading AI models... üß†",
    // UI Buttons and Labels (English)
    "Process Files": "Process Files",
    "Download All Images and Reports as ZIP": "Download All Images and Reports as ZIP",
    "Generate AI Risk Assessment from Image Notes": "Generate AI Risk Assessment from Image Notes",
    "Save Project": "Save Project",
    "Load Project": "Load Project",
    "Generate Task Breakdown": "Generate Task Breakdown",
    "Translate Table": "Translate Table",
    "Download Project ZIP": "Download Project ZIP",
    "Print": "Print",
    "Privacy Policy": "Privacy Policy",
    "Generate AI Recommendations & Visuals": "Generate AI Recommendations & Visuals",
    "Advanced Import / Convert": "Advanced Import / Convert",
    "Click to upload or drag and drop": "Click to upload or drag and drop",
    "Images or Videos": "Images or Videos",
    "Overall Progress": "Overall Progress",
    "Uploaded Videos (Capture frames below)": "Uploaded Videos (Capture frames below)",
    "Upload Images & Videos": "Upload Images & Videos",
    "Describe Your Task": "Describe Your Task",
    "Import Excel File": "Import Excel File",
    "Description of step": "Description of step",
    "What can go wrong / spot hazards": "What can go wrong / spot hazards",
    "Any existing controls": "Any existing controls",
    "Language": "Language",
    "Frequency": "Frequency",
    "Severity": "Severity",
    "Likelihood": "Likelihood",
    "Not set": "Not set"
  },
  fr: {
    // Hazard Groups (French)
    "Mechanical / Machinery hazards": "Dangers m√©caniques / Machines",
    "Workplace / Infrastructure Design": "Conception du lieu de travail / Infrastructure",
    "Physical health hazards": "Dangers pour la sant√© physique",
    "Chemical hazards": "Dangers chimiques",
    "Hazardous Energy": "√ânergie dangereuse",
    "Transportation": "Transport",
    "Ergonomic hazards": "Dangers ergonomiques",
    "Organizational and Psychosocial": "Organisationnels et psychosociaux",
    "Biological hazard": "Dangers biologiques",
    "Fire and explosion": "Incendie et explosion",
    // Frequency Scale (French)
    "RARELY (<30 min/day)": "RAREMENT (<30 min/jour)",
    "OCCASIONAL (<2 hrs/wk)": "OCCASIONNEL (<2 hrs/sem)",
    "INTERMEDIATE (2-8 hrs/wk)": "INTERM√âDIAIRE (2-8 hrs/sem)",
    "FREQUENTLY (1-3 days/wk)": "FR√âQUEMMENT (1-3 jours/sem)",
    "PERMANENT (>3 days/wk)": "PERMANENT (>3 jours/sem)",
    // Severity Scale (French)
    "No potential of injury": "Pas de risque de blessure",
    "Potential of FIRST AID": "Potentiel de premiers secours",
    "Potential of MEDICAL TREATMENT": "Potentiel de traitement m√©dical",
    "Potential of DART": "Potentiel de DART",
    "Potential of SIA": "Potentiel de SIA",
    "Potential of Fatality": "Potentiel de d√©c√®s",
    // Likelihood Scale (French)
    "Almost impossible": "Presque impossible",
    "Very unlikely": "Tr√®s improbable",
    "Possible to happen": "Susceptible de se produire",
    "Likely to happen": "Susceptible de se produire",
    "Very likely to happen": "Tr√®s susceptible de se produire",
    // Hazard List Items (French)
    "Hand tools (cut, impact, puncture, etc.)": "Outils manuels (coupure, impact, perforation, etc.)",
    "Powered tools": "Outils motoris√©s",
    "Pinch / nip points": "Points de pincement / happement",
    "Rotating parts (entanglement)": "Pi√®ces en rotation (emm√™lement)",
    "Moving parts (cutting)": "Pi√®ces mobiles (coupure)",
    "Moving parts (crushing)": "Pi√®ces mobiles (√©crasement)",
    "Ejection (parts, materials)": "√âjection (pi√®ces, mat√©riaux)",
    "Angular, sharp and cutting elements": "√âl√©ments angulaires, tranchants et coupants",
    "Degraded or malfunctioning equipment": "√âquipement d√©grad√© ou d√©fectueux",
    "Equipment failure": "Panne d'√©quipement",
    "Improper use of tools/machines": "Utilisation incorrecte des outils/machines",
    "Inadequate guarding": "Protection inad√©quate",
    "Use of lifting equipment and accessories": "Utilisation d'√©quipements de levage et accessoires",
    "Use of suspension equipment (jacks, etc.)": "Utilisation d'√©quipements de suspension (crics, etc.)",
    "Acceleration / deceleration": "Acc√©l√©ration / d√©c√©l√©ration",
    "Slips, trips, and falls (same level or height)": "Glissades, tr√©buchements et chutes (de plain-pied ou de hauteur)",
    "Slippery, uneven, unstable or damaged floor": "Sol glissant, in√©gal, instable ou endommag√©",
    "Congested or obstructed workplace": "Lieu de travail encombr√© ou obstru√©",
    "Clutter / Mess": "Encombrement / D√©sordre",
    "Protrusion (bump, puncture, cut, etc.)": "Saillie (choc, perforation, coupure, etc.)",
    "Hot surface": "Surface chaude",
    "Cold surface": "Surface froide",
    "Rough surface": "Surface rugueuse",
    "Unsecured items at height": "Objets non s√©curis√©s en hauteur",
    "Work at height (<1.2m - <4 feet)": "Travail en hauteur (<1,2 m - <4 pieds)",
    "Work at height (‚â•1.2m - ‚â•4 feet)": "Travail en hauteur (‚â•1,2 m - ‚â•4 pieds)",
    "Poor ventilation": "Mauvaise ventilation",
    "Extreme heat": "Chaleur extr√™me",
    "Extreme cold": "Froid extr√™me",
    "Snow or ice": "Neige ou glace",
    "Extreme wind": "Vent extr√™me",
    "Other adverse weather conditions": "Autres conditions m√©t√©orologiques d√©favorables",
    "Confined spaces": "Espaces confin√©s",
    "Lone work": "Travail isol√©",
    "Temporary works or unstable structures": "Travaux temporaires ou structures instables",
    "Engulfment": "Engloutissement",
    "Inclined surface": "Surface inclin√©e",
    "Poor visibility": "Mauvaise visibilit√©",
    "Coactivity area": "Zone de coactivit√©",
    "Noise exposure": "Exposition au bruit",
    "Vibration / Impact (hand-arm, whole-body)": "Vibrations / Impacts (main-bras, corps entier)",
    "Heat stress": "Stress thermique (chaud)",
    "Cold stress": "Stress thermique (froid)",
    "Poor lighting (intensity, glare, reflection)": "√âclairage insuffisant (intensit√©, √©blouissement, r√©flexion)",
    "Electro-magnetic fields": "Champs √©lectromagn√©tiques",
    "Ionizing radiation (X-rays, radioactive elements)": "Rayonnements ionisants (rayons X, √©l√©ments radioactifs)",
    "Non-ionizing radiation (UV, microwave, laser, welding radiations)": "Rayonnements non ionisants (UV, micro-ondes, laser, radiations de soudage)",
    "Severe draft (e.g. cold air current)": "Courant d'air s√©v√®re (ex. courant d'air froid)",
    "Smoke and fumes": "Fum√©es et vapeurs",
    "Physical health [Generic]": "Sant√© physique [G√©n√©rique]",
    "Explosive materials": "Mat√©riaux explosifs",
    "Flammable materials": "Mat√©riaux inflammables",
    "Oxidising materials": "Mat√©riaux oxydants",
    "Corrosive materials": "Mat√©riaux corrosifs",
    "Acute toxicity materials": "Mat√©riaux toxiques aigus",
    "Health hazard, sensitizers, allergens materials": "Dangers pour la sant√©, sensibilisants, allerg√®nes",
    "Carcinogens, mutagens, reprotoxic (CMRs) materials": "Mat√©riaux canc√©rog√®nes, mutag√®nes, reprotoxiques (CMR)",
    "Gas under pressure": "Gaz sous pression",
    "Asbestos": "Amiante",
    "Fibers other than asbestos": "Fibres autres que l'amiante",
    "Oil": "Huile",
    "Crystalline silica": "Silice cristalline",
    "Organic peroxides": "Peroxydes organiques",
    "Nanomaterials": "Nanomat√©riaux",
    "Endocrine disrupters": "Perturbateurs endocriniens",
    "Lead-containing material": "Mat√©riau contenant du plomb",
    "Particulate material (dust, smoke, fog, aerosol)": "Mat√©riau particulaire (poussi√®re, fum√©e, brouillard, a√©rosol)",
    "Improper labeling or storage": "√âtiquetage ou stockage incorrect",
    "Incompatible chemical reactions": "R√©actions chimiques incompatibles",
    "Chemical spills or leaks": "D√©versements ou fuites chimiques",
    "Water reactive substances": "Substances r√©actives √† l'eau",
    "Shock / vibration sensitive substances": "Substances sensibles aux chocs / vibrations",
    "Chemicals [Generic]": "Produits chimiques [G√©n√©rique]",
    "Electricity": "√âlectricit√©",
    "Electrostatic": "√âlectrostatique",
    "Electromagnetic fields": "Champs √©lectromagn√©tiques",
    "Arc flash": "Arc √©lectrique",
    "Magnetic": "Magn√©tique",
    "Equipment under pressure": "√âquipement sous pression",
    "Compressed air": "Air comprim√©",
    "Vacuum": "Vide",
    "Hydraulic": "Hydraulique",
    "Pneumatic": "Pneumatique",
    "Thermal energy (steam, heated surfaces)": "√ânergie thermique (vapeur, surfaces chauff√©es)",
    "Kinetic energy": "√ânergie cin√©tique",
    "Gravity": "Gravit√©",
    "Stored energy (pneumatic, hydraulic, mechanical, electrical)": "√ânergie stock√©e (pneumatique, hydraulique, m√©canique, √©lectrique)",
    "Exothermic chemical reaction": "R√©action chimique exothermique",
    "Hazardous Energy [Generic]": "√ânergie dangereuse [G√©n√©rique]",
    "Interaction pedestrian/pedestrian": "Interaction pi√©ton/pi√©ton",
    "Interaction pedestrian/bicycle": "Interaction pi√©ton/v√©lo",
    "Interaction pedestrian/Vehicle": "Interaction pi√©ton/v√©hicule",
    "Interaction bicycle/bicycle": "Interaction v√©lo/v√©lo",
    "Interaction bicycle/Vehicle": "Interaction v√©lo/v√©hicule",
    "Interaction Vehicle/Vehicle": "Interaction v√©hicule/v√©hicule",
    "Interaction Vehicle/Stationary items": "Interaction v√©hicule/objets fixes",
    "Poor road or yard conditions": "Mauvaises conditions de route ou de cour",
    "Unintentional vehicle movement": "Mouvement involontaire du v√©hicule",
    "High speed vehicle, tire grip loss": "V√©hicule √† haute vitesse, perte d'adh√©rence des pneus",
    "Inadequate load securing": "Fixation inad√©quate de la charge",
    "Traffic [Generic]": "Circulation [G√©n√©rique]",
    "Postures (Hit list)": "Postures (liste des hits)",
    "Force": "Force",
    "Lifting/Lowering": "Levage/abaissement",
    "Pushing": "Pousser",
    "Pulling": "Tirer",
    "Carrying": "Porter",
    "Soft tissue compression": "Compression des tissus mous",
    "Ill-fitting gloves": "Gants mal ajust√©s",
    "Standing or Sitting for long periods": "Debout ou assis pendant de longues p√©riodes",
    "Computer workstation / Screen": "Poste de travail ordinateur / √âcran",
    "Inadequate tool or workstation design": "Conception inad√©quate de l'outil ou du poste de travail",
    "Poor ergonomics [Generic]": "Ergonomie faible [G√©n√©rique]",
    "Ambiguity of the roles and responsibilities": "Ambigu√Øt√© des r√¥les et responsabilit√©s",
    "Inadequate staffing": "Dotation insuffisante",
    "High job demands (physical or mental workload)": "Exigences √©lev√©es du travail (charge physique ou mentale)",
    "Low job control or autonomy": "Faible contr√¥le ou autonomie du travail",
    "Monotonous or repetitive tasks": "T√¢ches monotones ou r√©p√©titives",
    "Unclear job roles or expectations": "R√¥les ou attentes du travail non clairs",
    "Job insecurity or precarious employment": "Ins√©curit√© d'emploi ou emploi pr√©caire",
    "Long working hours or shift work": "Longues heures de travail ou travail post√©",
    "Unrealistic deadlines": "D√©lais irr√©alistes",
    "Coactivity": "Coactivit√©",
    "Unfamiliar work": "Travail inconnu",
    "New hire / temporary worker": "Nouvel embauch√© / Travailleur temporaire",
    "Insufficient / inadequate training": "Formation insuffisante / inad√©quate",
    "Violations of rules": "Violations des r√®gles",
    "Misuse of computer systems / equipment": "Mauvaise utilisation des syst√®mes / √©quipements informatiques",
    "Lack of adherence to standard": "Manque d'adh√©sion √† la norme",
    "Lack of standard": "Absence de norme",
    "Disrupted sleep pattern (shift work)": "Perturbation du sommeil (travail post√©)",
    "Incompatible simultaneous activities": "Activit√©s simultan√©es incompatibles",
    "Distraction": "Distraction",
    "Isolation (especially in remote work or lone working roles)": "Isolation (surtout en t√©l√©travail ou r√¥les isol√©s)",
    "Workplace bullying or harassment": "Intimidation ou harc√®lement au travail",
    "Discrimination (e.g. gender, race, age)": "Discrimination (ex. genre, race, √¢ge)",
    "Poor supervisor or managerial support": "Soutien insuffisant du superviseur ou de la direction",
    "Inconsistent communication during organizational change": "Communication incoh√©rente pendant le changement organisationnel",
    "Lack of transparency or trust in leadership": "Manque de transparence ou de confiance dans la direction",
    "Poor organizational justice (unfair treatment)": "Justice organisationnelle faible (traitement injuste)",
    "Lack of recognition or reward": "Manque de reconnaissance ou de r√©compense",
    "Lack of communication or feedback": "Manque de communication ou de feedback",
    "Lack of employee involvement in decision-making": "Manque d'implication des employ√©s dans la prise de d√©cision",
    "Dealing with aggressive or violent people": "Gestion de personnes agressives ou violentes",
    "Exposure to distressing situations (e.g. emergency services, healthcare, customer complaints)": "Exposition √† des situations distressantes (ex. services d'urgence, soins de sant√©, plaintes clients)",
    "Lack of privacy or personal space": "Manque de confidentialit√© ou d'espace personnel",
    "Inadequate rest areas": "Zones de repos inad√©quates",
    "Overcrowded or chaotic workspaces": "Espaces de travail surpeupl√©s ou chaotiques",
    "Remote Work Specific Hazards": "Risques sp√©cifiques au t√©l√©travail",
    "Work-Life Balance": "√âquilibre travail-vie",
    "Employment restriction (e.g. Pregnant/breastfeeding, handicap)": "Restriction d'emploi (ex. enceinte/allaitante, handicap)",
    "Viruses, bacteria, fungi": "Virus, bact√©ries, champignons",
    "Legionella (specific bacteria)": "L√©gionelle (bact√©rie sp√©cifique)",
    "Molds or allergens": "Moisissures ou allerg√®nes",
    "Handling human or animal bodily fluids": "Manipulation de fluides corporels humains ou animaux",
    "Bloodborne pathogens": "Pathog√®nes transmis par le sang",
    "Contaminated waste or biological material": "D√©chets contamin√©s ou mat√©riaux biologiques",
    "Potability of water": "Potabilit√© de l'eau",
    "Food hygiene": "Hygi√®ne alimentaire",
    "Animal or insect bites/stings": "Morsures/piq√ªres d'animaux ou d'insectes",
    "Animal waste": "D√©chets animaux",
    "Hazardous vegetation": "V√©g√©tation dangereuse",
    "Flammable and combustible materials": "Mat√©riaux inflammables et combustibles",
    "Ignition sources": "Sources d'allumage",
    "Ignition sources (open flames, sparks, static)": "Sources d'allumage (flammes ouvertes, √©tincelles, statique)",
    "Dust explosions (e.g., coal, wood, metal dust)": "Explosions de poussi√®res (ex. charbon, bois, poussi√®re m√©tallique)",
    "Oxygen-enriched environments": "Environnements enrichis en oxyg√®ne",
    // Risk/Consequences (French)
    "Abrasion, Scratches": "Abrasions, √©gratignures",
    "Allergic Reaction": "R√©action allergique",
    "Amputation": "Amputation",
    "Asphyxiation": "Asphyxie",
    "Burn - Chemical": "Br√ªlure - Chimique",
    "Burn - Electrical/Electrocution": "Br√ªlure - √âlectrique/√âlectrocution",
    "Burn or Scald (thermal)": "Br√ªlure ou √©bouillantement (thermique)",
    "Chemical exposure": "Exposition chimique",
    "Concussion": "Commotion c√©r√©brale",
    "Contusion, Bruise": "Contusion, ecchymose",
    "Crushing injury": "Blessure par √©crasement",
    "Laceration, Cut, Open wound": "Lac√©ration, coupure, plaie ouverte",
    "Fracture": "Fracture",
    "Frostbite / Hypothermia": "Engelures / Hypothermie",
    "Hearing loss, or impairment": "Perte auditive ou d√©ficience",
    "Heat Stress / Exhaustion / Stroke": "Stress thermique / √âpuisement / Coup de chaleur",
    "Hernia": "Hernie",
    "Mental Stress / Work-related Mental Health Condition": "Stress mental / Trouble mental li√© au travail",
    "Musculoskeletal Disorder (MSD)": "Trouble musculo-squelettique (TMS)",
    "Poisoning": "Empoisonnement",
    "Puncture": "Perforation",
    "Repetitive motion injury": "Blessure par mouvements r√©p√©titifs",
    "Respiratory irritation (e.g. Asthma)": "Irritation respiratoire (ex. Asthme)",
    "Sprain": "Entorse",
    "Strain": "Foulure",
    // Instruction and Helper Text (French)
    "Upload media files. Faces will be automatically blurred. Click thumbnails to add risk descriptions, hazards, and controls.": "T√©l√©chargez des fichiers m√©dias. Les visages seront automatiquement flout√©s. Cliquez sur les miniatures pour ajouter des descriptions de risques, des dangers et des contr√¥les.",
    "Write a detailed description of the work process. Mention any previous incidents for better risk scoring.": "√âcrivez une description d√©taill√©e du processus de travail. Mentionnez les incidents ant√©rieurs pour un meilleur calcul des risques.",
    "Upload an Excel file containing risk data. The system will parse and convert it to risk assessment format.": "T√©l√©chargez un fichier Excel contenant des donn√©es de risque. Le syst√®me l'analysera et le convertira au format d'√©valuation des risques.",
    "Click a thumbnail below to open the large preview for manual blurring and to add risk notes. You can also drag-and-drop to reorder images.": "Cliquez sur une miniature ci-dessous pour ouvrir l'aper√ßu agrandi pour le floutage manuel et pour ajouter des notes de risque. Vous pouvez √©galement glisser-d√©poser pour r√©organiser les images.",
    "Uploaded videos will appear here...": "Les vid√©os t√©l√©charg√©es appara√Ætront ici...",
    "Processed images/frames will appear here...": "Les images/images trait√©es appara√Ætront ici...",
    "Click to select Excel file": "Cliquez pour s√©lectionner le fichier Excel",
    "Supported: .xlsx, .xls, .csv": "Formats pris en charge: .xlsx, .xls, .csv",
    "Finish uploading and describing your task/images": "Terminez le t√©l√©chargement et la description de votre t√¢che/images",
    "Review the risk assessment table": "Examinez le tableau d'√©valuation des risques",
    "Generate AI recommendations": "G√©n√©rer les recommandations IA",
    "Download your complete report": "T√©l√©chargez votre rapport complet",
    "Mention past incidents for more accurate scoring": "Mentionnez les incidents pass√©s pour un calcul plus pr√©cis",
    "Add detailed hazard descriptions in notes": "Ajoutez des descriptions d√©taill√©es des dangers dans les notes",
    "Review AI suggestions before finalizing": "Examinez les suggestions IA avant de finaliser",
    "Export to PDF for stakeholder review": "Exporter au format PDF pour examen des parties prenantes",
    "Loading AI models... üß†": "Chargement des mod√®les IA... üß†",
    // UI Buttons and Labels (French)
    "Process Files": "Traiter les fichiers",
    "Download All Images and Reports as ZIP": "T√©l√©charger toutes les images et rapports en ZIP",
    "Generate AI Risk Assessment from Image Notes": "G√©n√©rer une √©valuation des risques IA √† partir des notes d'image",
    "Save Project": "Enregistrer le projet",
    "Load Project": "Charger le projet",
    "Generate Task Breakdown": "G√©n√©rer une ventilation des t√¢ches",
    "Translate Table": "Traduire le tableau",
    "Download Project ZIP": "T√©l√©charger ZIP du projet",
    "Print": "Imprimer",
    "Privacy Policy": "Politique de confidentialit√©",
    "Generate AI Recommendations & Visuals": "G√©n√©rer les recommandations et visuels IA",
    "Advanced Import / Convert": "Importation / Conversion avanc√©e",
    "Click to upload or drag and drop": "Cliquez pour t√©l√©charger ou glissez-d√©posez",
    "Images or Videos": "Images ou vid√©os",
    "Overall Progress": "Progr√®s global",
    "Uploaded Videos (Capture frames below)": "Vid√©os t√©l√©charg√©es (capturer les images ci-dessous)",
    "Upload Images & Videos": "T√©l√©charger des images et des vid√©os",
    "Describe Your Task": "D√©crivez votre t√¢che",
    "Import Excel File": "Importer un fichier Excel",
    "Description of step": "Description de l'√©tape",
    "What can go wrong / spot hazards": "Qu'est-ce qui pourrait mal tourner / rep√©rer les dangers",
    "Any existing controls": "Tous les contr√¥les existants",
    "Language": "Langue",
    "Frequency": "Fr√©quence",
    "Severity": "Gravit√©",
    "Likelihood": "Probabilit√©",
    "Not set": "Non d√©fini"
  },
  de: {
    // Hazard Groups (German)
    "Mechanical / Machinery hazards": "Mechanische / Maschinenrisiken",
    "Workplace / Infrastructure Design": "Arbeitsplatz / Infrastrukturdesign",
    "Physical health hazards": "Physische Gesundheitsrisiken",
    "Chemical hazards": "Chemische Risiken",
    "Hazardous Energy": "Gef√§hrliche Energie",
    "Transportation": "Transport",
    "Ergonomic hazards": "Ergonomische Risiken",
    "Organizational and Psychosocial": "Organisatorisch und psychosozial",
    "Biological hazard": "Biologische Risiken",
    "Fire and explosion": "Feuer und Explosion",
    // Frequency Scale (German)
    "RARELY (<30 min/day)": "SELTEN (<30 min/Tag)",
    "OCCASIONAL (<2 hrs/wk)": "GELEGENTLICH (<2 Stunden/Wo)",
    "INTERMEDIATE (2-8 hrs/wk)": "ZWISCHENDURCH (2-8 Stunden/Wo)",
    "FREQUENTLY (1-3 days/wk)": "H√ÑUFIG (1-3 Tage/Wo)",
    "PERMANENT (>3 days/wk)": "DAUERHAFT (>3 Tage/Wo)",
    // Severity Scale (German)
    "No potential of injury": "Keine Verletzungsgefahr",
    "Potential of FIRST AID": "Potenzial der Ersten Hilfe",
    "Potential of MEDICAL TREATMENT": "Potenzial der √§rztlichen Behandlung",
    "Potential of DART": "Potenzial von DART",
    "Potential of SIA": "Potenzial von SIA",
    "Potential of Fatality": "Potenzial f√ºr Todesfall",
    // Likelihood Scale (German)
    "Almost impossible": "Fast unm√∂glich",
    "Very unlikely": "Sehr unwahrscheinlich",
    "Possible to happen": "M√∂glich",
    "Likely to happen": "Wahrscheinlich",
    "Very likely to happen": "Sehr wahrscheinlich",
    // Hazard List Items (German)
    "Hand tools (cut, impact, puncture, etc.)": "Handwerkzeuge (Schnitt, Sto√ü, Stich usw.)",
    "Powered tools": "Elektrische Werkzeuge",
    "Pinch / nip points": "Quetsch- / Einklemmstellen",
    "Rotating parts (entanglement)": "Rotierende Teile (Verfangen)",
    "Moving parts (cutting)": "Bewegliche Teile (Schneiden)",
    "Moving parts (crushing)": "Bewegliche Teile (Quetschen)",
    "Ejection (parts, materials)": "Auswurf (Teile, Materialien)",
    "Angular, sharp and cutting elements": "Winklige, scharfe und schneidende Elemente",
    "Degraded or malfunctioning equipment": "Verschlei√ütes oder defektes Ger√§t",
    "Equipment failure": "Ger√§teausfall",
    "Improper use of tools/machines": "Falsche Verwendung von Werkzeugen/Maschinen",
    "Inadequate guarding": "Unzureichender Schutz",
    "Use of lifting equipment and accessories": "Verwendung von Hebezeugen und Zubeh√∂r",
    "Use of suspension equipment (jacks, etc.)": "Verwendung von Aufh√§ngeger√§ten (Heber usw.)",
    "Acceleration / deceleration": "Beschleunigung / Verz√∂gerung",
    "Slips, trips, and falls (same level or height)": "Ausrutschen, Stolpern und St√ºrze (gleiche Ebene oder H√∂he)",
    "Slippery, uneven, unstable or damaged floor": "Rutschiger, unebener, instabiler oder besch√§digter Boden",
    "Congested or obstructed workplace": "√úberf√ºllter oder behinderter Arbeitsplatz",
    "Clutter / Mess": "Unordnung / Chaos",
    "Protrusion (bump, puncture, cut, etc.)": "Vorsprung (Sto√ü, Stich, Schnitt usw.)",
    "Hot surface": "Hei√üe Oberfl√§che",
    "Cold surface": "Kalte Oberfl√§che",
    "Rough surface": "Raue Oberfl√§che",
    "Unsecured items at height": "Ungesicherte Gegenst√§nde in der H√∂he",
    "Work at height (<1.2m - <4 feet)": "Arbeit in H√∂he (<1,2 m - <4 Fu√ü)",
    "Work at height (‚â•1.2m - ‚â•4 feet)": "Arbeit in H√∂he (‚â•1,2 m - ‚â•4 Fu√ü)",
    "Poor ventilation": "Schlechte Bel√ºftung",
    "Extreme heat": "Extreme Hitze",
    "Extreme cold": "Extreme K√§lte",
    "Snow or ice": "Schnee oder Eis",
    "Extreme wind": "Extremer Wind",
    "Other adverse weather conditions": "Andere widrige Witterungsbedingungen",
    "Confined spaces": "Enge R√§ume",
    "Lone work": "Alleinige Arbeit",
    "Temporary works or unstable structures": "Vorl√§ufige Arbeiten oder instabile Strukturen",
    "Engulfment": "Verschluckung",
    "Inclined surface": "Geneigte Oberfl√§che",
    "Poor visibility": "Schlechte Sicht",
    "Coactivity area": "Koaktivit√§t Bereich",
    "Noise exposure": "L√§rmbelastung",
    "Vibration / Impact (hand-arm, whole-body)": "Vibration / Sto√ü (Hand-Arm, Ganzk√∂rper)",
    "Heat stress": "Hitzestress",
    "Cold stress": "K√§ltestress",
    "Poor lighting (intensity, glare, reflection)": "Schlechte Beleuchtung (Intensit√§t, Blendung, Reflexion)",
    "Electro-magnetic fields": "Elektromagnetische Felder",
    "Ionizing radiation (X-rays, radioactive elements)": "Ionisierende Strahlung (R√∂ntgenstrahlen, radioaktive Elemente)",
    "Non-ionizing radiation (UV, microwave, laser, welding radiations)": "Nicht-ionisierende Strahlung (UV, Mikrowelle, Laser, Schwei√üstrahlung)",
    "Severe draft (e.g. cold air current)": "Starker Zug (z.B. kalter Luftstrom)",
    "Smoke and fumes": "Rauch und D√§mpfe",
    "Physical health [Generic]": "Physische Gesundheit [Generisch]",
    "Explosive materials": "Explosive Materialien",
    "Flammable materials": "Entz√ºndliche Materialien",
    "Oxidising materials": "Oxidierende Materialien",
    "Corrosive materials": "Korrosive Materialien",
    "Acute toxicity materials": "Akut toxische Materialien",
    "Health hazard, sensitizers, allergens materials": "Gesundheitsgefahr, Sensibilisatoren, Allergene Materialien",
    "Carcinogens, mutagens, reprotoxic (CMRs) materials": "Karzinogene, mutagene, reprotoxische (CMR) Materialien",
    "Gas under pressure": "Gas unter Druck",
    "Asbestos": "Asbest",
    "Fibers other than asbestos": "Fasern au√üer Asbest",
    "Oil": "√ñl",
    "Crystalline silica": "Kristallines Siliziumdioxid",
    "Organic peroxides": "Organische Peroxide",
    "Nanomaterials": "Nanomaterialien",
    "Endocrine disrupters": "Endokrine Disruptoren",
    "Lead-containing material": "Blei-haltiges Material",
    "Particulate material (dust, smoke, fog, aerosol)": "Partikelmaterial (Staub, Rauch, Nebel, Aerosol)",
    "Improper labeling or storage": "Falsche Kennzeichnung oder Lagerung",
    "Incompatible chemical reactions": "Inkompatible chemische Reaktionen",
    "Chemical spills or leaks": "Chemische Versch√ºttungen oder Lecks",
    "Water reactive substances": "Wasserreaktive Substanzen",
    "Shock / vibration sensitive substances": "Sto√ü / vibrationsempfindliche Substanzen",
    "Chemicals [Generic]": "Chemikalien [Generisch]",
    "Electricity": "Elektrizit√§t",
    "Electrostatic": "Elektrostatisch",
    "Electromagnetic fields": "Elektromagnetische Felder",
    "Arc flash": "Lichtbogenblitz",
    "Magnetic": "Magnetisch",
    "Equipment under pressure": "Ger√§t unter Druck",
    "Compressed air": "Druckluft",
    "Vacuum": "Vakuum",
    "Hydraulic": "Hydraulik",
    "Pneumatic": "Pneumatik",
    "Thermal energy (steam, heated surfaces)": "Thermische Energie (Dampf, erhitzte Oberfl√§chen)",
    "Kinetic energy": "Kinetische Energie",
    "Gravity": "Schwerkraft",
    "Stored energy (pneumatic, hydraulic, mechanical, electrical)": "Gespeicherte Energie (pneumatisch, hydraulisch, mechanisch, elektrisch)",
    "Exothermic chemical reaction": "Exotherme chemische Reaktion",
    "Hazardous Energy [Generic]": "Gef√§hrliche Energie [Generisch]",
    "Interaction pedestrian/pedestrian": "Interaktion Fu√üg√§nger/Fu√üg√§nger",
    "Interaction pedestrian/bicycle": "Interaktion Fu√üg√§nger/Fahrrad",
    "Interaction pedestrian/Vehicle": "Interaktion Fu√üg√§nger/Fahrzeug",
    "Interaction bicycle/bicycle": "Interaktion Fahrrad/Fahrrad",
    "Interaction bicycle/Vehicle": "Interaktion Fahrrad/Fahrzeug",
    "Interaction Vehicle/Vehicle": "Interaktion Fahrzeug/Fahrzeug",
    "Interaction Vehicle/Stationary items": "Interaktion Fahrzeug/Station√§re Gegenst√§nde",
    "Poor road or yard conditions": "Schlechte Stra√üen- oder Hofbedingungen",
    "Unintentional vehicle movement": "Unbeabsichtigte Fahrzeugbewegung",
    "High speed vehicle, tire grip loss": "Hochgeschwindigkeitsfahrzeug, Verlust der Reifenhaftung",
    "Inadequate load securing": "Unzureichende Ladungssicherung",
    "Traffic [Generic]": "Verkehr [Generisch]",
    "Postures (Hit list)": "Haltungen (Hit-Liste)",
    "Force": "Kraft",
    "Lifting/Lowering": "Heben/Senken",
    "Pushing": "Schieben",
    "Pulling": "Ziehen",
    "Carrying": "Tragen",
    "Soft tissue compression": "Weichgewebekompression",
    "Ill-fitting gloves": "Schlecht passende Handschuhe",
    "Standing or Sitting for long periods": "Langes Stehen oder Sitzen",
    "Computer workstation / Screen": "Computerarbeitsplatz / Bildschirm",
    "Inadequate tool or workstation design": "Unzureichende Werkzeug- oder Arbeitsplatzgestaltung",
    "Poor ergonomics [Generic]": "Schlechte Ergonomie [Generisch]",
    "Ambiguity of the roles and responsibilities": "Unklarheit der Rollen und Verantwortlichkeiten",
    "Inadequate staffing": "Unzureichendes Personal",
    "High job demands (physical or mental workload)": "Hohe Arbeitsanforderungen (physisch oder mental)",
    "Low job control or autonomy": "Wenig Kontrolle oder Autonomie am Arbeitsplatz",
    "Monotonous or repetitive tasks": "Monotone oder repetitive Aufgaben",
    "Unclear job roles or expectations": "Unklare Arbeitsrollen oder Erwartungen",
    "Job insecurity or precarious employment": "Arbeitsplatzunsicherheit oder prek√§re Besch√§ftigung",
    "Long working hours or shift work": "Lange Arbeitszeiten oder Schichtarbeit",
    "Unrealistic deadlines": "Unrealistische Fristen",
    "Coactivity": "Koaktivit√§t",
    "Unfamiliar work": "Unbekannte Arbeit",
    "New hire / temporary worker": "Neueingestellter / Tempor√§rer Arbeiter",
    "Insufficient / inadequate training": "Unzureichende / unangemessene Schulung",
    "Violations of rules": "Verst√∂√üe gegen Regeln",
    "Misuse of computer systems / equipment": "Missbrauch von Computersystemen / -ger√§ten",
    "Lack of adherence to standard": "Mangelnde Einhaltung des Standards",
    "Lack of standard": "Fehlender Standard",
    "Disrupted sleep pattern (shift work)": "Gest√∂rtes Schlafmuster (Schichtarbeit)",
    "Incompatible simultaneous activities": "Inkompatible gleichzeitige Aktivit√§ten",
    "Distraction": "Ablenkung",
    "Isolation (especially in remote work or lone working roles)": "Isolation (besonders bei Fernarbeit oder Alleinarbeit)",
    "Workplace bullying or harassment": "Mobbing oder Bel√§stigung am Arbeitsplatz",
    "Discrimination (e.g. gender, race, age)": "Diskriminierung (z.B. Geschlecht, Rasse, Alter)",
    "Poor supervisor or managerial support": "Schlechte Unterst√ºtzung durch Vorgesetzte oder Management",
    "Inconsistent communication during organizational change": "Inkonsistente Kommunikation w√§hrend organisatorischer Ver√§nderungen",
    "Lack of transparency or trust in leadership": "Mangel an Transparenz oder Vertrauen in die F√ºhrung",
    "Poor organizational justice (unfair treatment)": "Schlechte organisatorische Gerechtigkeit (unfaire Behandlung)",
    "Lack of recognition or reward": "Mangel an Anerkennung oder Belohnung",
    "Lack of communication or feedback": "Mangel an Kommunikation oder Feedback",
    "Lack of employee involvement in decision-making": "Mangel an Beteiligung der Mitarbeiter an Entscheidungsfindung",
    "Dealing with aggressive or violent people": "Umgang mit aggressiven oder gewaltt√§tigen Personen",
    "Exposure to distressing situations (e.g. emergency services, healthcare, customer complaints)": "Belastende Situationen (z.B. Notdienste, Gesundheitswesen, Kundenbeschwerden)",
    "Lack of privacy or personal space": "Mangel an Privatsph√§re oder pers√∂nlichem Raum",
    "Inadequate rest areas": "Unzureichende Ruhebereiche",
    "Overcrowded or chaotic workspaces": "√úberf√ºllte oder chaotische Arbeitspl√§tze",
    "Remote Work Specific Hazards": "Spezifische Risiken f√ºr Fernarbeit",
    "Work-Life Balance": "Work-Life-Balance",
    "Employment restriction (e.g. Pregnant/breastfeeding, handicap)": "Besch√§ftigungsbeschr√§nkung (z.B. Schwangere/Stillende, Behinderung)",
    "Viruses, bacteria, fungi": "Viren, Bakterien, Pilze",
    "Legionella (specific bacteria)": "Legionella (spezifisches Bakterium)",
    "Molds or allergens": "Schimmel oder Allergene",
    "Handling human or animal bodily fluids": "Umgang mit menschlichen oder tierischen K√∂rperfl√ºssigkeiten",
    "Bloodborne pathogens": "Blut√ºbertragbare Erreger",
    "Contaminated waste or biological material": "Kontaminierter Abfall oder biologisches Material",
    "Potability of water": "Trinkbarkeit von Wasser",
    "Food hygiene": "Lebensmittelhygiene",
    "Animal or insect bites/stings": "Tier- oder Insektenbisse/Stiche",
    "Animal waste": "Tierabfall",
    "Hazardous vegetation": "Gef√§hrliche Vegetation",
    "Flammable and combustible materials": "Entz√ºndliche und brennbare Materialien",
    "Ignition sources": "Z√ºndquellen",
    "Ignition sources (open flames, sparks, static)": "Z√ºndquellen (offene Flammen, Funken, statisch)",
    "Dust explosions (e.g., coal, wood, metal dust)": "Staubexplosionen (z.B. Kohle, Holz, Metalstaub)",
    "Oxygen-enriched environments": "Sauerstoffangereicherte Umgebungen",
    // Risk/Consequences (German)
    "Abrasion, Scratches": "Abrasionen, Kratzer",
    "Allergic Reaction": "Allergische Reaktion",
    "Amputation": "Amputation",
    "Asphyxiation": "Erstickung",
    "Burn - Chemical": "Verbrennung - Chemisch",
    "Burn - Electrical/Electrocution": "Verbrennung - Elektrisch/Stromschlag",
    "Burn or Scald (thermal)": "Verbrennung oder Verbr√ºhung (thermisch)",
    "Chemical exposure": "Chemische Exposition",
    "Concussion": "Gehirnersch√ºtterung",
    "Contusion, Bruise": "Prellung, Bluterguss",
    "Crushing injury": "Quetschverletzung",
    "Laceration, Cut, Open wound": "Schnittverletzung, Schnitt, Offene Wunde",
    "Fracture": "Fraktur",
    "Frostbite / Hypothermia": "Erfrierung / Hypothermie",
    "Hearing loss, or impairment": "H√∂rverlust oder Beeintr√§chtigung",
    "Heat Stress / Exhaustion / Stroke": "Hitzestress / Ersch√∂pfung / Schlaganfall",
    "Hernia": "Hernie",
    "Mental Stress / Work-related Mental Health Condition": "Mentale Belastung / Arbeitsbedingte psychische Erkrankung",
    "Musculoskeletal Disorder (MSD)": "Muskel-Skelett-Erkrankung (MSE)",
    "Poisoning": "Vergiftung",
    "Puncture": "Stichverletzung",
    "Repetitive motion injury": "Verletzung durch repetitive Bewegungen",
    "Respiratory irritation (e.g. Asthma)": "Atemwegsreizung (z.B. Asthma)",
    "Sprain": "Verstauchung",
    "Strain": "Zerrung",
    // Instruction and Helper Text (German)
    "Upload media files. Faces will be automatically blurred. Click thumbnails to add risk descriptions, hazards, and controls.": "Laden Sie Mediendateien hoch. Gesichter werden automatisch unkenntlich gemacht. Klicken Sie auf Miniaturansichten, um Risikobeschreibungen, Gefahren und Kontrollen hinzuzuf√ºgen.",
    "Write a detailed description of the work process. Mention any previous incidents for better risk scoring.": "Schreiben Sie eine detaillierte Beschreibung des Arbeitsprozesses. Erw√§hnen Sie fr√ºhere Vorf√§lle f√ºr eine bessere Risikobewertung.",
    "Upload an Excel file containing risk data. The system will parse and convert it to risk assessment format.": "Laden Sie eine Excel-Datei mit Risikodaten hoch. Das System analysiert und konvertiert sie in das Risikobewertungsformat.",
    "Click a thumbnail below to open the large preview for manual blurring and to add risk notes. You can also drag-and-drop to reorder images.": "Klicken Sie unten auf eine Miniaturansicht, um die gro√üe Vorschau zum manuellen Unkenntlichmachen zu √∂ffnen und Risikonotizen hinzuzuf√ºgen. Sie k√∂nnen auch Bilder per Drag-and-Drop neu anordnen.",
    "Uploaded videos will appear here...": "Hochgeladene Videos werden hier angezeigt...",
    "Processed images/frames will appear here...": "Verarbeitete Bilder/Frames werden hier angezeigt...",
    "Click to select Excel file": "Klicken Sie, um die Excel-Datei auszuw√§hlen",
    "Supported: .xlsx, .xls, .csv": "Unterst√ºtzte Formate: .xlsx, .xls, .csv",
    "Finish uploading and describing your task/images": "Beenden Sie das Hochladen und Beschreiben Ihrer Aufgabe/Bilder",
    "Review the risk assessment table": "√úberpr√ºfen Sie die Risikobewertungstabelle",
    "Generate AI recommendations": "KI-Empfehlungen generieren",
    "Download your complete report": "Laden Sie Ihren vollst√§ndigen Bericht herunter",
    "Mention past incidents for more accurate scoring": "Erw√§hnen Sie fr√ºhere Vorf√§lle f√ºr genauere Bewertungen",
    "Add detailed hazard descriptions in notes": "F√ºgen Sie detaillierte Gefahrenbeschreibungen in Notizen hinzu",
    "Review AI suggestions before finalizing": "√úberpr√ºfen Sie KI-Vorschl√§ge vor der Finalisierung",
    "Export to PDF for stakeholder review": "Als PDF exportieren zur √úberpr√ºfung durch Interessentr√§ger",
    "Loading AI models... üß†": "KI-Modelle werden geladen... üß†",
    // UI Buttons and Labels (German)
    "Process Files": "Dateien verarbeiten",
    "Download All Images and Reports as ZIP": "Alle Bilder und Berichte als ZIP herunterladen",
    "Generate AI Risk Assessment from Image Notes": "KI-Risikobewertung aus Bildnotizen generieren",
    "Save Project": "Projekt speichern",
    "Load Project": "Projekt laden",
    "Generate Task Breakdown": "Aufgabenaufschl√ºsselung generieren",
    "Translate Table": "Tabelle √ºbersetzen",
    "Download Project ZIP": "Projekt-ZIP herunterladen",
    "Print": "Drucken",
    "Privacy Policy": "Datenschutzrichtlinie",
    "Generate AI Recommendations & Visuals": "KI-Empfehlungen und Grafiken generieren",
    "Advanced Import / Convert": "Erweiterter Import / Konvertierung",
    "Click to upload or drag and drop": "Klicken zum Hochladen oder Ziehen und Ablegen",
    "Images or Videos": "Bilder oder Videos",
    "Overall Progress": "Gesamtfortschritt",
    "Uploaded Videos (Capture frames below)": "Hochgeladene Videos (Bilder unten erfassen)",
    "Upload Images & Videos": "Bilder und Videos hochladen",
    "Describe Your Task": "Beschreiben Sie Ihre Aufgabe",
    "Import Excel File": "Excel-Datei importieren",
    "Description of step": "Beschreibung des Schritts",
    "What can go wrong / spot hazards": "Was kann schiefgehen / Gefahren erkennen",
    "Any existing controls": "Alle vorhandenen Steuerungen",
    "Language": "Sprache",
    "Frequency": "H√§ufigkeit",
    "Severity": "Schweregrad",
    "Likelihood": "Wahrscheinlichkeit",
    "Not set": "Nicht gesetzt"
  }
};

        // --- GLOBAL LANGUAGE STATE ---
        // Load language from localStorage or default to 'en'
        let currentLang = localStorage.getItem('appLanguage') || 'en';

        // --- TRANSLATION FUNCTION ---
        const t = (englishText) => {
            if (!TRANSLATIONS[currentLang] || !TRANSLATIONS[currentLang][englishText]) {
                return englishText; // Fallback to English if translation not found
            }
            return TRANSLATIONS[currentLang][englishText];
        };

        // --- UPDATE UI TEXT WHEN LANGUAGE CHANGES ---
        const updateUIText = () => {
            // Update button text by their IDs
            const buttonIds = [
                'processBtn', 'downloadBtn', 'generateAiReportBtn', 'saveProjectBtn', 
                'loadProjectBtn', 'generateTasksBtn', 'translateTableBtn', 'downloadProjectZipBtn',
                'privacyBtn'
            ];
            
            buttonIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    const englishText = btn.getAttribute('data-en-text') || btn.innerText;
                    btn.innerText = t(englishText);
                    btn.setAttribute('data-en-text', englishText);
                }
            });

            // Update label text
            const labels = document.querySelectorAll('label[for="stepDescription"], label[for="spotHazards"], label[for="existingControls"], label[for="langSelect"]');
            labels.forEach(label => {
                const englishText = label.getAttribute('data-en-text') || label.innerText;
                label.innerText = t(englishText);
                label.setAttribute('data-en-text', englishText);
            });

            // Update placeholder text
            const placeholders = document.querySelectorAll('[placeholder]');
            placeholders.forEach(el => {
                const englishText = el.getAttribute('data-en-placeholder') || el.placeholder;
                el.placeholder = t(englishText);
                el.setAttribute('data-en-placeholder', englishText);
            });

            // Update h2 and h3 headers
            const headers = document.querySelectorAll('h2, h3');
            headers.forEach(header => {
                const englishText = header.getAttribute('data-en-text') || header.innerText;
                const translated = t(englishText);
                if (translated !== englishText) {
                    header.innerText = translated;
                    header.setAttribute('data-en-text', englishText);
                }
            });

            // Update paragraph instruction text (tab introductions and helper text)
            const paragraphs = document.querySelectorAll('p.text-slate-600');
            paragraphs.forEach(p => {
                const englishText = p.getAttribute('data-en-text') || p.innerText;
                const translated = t(englishText);
                if (translated !== englishText) {
                    p.innerText = translated;
                    p.setAttribute('data-en-text', englishText);
                }
            });

            // Update span text in info boxes (like manual blur info)
            const infoBoxes = document.querySelectorAll('[id*="info"]');
            infoBoxes.forEach(box => {
                const englishText = box.getAttribute('data-en-text') || box.innerText;
                const translated = t(englishText);
                if (translated !== englishText) {
                    box.innerText = translated;
                    box.setAttribute('data-en-text', englishText);
                }
            });

            // Update placeholder-like text in empty states
            const emptyStates = document.querySelectorAll('p.text-slate-500');
            emptyStates.forEach(p => {
                const englishText = p.getAttribute('data-en-text') || p.innerText;
                const translated = t(englishText);
                if (translated !== englishText) {
                    p.innerText = translated;
                    p.setAttribute('data-en-text', englishText);
                }
            });
        };

        // --- MASTER HAZARD & CONSEQUENCE REGISTRIES ---
        //const HAZARD_REGISTRY = { "Hand tools (cut, impact, puncture, etc.)": { group: "Mechanical / Machinery hazards", severity: 5, likelihood: 5 }, "Powered tools": { group: "Mechanical / Machinery hazards", severity: 7, likelihood: 4 }, "Pinch / nip points": { group: "Mechanical / Machinery hazards", severity: 7, likelihood: 5 }, "Rotating parts (entanglement)": { group: "Mechanical / Machinery hazards", severity: 9, likelihood: 3 }, "Moving parts (cutting)": { group: "Mechanical / Machinery hazards", severity: 9, likelihood: 4 }, "Moving parts (crushing)": { group: "Mechanical / Machinery hazards", severity: 9, likelihood: 4 }, "Ejection (parts, materials)": { group: "Mechanical / Machinery hazards", severity: 5, likelihood: 5 }, "Angular, sharp and cutting elements": { group: "Mechanical / Machinery hazards", severity: 7, likelihood: 5 }, "Slips, trips, and falls (same level or height)": { group: "Workplace / Infrastructure Design", severity: 3, likelihood: 8 }, "Slippery, eneven, unstable or damaged floor": { group: "Workplace / Infrastructure Design", severity: 5, likelihood: 7 }, "Congested or obstructed workplace": { group: "Workplace / Infrastructure Design", severity: 3, likelihood: 8 }, "Noise exposure": { group: "Physical health hazards", severity: 3, likelihood: 9 }, "Vibration / Impact (hand-arm, whole-body)": { group: "Physical health hazards", severity: 5, likelihood: 8 }, "Heat stress": { group: "Physical health hazards", severity: 5, likelihood: 5 }, "Cold stress": { group: "Physical health hazards", severity: 5, likelihood: 5 }, "Flammable materials": { group: "Chemical hazards", severity: 10, likelihood: 1 }, "Corrosive materials": { group: "Chemical hazards", severity: 7, likelihood: 3 }, "Electricity": { group: "Hazardous Energy", severity: 10, likelihood: 2 }, "Gravity": { group: "Hazardous Energy", severity: 7, likelihood: 5 }, "Hydraulic": { group: "Hazardous Energy", severity: 7, likelihood: 3 }, "Pneumatic": { group: "Hazardous Energy", severity: 5, likelihood: 3 }, "Interraction pedestrian/Vehicle": { group: "Transportation", severity: 7, likelihood: 3 }, "Postures (Hit list)": { group: "Ergonomic hazards", severity: 3, likelihood: 9 }, "Force": { group: "Ergonomic hazards", severity: 5, likelihood: 8 }, "Lifting/Lowering": { group: "Ergonomic hazards", severity: 5, likelihood: 8 }, "Pushing": { group: "Ergonomic hazards", severity: 5, likelihood: 8 }, "Pulling": { group: "Ergonomic hazards", severity: 5, likelihood: 8 }, "Carrying": { group: "Ergonomic hazards", severity: 5, likelihood: 8 }, "High job demands": { group: "Organizational and Psychosocial", severity: 3, likelihood: 8 }, "Low job control or autonomy": { group: "Organizational and Psychosocial", severity: 3, likelihood: 7 }, "Monotonous or repetitive tasks": { group: "Organizational and Psychosocial", severity: 3, likelihood: 9 }, "Viruses, bacteria, fungi": { group: "Biological hazard", severity: 7, likelihood: 3 }, "Flammable and combustible materials": { group: "Fire and explosion", severity: 10, likelihood: 2 }, "Ignition sources": { group: "Fire and explosion", severity: 10, likelihood: 2 } };
        const HAZARD_REGISTRY = { 
    "Hand tools (cut, impact, puncture, etc.)": { group: "Mechanical / Machinery hazards", severity: 5, likelihood: 5 }, 
    "Powered tools": { group: "Mechanical / Machinery hazards", severity: 7, likelihood: 4 }, 
    "Pinch / nip points": { group: "Mechanical / Machinery hazards", severity: 7, likelihood: 5 }, 
    "Rotating parts (entanglement)": { group: "Mechanical / Machinery hazards", severity: 9, likelihood: 3 }, 
    "Moving parts (cutting)": { group: "Mechanical / Machinery hazards", severity: 9, likelihood: 4 }, 
    "Moving parts (crushing)": { group: "Mechanical / Machinery hazards", severity: 9, likelihood: 4 }, 
    "Ejection (parts, materials)": { group: "Mechanical / Machinery hazards", severity: 5, likelihood: 5 }, 
    "Angular, sharp and cutting elements": { group: "Mechanical / Machinery hazards", severity: 7, likelihood: 5 }, 
    "Degraded or malfunctioning equipment": { group: "Mechanical / Machinery hazards", severity: 8, likelihood: 4 }, 
    "Equipment failure": { group: "Mechanical / Machinery hazards", severity: 9, likelihood: 3 }, 
    "Improper use of tools/machines": { group: "Mechanical / Machinery hazards", severity: 7, likelihood: 6 }, 
    "Inadequate guarding": { group: "Mechanical / Machinery hazards", severity: 8, likelihood: 4 }, 
    "Use of lifting equipment and accessories": { group: "Mechanical / Machinery hazards", severity: 7, likelihood: 5 }, 
    "Use of suspension equipment (jacks, etc.)": { group: "Mechanical / Machinery hazards", severity: 8, likelihood: 4 }, 
    "Acceleration / deceleration": { group: "Mechanical / Machinery hazards", severity: 6, likelihood: 5 }, 
    "Slips, trips, and falls (same level or height)": { group: "Workplace / Infrastructure Design", severity: 3, likelihood: 8 }, 
    "Slippery, uneven, unstable or damaged floor": { group: "Workplace / Infrastructure Design", severity: 5, likelihood: 7 }, 
    "Congested or obstructed workplace": { group: "Workplace / Infrastructure Design", severity: 3, likelihood: 8 }, 
    "Clutter / Mess": { group: "Workplace / Infrastructure Design", severity: 4, likelihood: 7 }, 
    "Protrusion (bump, puncture, cut, etc.)": { group: "Workplace / Infrastructure Design", severity: 5, likelihood: 6 }, 
    "Hot surface": { group: "Workplace / Infrastructure Design", severity: 6, likelihood: 5 }, 
    "Cold surface": { group: "Workplace / Infrastructure Design", severity: 5, likelihood: 5 }, 
    "Rough surface": { group: "Workplace / Infrastructure Design", severity: 4, likelihood: 6 }, 
    "Unsecured items at height": { group: "Workplace / Infrastructure Design", severity: 7, likelihood: 4 }, 
    "Work at height (<1.2m - <4 feet)": { group: "Workplace / Infrastructure Design", severity: 5, likelihood: 6 }, 
    "Work at height (‚â•1.2m - ‚â•4 feet)": { group: "Workplace / Infrastructure Design", severity: 8, likelihood: 5 }, 
    "Poor ventilation": { group: "Workplace / Infrastructure Design", severity: 4, likelihood: 7 }, 
    "Extreme heat": { group: "Workplace / Infrastructure Design", severity: 6, likelihood: 4 }, 
    "Extreme cold": { group: "Workplace / Infrastructure Design", severity: 6, likelihood: 4 }, 
    "Snow or ice": { group: "Workplace / Infrastructure Design", severity: 5, likelihood: 5 }, 
    "Extreme wind": { group: "Workplace / Infrastructure Design", severity: 6, likelihood: 3 }, 
    "Other adverse weather conditions": { group: "Workplace / Infrastructure Design", severity: 5, likelihood: 4 }, 
    "Confined spaces": { group: "Workplace / Infrastructure Design", severity: 8, likelihood: 3 }, 
    "Lone work": { group: "Workplace / Infrastructure Design", severity: 6, likelihood: 5 }, 
    "Temporary works or unstable structures": { group: "Workplace / Infrastructure Design", severity: 7, likelihood: 4 }, 
    "Engulfment": { group: "Workplace / Infrastructure Design", severity: 9, likelihood: 3 }, 
    "Inclined surface": { group: "Workplace / Infrastructure Design", severity: 5, likelihood: 6 }, 
    "Poor visibility": { group: "Workplace / Infrastructure Design", severity: 4, likelihood: 7 }, 
    "Coactivity area": { group: "Workplace / Infrastructure Design", severity: 6, likelihood: 6 }, 
    "Noise exposure": { group: "Physical health hazards", severity: 3, likelihood: 9 }, 
    "Vibration / Impact (hand-arm, whole-body)": { group: "Physical health hazards", severity: 5, likelihood: 8 }, 
    "Heat stress": { group: "Physical health hazards", severity: 5, likelihood: 5 }, 
    "Cold stress": { group: "Physical health hazards", severity: 5, likelihood: 5 }, 
    "Poor lighting (intensity, glare, reflection)": { group: "Physical health hazards", severity: 4, likelihood: 7 }, 
    "Electro-magnetic fields": { group: "Physical health hazards", severity: 6, likelihood: 3 }, 
    "Ionizing radiation (X-rays, radioactive elements)": { group: "Physical health hazards", severity: 9, likelihood: 2 }, 
    "Non-ionizing radiation (UV, microwave, laser, welding radiations)": { group: "Physical health hazards", severity: 7, likelihood: 4 }, 
    "Severe draft (e.g. cold air current)": { group: "Physical health hazards", severity: 5, likelihood: 5 }, 
    "Smoke and fumes": { group: "Physical health hazards", severity: 6, likelihood: 6 }, 
    "Physical health [Generic]": { group: "Physical health hazards", severity: 5, likelihood: 5 }, 
    "Explosive materials": { group: "Chemical hazards", severity: 10, likelihood: 1 }, 
    "Flammable materials": { group: "Chemical hazards", severity: 10, likelihood: 1 }, 
    "Oxidising materials": { group: "Chemical hazards", severity: 9, likelihood: 2 }, 
    "Corrosive materials": { group: "Chemical hazards", severity: 7, likelihood: 3 }, 
    "Acute toxicity materials": { group: "Chemical hazards", severity: 8, likelihood: 3 }, 
    "Health hazard, sensitizers, allergens materials": { group: "Chemical hazards", severity: 6, likelihood: 5 }, 
    "Carcinogens, mutagens, reprotoxic (CMRs) materials": { group: "Chemical hazards", severity: 9, likelihood: 2 }, 
    "Gas under pressure": { group: "Chemical hazards", severity: 7, likelihood: 3 }, 
    "Asbestos": { group: "Chemical hazards", severity: 9, likelihood: 2 }, 
    "Fibers other than asbestos": { group: "Chemical hazards", severity: 7, likelihood: 3 }, 
    "Oil": { group: "Chemical hazards", severity: 5, likelihood: 4 }, 
    "Crystalline silica": { group: "Chemical hazards", severity: 8, likelihood: 3 }, 
    "Organic peroxides": { group: "Chemical hazards", severity: 9, likelihood: 2 }, 
    "Nanomaterials": { group: "Chemical hazards", severity: 6, likelihood: 3 }, 
    "Endocrine disrupters": { group: "Chemical hazards", severity: 7, likelihood: 4 }, 
    "Lead-containing material": { group: "Chemical hazards", severity: 8, likelihood: 3 }, 
    "Particulate material (dust, smoke, fog, aerosol)": { group: "Chemical hazards", severity: 6, likelihood: 6 }, 
    "Improper labeling or storage": { group: "Chemical hazards", severity: 7, likelihood: 5 }, 
    "Incompatible chemical reactions": { group: "Chemical hazards", severity: 8, likelihood: 4 }, 
    "Chemical spills or leaks": { group: "Chemical hazards", severity: 7, likelihood: 5 }, 
    "Water reactive substances": { group: "Chemical hazards", severity: 8, likelihood: 3 }, 
    "Shock / vibration sensitive substances": { group: "Chemical hazards", severity: 9, likelihood: 2 }, 
    "Chemicals [Generic]": { group: "Chemical hazards", severity: 5, likelihood: 5 }, 
    "Electricity": { group: "Hazardous Energy", severity: 10, likelihood: 2 }, 
    "Electrostatic": { group: "Hazardous Energy", severity: 7, likelihood: 3 }, 
    "Electromagnetic fields": { group: "Hazardous Energy", severity: 6, likelihood: 3 }, 
    "Arc flash": { group: "Hazardous Energy", severity: 10, likelihood: 2 }, 
    "Magnetic": { group: "Hazardous Energy", severity: 6, likelihood: 3 }, 
    "Equipment under pressure": { group: "Hazardous Energy", severity: 8, likelihood: 3 }, 
    "Compressed air": { group: "Hazardous Energy", severity: 7, likelihood: 4 }, 
    "Vacuum": { group: "Hazardous Energy", severity: 6, likelihood: 3 }, 
    "Hydraulic": { group: "Hazardous Energy", severity: 7, likelihood: 3 }, 
    "Pneumatic": { group: "Hazardous Energy", severity: 5, likelihood: 3 }, 
    "Thermal energy (steam, heated surfaces)": { group: "Hazardous Energy", severity: 7, likelihood: 4 }, 
    "Kinetic energy": { group: "Hazardous Energy", severity: 7, likelihood: 5 }, 
    "Gravity": { group: "Hazardous Energy", severity: 7, likelihood: 5 }, 
    "Stored energy (pneumatic, hydraulic, mechanical, electrical)": { group: "Hazardous Energy", severity: 8, likelihood: 4 }, 
    "Exothermic chemical reaction": { group: "Hazardous Energy", severity: 9, likelihood: 3 }, 
    "Hazardous Energy [Generic]": { group: "Hazardous Energy", severity: 7, likelihood: 4 }, 
    "Interaction pedestrian/pedestrian": { group: "Transportation", severity: 4, likelihood: 6 }, 
    "Interaction pedestrian/bicycle": { group: "Transportation", severity: 5, likelihood: 5 }, 
    "Interaction pedestrian/Vehicle": { group: "Transportation", severity: 7, likelihood: 3 }, 
    "Interaction bicycle/bicycle": { group: "Transportation", severity: 5, likelihood: 4 }, 
    "Interaction bicycle/Vehicle": { group: "Transportation", severity: 8, likelihood: 4 }, 
    "Interaction Vehicle/Vehicle": { group: "Transportation", severity: 9, likelihood: 3 }, 
    "Interaction Vehicle/Stationary items": { group: "Transportation", severity: 7, likelihood: 4 }, 
    "Poor road or yard conditions": { group: "Transportation", severity: 6, likelihood: 5 }, 
    "Unintentional vehicle movement": { group: "Transportation", severity: 8, likelihood: 3 }, 
    "High speed vehicle, tire grip loss": { group: "Transportation", severity: 9, likelihood: 3 }, 
    "Inadequate load securing": { group: "Transportation", severity: 7, likelihood: 4 }, 
    "Traffic [Generic]": { group: "Transportation", severity: 6, likelihood: 5 }, 
    "Postures (Hit list)": { group: "Ergonomic hazards", severity: 3, likelihood: 9 }, 
    "Force": { group: "Ergonomic hazards", severity: 5, likelihood: 8 }, 
    "Lifting/Lowering": { group: "Ergonomic hazards", severity: 5, likelihood: 8 }, 
    "Pushing": { group: "Ergonomic hazards", severity: 5, likelihood: 8 }, 
    "Pulling": { group: "Ergonomic hazards", severity: 5, likelihood: 8 }, 
    "Carrying": { group: "Ergonomic hazards", severity: 5, likelihood: 8 }, 
    "Soft tissue compression": { group: "Ergonomic hazards", severity: 5, likelihood: 7 }, 
    "Ill-fitting gloves": { group: "Ergonomic hazards", severity: 4, likelihood: 6 }, 
    "Standing or Sitting for long periods": { group: "Ergonomic hazards", severity: 4, likelihood: 8 }, 
    "Computer workstation / Screen": { group: "Ergonomic hazards", severity: 4, likelihood: 9 }, 
    "Inadequate tool or workstation design": { group: "Ergonomic hazards", severity: 5, likelihood: 7 }, 
    "Poor ergonomics [Generic]": { group: "Ergonomic hazards", severity: 5, likelihood: 7 }, 
    "Ambiguity of the roles and responsibilities": { group: "Organizational and Psychosocial", severity: 3, likelihood: 8 }, 
    "Inadequate staffing": { group: "Organizational and Psychosocial", severity: 4, likelihood: 7 }, 
    "High job demands (physical or mental workload)": { group: "Organizational and Psychosocial", severity: 3, likelihood: 8 }, 
    "Low job control or autonomy": { group: "Organizational and Psychosocial", severity: 3, likelihood: 7 }, 
    "Monotonous or repetitive tasks": { group: "Organizational and Psychosocial", severity: 3, likelihood: 9 }, 
    "Unclear job roles or expectations": { group: "Organizational and Psychosocial", severity: 3, likelihood: 8 }, 
    "Job insecurity or precarious employment": { group: "Organizational and Psychosocial", severity: 4, likelihood: 7 }, 
    "Long working hours or shift work": { group: "Organizational and Psychosocial", severity: 4, likelihood: 8 }, 
    "Unrealistic deadlines": { group: "Organizational and Psychosocial", severity: 3, likelihood: 8 }, 
    "Coactivity": { group: "Organizational and Psychosocial", severity: 4, likelihood: 6 }, 
    "Unfamiliar work": { group: "Organizational and Psychosocial", severity: 4, likelihood: 5 }, 
    "New hire / temporary worker": { group: "Organizational and Psychosocial", severity: 3, likelihood: 7 }, 
    "Insufficient / inadequate training": { group: "Organizational and Psychosocial", severity: 4, likelihood: 7 }, 
    "Violations of rules": { group: "Organizational and Psychosocial", severity: 5, likelihood: 6 }, 
    "Misuse of computer systems / equipment": { group: "Organizational and Psychosocial", severity: 4, likelihood: 6 }, 
    "Lack of adherence to standard": { group: "Organizational and Psychosocial", severity: 4, likelihood: 7 }, 
    "Lack of standard": { group: "Organizational and Psychosocial", severity: 4, likelihood: 7 }, 
    "Disrupted sleep pattern (shift work)": { group: "Organizational and Psychosocial", severity: 4, likelihood: 8 }, 
    "Incompatible simultaneous activities": { group: "Organizational and Psychosocial", severity: 4, likelihood: 6 }, 
    "Distraction": { group: "Organizational and Psychosocial", severity: 3, likelihood: 9 }, 
    "Isolation (especially in remote work or lone working roles)": { group: "Organizational and Psychosocial", severity: 4, likelihood: 7 }, 
    "Workplace bullying or harassment": { group: "Organizational and Psychosocial", severity: 5, likelihood: 6 }, 
    "Discrimination (e.g. gender, race, age)": { group: "Organizational and Psychosocial", severity: 5, likelihood: 5 }, 
    "Poor supervisor or managerial support": { group: "Organizational and Psychosocial", severity: 4, likelihood: 8 }, 
    "Inconsistent communication during organizational change": { group: "Organizational and Psychosocial", severity: 3, likelihood: 7 }, 
    "Lack of transparency or trust in leadership": { group: "Organizational and Psychosocial", severity: 4, likelihood: 7 }, 
    "Poor organizational justice (unfair treatment)": { group: "Organizational and Psychosocial", severity: 4, likelihood: 6 }, 
    "Lack of recognition or reward": { group: "Organizational and Psychosocial", severity: 3, likelihood: 8 }, 
    "Lack of communication or feedback": { group: "Organizational and Psychosocial", severity: 3, likelihood: 8 }, 
    "Lack of employee involvement in decision-making": { group: "Organizational and Psychosocial", severity: 3, likelihood: 7 }, 
    "Dealing with aggressive or violent people": { group: "Organizational and Psychosocial", severity: 5, likelihood: 5 }, 
    "Exposure to distressing situations (e.g. emergency services, healthcare, customer complaints)": { group: "Organizational and Psychosocial", severity: 5, likelihood: 6 }, 
    "Lack of privacy or personal space": { group: "Organizational and Psychosocial", severity: 3, likelihood: 7 }, 
    "Inadequate rest areas": { group: "Organizational and Psychosocial", severity: 3, likelihood: 7 }, 
    "Overcrowded or chaotic workspaces": { group: "Organizational and Psychosocial", severity: 4, likelihood: 7 }, 
    "Remote Work Specific Hazards": { group: "Organizational and Psychosocial", severity: 4, likelihood: 8 }, 
    "Work-Life Balance": { group: "Organizational and Psychosocial", severity: 4, likelihood: 9 }, 
    "Employment restriction (e.g. Pregnant/breastfeeding, handicap)": { group: "Organizational and Psychosocial", severity: 5, likelihood: 5 }, 
    "Viruses, bacteria, fungi": { group: "Biological hazard", severity: 7, likelihood: 3 }, 
    "Legionella (specific bacteria)": { group: "Biological hazard", severity: 8, likelihood: 3 }, 
    "Molds or allergens": { group: "Biological hazard", severity: 5, likelihood: 5 }, 
    "Handling human or animal bodily fluids": { group: "Biological hazard", severity: 7, likelihood: 4 }, 
    "Bloodborne pathogens": { group: "Biological hazard", severity: 8, likelihood: 3 }, 
    "Contaminated waste or biological material": { group: "Biological hazard", severity: 6, likelihood: 4 }, 
    "Potability of water": { group: "Biological hazard", severity: 6, likelihood: 4 }, 
    "Food hygiene": { group: "Biological hazard", severity: 6, likelihood: 5 }, 
    "Animal or insect bites/stings": { group: "Biological hazard", severity: 5, likelihood: 5 }, 
    "Animal waste": { group: "Biological hazard", severity: 6, likelihood: 4 }, 
    "Hazardous vegetation": { group: "Biological hazard", severity: 4, likelihood: 4 }, 
    "Flammable and combustible materials": { group: "Fire and explosion", severity: 10, likelihood: 2 }, 
    "Ignition sources": { group: "Fire and explosion", severity: 10, likelihood: 2 }, 
    "Ignition sources (open flames, sparks, static)": { group: "Fire and explosion", severity: 10, likelihood: 2 },  // NEW
    "Dust explosions (e.g., coal, wood, metal dust)": { group: "Fire and explosion", severity: 10, likelihood: 2 },  // NEW
    "Oxygen-enriched environments": { group: "Fire and explosion", severity: 9, likelihood: 2 }  // NEW
};
        const CONSEQUENCE_REGISTRY = [ "Abrasion, Scratches", "Allergic Reaction", "Amputation", "Asphyxiation", "Burn - Chemical", "Burn - Electrical/Electrocution", "Burn or Scald (thermal)", "Chemical exposure", "Concussion", "Contusion, Bruise", "Crushing injury", "Laceration, Cut, Open wound", "Fracture", "Frostbite / Hypothermia", "Hearing loss, or impairment", "Heat Stress / Exhaustion / Stroke", "Hernia", "Mental Stress / Work-related Mental Health Condition", "Musculoskeletal Disorder (MSD)", "Poisoning", "Puncture", "Repetitive motion injury", "Respiratory irritation (e.g. Asthma)", "Sprain", "Strain" ];
        const FREQUENCY_SCALE = { "1": "RARELY (<30 min/day)", "1.25": "OCCASIONAL (<2 hrs/wk)", "1.5": "INTERMEDIATE (2-8 hrs/wk)", "1.75": "FREQUENTLY (1-3 days/wk)", "2": "PERMANENT (>3 days/wk)" };
        const SEVERITY_SCALE = { "1": "No potential of injury", "3": "Potential of FIRST AID", "5": "Potential of MEDICAL TREATMENT", "7": "Potential of DART", "9": "Potential of SIA", "10": "Potential of Fatality" };
        const LIKELIHOOD_SCALE = { "1": "Almost impossible", "3": "Very unlikely", "5": "Possible to happen", "8": "Likely to happen", "10": "Very likely to happen" };
        const HAZARD_GROUPS = [...new Set(Object.values(HAZARD_REGISTRY).map(item => item.group))].sort();
        // --- NEW: Moved helper functions and classes to IIFE scope ---
        // --- NEW: Helper function to split an array into chunks ---
        const chunkArray = (arr, size) =>
            Array.from({ length: Math.ceil(arr.length / size) }, (v, i) =>
                arr.slice(i * size, i * size + size)
            );

        // (createFinalFileName is defined in the global scope above so other modules can use it)
            
        // --- Moved helper functions and classes to IIFE scope ---
        const selectClasses = "w-full p-2 border border-slate-300 rounded-md bg-white focus:ring-2 focus:ring-indigo-500 transition";
        const inputClasses = "w-full p-2 border border-slate-300 rounded-md bg-white focus:ring-2 focus:ring-indigo-500 transition";

        const createDropdown = (options, selectedValue, onChange) => {
            let optionsHTML = Object.entries(options).map(([value, text]) => {
                const translatedText = t(text);
                return `<option value="${value}" ${value == selectedValue ? 'selected' : ''}>${value} - ${translatedText}</option>`;
            }).join('');
            return `<select class="${selectClasses}" onchange="${onChange}">${optionsHTML}</select>`;
        };
        
        const createTextDropdown = (options, selectedValue, onChange) => {
            // Ensure selectedValue exists in options, add if not (AI might hallucinate)
            let currentOptions = [...options]; // Copy
            if (!currentOptions.includes(selectedValue) && selectedValue) {
                currentOptions.unshift(selectedValue); // Add to beginning
            }
            let optionsHTML = currentOptions.map(optionName => {
                const translatedName = t(optionName);
                return `<option value="${optionName}" ${optionName === selectedValue ? 'selected' : ''}>${translatedName}</option>`;
            }).join('');
            return `<select class="${selectClasses}" onchange="${onChange}">${optionsHTML}</select>`;
        };
        
        const createHazardGroupDropdown = (selectedValue) => {
             // Ensure selectedValue exists in options, add if not
             let currentGroups = [...HAZARD_GROUPS]; // Copy
             if (!currentGroups.includes(selectedValue) && selectedValue) {
                   currentGroups.unshift(selectedValue); // Add to beginning
             }
            let optionsHTML = currentGroups.map(groupName => {
                const translatedGroup = t(groupName);
                return `<option value="${groupName}" ${groupName === selectedValue ? 'selected' : ''}>${translatedGroup}</option>`;
            }).join('');
            const isUnknown = selectedValue === 'Unknown' ? 'border-red-500 text-red-600' : '';
            return `<select class="${selectClasses} ${isUnknown}" onchange="this.className = this.value === 'Unknown' ? '${selectClasses} border-red-500 text-red-600' : '${selectClasses}'">${optionsHTML}</select>`;
        };
        // --- END NEW ---

        // --- Make dropdown functions globally accessible for language change listener ---
        window.createDropdown = createDropdown;
        window.createHazardGroupDropdown = createHazardGroupDropdown;
        window.createTextDropdown = createTextDropdown;

        // Make functions global so inline HTML onclicks can find them
        window.processFreeText = async function() {
            const userInput = document.getElementById('freeTextInput').value;
            const generateBtn = document.getElementById('generateTasksBtn');
            if (!userInput.trim()) {
                showCustomAlert("Please describe the task first.", 'info');
                return;
            }
            generateBtn.disabled = true;
           generateBtn.innerHTML = `${spinnerSVG} Analyzing Description...`;
            
            const tableContainer = document.getElementById('table-container');
            tableContainer.innerHTML = "<p class='text-center p-8 text-slate-600 italic'>Generating task breakdown... This may take a moment.</p>";
            document.getElementById('dashboard-container').style.display = 'block';
            
            // Split large input into batches to avoid losing data
            // Batch strategy: split on sentence boundaries (~1200 chars per batch for efficiency)
            const batches = splitTextIntoBatches(userInput, 1200);
            
            if (batches.length > 1) {
                // Use batch processing for better analysis
                console.debug(`Input is large (${userInput.length} chars). Processing in ${batches.length} batches...`);
                await processBatchesAndPopulateTable(batches);
            } else {
                // Small input: process directly
                const breakdownPrompt = `
                You are a world-class safety and risk assessment expert. Your task is to analyze the user's description of a work process and break it down into a structured JSON array for a detailed risk assessment table. You must be thorough.
                **Your Knowledge Base (Use these exact values for matching):**
                - Hazard List Registry: ${JSON.stringify(Object.keys(HAZARD_REGISTRY))}
                - Consequence Registry: ${JSON.stringify(CONSEQUENCE_REGISTRY)}
                - Frequency Scale: ${JSON.stringify(FREQUENCY_SCALE)}
                - Severity Scale: ${JSON.stringify(SEVERITY_SCALE)}
                - Likelihood Scale: ${JSON.stringify(LIKELIHOOD_SCALE)}
                **User's Input:** "${userInput}"
                **Your Instructions (Critical: Follow these for EACH task/step you identify):**
                1. **Identify the Step:** Clearly state the task or sub-task in the "Steps" field.
                2. **Comprehensive Hazard Identification (Most Important Rule):**
                   * For each step, identify ALL plausible direct, indirect, and hidden hazards.
                   * For EACH identified hazard, create a separate JSON object. The same "Steps" value will appear in multiple objects if a step has multiple hazards.
                3. **Match Hazard:** Select the single most appropriate "Hazard List" item from the Registry.
                4. **Match Consequence:** Select the single most appropriate "Risk/Consequences" item from the Registry.
                5. **Infer Details:** Infer "Hazard Source," suggest "Current Control," and classify "Routine/Non-Routine/Emergency Situation".
                6. **Select F, S, L Values:** Select the most appropriate NUMERIC value for "Frequency," "Severity," and "Likelihood" from the scales.
                7. **Consider Past Incidents:** If the user's input mentions previous incidents, near misses, or accidents related to a specific step or hazard, you MUST increase the 'Likelihood' score for that specific hazard object accordingly (e.g., move from 5 'Possible' to 8 'Likely' or from 8 'Likely' to 10 'Very likely') to reflect the known history. Clearly state in the "Hazard Source" if a past incident influenced the score (e.g., "Manual lifting - Past back strain incident reported").
                8. **Link Image ID:** The user's input may contain (ImageID: xxx). If you see this, you MUST add this exact ID to your JSON object for that step using the key "imageId". If no ID is provided for a step, output imageId: null.
                **Final Output:** Your response MUST ONLY be a valid JSON array of objects. Do not include any text outside the JSON. Each object MUST have these keys: "Steps", "Hazard List", "Risk/Consequences", "Hazard Source", "Current Control", "Routine/Non-Routine/Emergency Situation", "Frequency", "Severity", "Likelihood".

                `;
                
                try {
                    console.debug("Attempting task generation with primary (paid) model:", PAID_MODEL);
                    const response = await callAPI(PAID_MODEL, breakdownPrompt);
                    const taskData = parseAndCleanData(response);
                    
                    buildTableFromData(taskData);
                    initializeDashboard();
                } catch (error) {
                    console.error("AI task generation failed.", error);
                    tableContainer.innerHTML = `<p class="text-center p-8 text-red-600 font-medium">Error: ${error.message}. The AI failed to generate a valid task list. Please try rephrasing your description.</p>`;
                } finally {
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = "Generate Task Breakdown";
                }
            }
        }

        async function processBatchesAndPopulateTable(batches) {
    const generateBtn = document.getElementById('generateTasksBtn');
    generateBtn.disabled = true;
    generateBtn.innerHTML = `${spinnerSVG} Analyzing in batches...`;

    const tableContainer = document.getElementById('table-container');
    tableContainer.innerHTML = `<div class='text-center p-8'>
        <div class='inline-flex items-center gap-3'>
            <svg class='animate-spin h-6 w-6 text-indigo-600' xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24'>
                <circle class='opacity-25' cx='12' cy='12' r='10' stroke='currentColor' stroke-width='4'></circle>
                <path class='opacity-75' fill='currentColor' d='M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z'></path>
            </svg>
            <p class='text-slate-600 font-medium'>Analyzing in ${batches.length} batches... This may take a moment.</p>
        </div>
    </div>`;

    // Auto-scroll to bottom of page
    setTimeout(() => {
        window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    }, 100);

    let allTaskData = [];  // Combined results from all batches

    // Process batches in parallel with concurrency limit (3 at a time)
    const concurrencyLimit = 3;
    const batchPromises = batches.map((batchText, index) => 
        processBatchSafely(batchText, index)
    );

    // Execute with concurrency limit
    const results = await executeWithConcurrencyLimit(batchPromises, concurrencyLimit);
    
    // Merge all results
    results.forEach(result => {
        if (result && result.data) {
            allTaskData = allTaskData.concat(result.data);
        }
        if (result && result.error) {
            console.error(result.error);
            showCustomAlert(`${result.error}`, 'error');
        }
    });

    if (allTaskData.length > 0) {
        buildTableFromData(allTaskData);
        initializeDashboard();
        // Auto-scroll to table after generation completes
        setTimeout(() => {
            const table = document.querySelector('#table-container table');
            if (table) table.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 500);
    } else {
        tableContainer.innerHTML = `<p class="text-center p-8 text-red-600 font-medium">Error: All batches failed. Please try again.</p>`;
    }

    generateBtn.disabled = false;
    generateBtn.innerHTML = "Generate Task Breakdown";
}

    // Helper: Process single batch safely
    async function processBatchSafely(batchText, batchIndex) {
        const batchPrompt = `
   Process each --- ENTRY --- block separately and generate JSON objects only for that entry before moving to the next.
    You are a world-class safety and risk assessment expert. Analyze this high-risk batch of image notes and break it down into a structured JSON array for a risk assessment table. You must be thorough.
    **Your Knowledge Base (Use these exact values for matching):**
    - Hazard List Registry: ${JSON.stringify(Object.keys(HAZARD_REGISTRY))}
    - Consequence Registry: ${JSON.stringify(CONSEQUENCE_REGISTRY)}
    - Frequency Scale: ${JSON.stringify(FREQUENCY_SCALE)}
    - Severity Scale: ${JSON.stringify(SEVERITY_SCALE)}
    - Likelihood Scale: ${JSON.stringify(LIKELIHOOD_SCALE)}
    **User's Input:** "${batchText}"
    **Your Instructions (Critical: Follow these for EACH task/step you identify):**
   - For all JSON objects generated from a single --- ENTRY ---, use the exact ImageID from that ENTRY's (ImageID: xxx) in the "imageId" key.
   - Use the exact text after "STEP/DESCRIPTION:" as the "Steps" value, without rephrasing or modification.
    1. **Identify the Step:** Clearly state the task or sub-task in the "Steps" field.
    2. **User Pre-Rated Hazards (HIGHEST PRIORITY):**
       * If the user has provided USER RATINGS (Frequency, Severity, Likelihood) in the ENTRY, you MUST preserve these exact numeric values in the JSON objects for any hazards they have identified.
       * When a user specifies F/S/L ratings, this indicates they have pre-assessed certain hazards. Keep their ratings as the primary values.
       * After preserving user-rated hazards, identify ANY ADDITIONAL hazards they may have missed based on the description, and generate separate JSON objects for those.
    3. **Comprehensive Hazard Identification (Most Important Rule):**
       * For each step, identify ALL plausible direct, indirect, and hidden hazards.
       * For EACH identified hazard, create a separate JSON object. The same "Steps" value will appear in multiple objects if a step has multiple hazards.
    4. **Match Hazard:** Select the single most appropriate "Hazard List" item from the Registry.
    5. **Match Consequence:** Select the single most appropriate "Risk/Consequences" item from the Registry.
    6. **Infer Details:** Infer "Hazard Source," suggest "Current Control," and classify "Routine/Non-Routine/Emergency Situation".
    7. **Select F, S, L Values:** For user pre-rated hazards, use their provided values. For newly identified hazards, select the most appropriate NUMERIC value from the scales.
    8. **Consider Past Incidents:** If the user's input mentions previous incidents, near misses, or accidents related to a specific step or hazard, you MUST increase the 'Likelihood' score for that specific hazard object accordingly (e.g., move from 5 'Possible' to 8 'Likely' or from 8 'Likely' to 10 'Very likely') to reflect the known history. Clearly state in the "Hazard Source" if a past incident influenced the score (e.g., "Manual lifting - Past back strain incident reported").
    9. **Link Image ID:** The user's input contains (ImageID: xxx) for each ENTRY. You MUST add this exact ID to EVERY JSON object generated from that ENTRY using the key "imageId". If no ID, use null.
    Process ONLY this batch. Output a JSON array that can be merged with others.
    **Final Output:** Your response MUST ONLY be a valid JSON array of objects. Do not include any text outside the JSON. Each object MUST have these keys: "Steps", "Hazard List", "Risk/Consequences", "Hazard Source", "Current Control", "Routine/Non-Routine/Emergency Situation", "Frequency", "Severity", "Likelihood".
`;

        try {
            const response = await callAPI(PAID_MODEL, batchPrompt);
            const batchData = parseAndCleanData(response);
            return { data: batchData, error: null };
        } catch (error) {
            return { data: [], error: `Batch ${batchIndex + 1} failed: ${error.message}` };
        }
    }

    // Helper: Execute promises with concurrency limit
    async function executeWithConcurrencyLimit(promises, limit) {
        const results = [];
        const executing = [];
        
        for (const promise of promises) {
            const p = promise.then(result => {
                executing.splice(executing.indexOf(p), 1);
                return result;
            });
            results.push(p);
            executing.push(p);
            
            if (executing.length >= limit) {
                await Promise.race(executing);
            }
        }
        
        return Promise.all(results);
    }

window.processBatchesAndPopulateTable = processBatchesAndPopulateTable;

        // Helper function: Split text into logical batches to avoid data loss
        function splitTextIntoBatches(text, maxBatchSize = 500) {
            const batches = [];
            let currentBatch = '';
            
            // Split by sentence boundaries (period, question mark, exclamation mark)
            const sentences = text.split(/(?<=[.!?])\s+/);
            
            for (let sentence of sentences) {
                // If adding this sentence would exceed limit, start a new batch
                if ((currentBatch + ' ' + sentence).length > maxBatchSize && currentBatch.length > 0) {
                    batches.push(currentBatch.trim());
                    currentBatch = sentence;
                } else {
                    currentBatch += (currentBatch ? ' ' : '') + sentence;
                }
            }
            
            // Add any remaining text
            if (currentBatch.trim()) {
                batches.push(currentBatch.trim());
            }
            
            return batches.length > 0 ? batches : [text]; // Return at least the original text
        }

        function buildTableFromData(data) {
            const tableContainer = document.getElementById('table-container');
            if (!data || data.length === 0) {
                tableContainer.innerHTML = "<p class='text-center p-8 text-slate-600 italic'>The AI could not identify any tasks. Please try a different description.</p>";
                return;
            }
            
            // --- MODIFICATION: Added "Picture", "AI" and "Delete" headers ---
            const headers = ["Picture", "AI", "Steps", "Hazard Group", "Hazard List", "Risk/Consequences", "Frequency", "Severity", "Likelihood", "Risk Score", "Risk Category", "Hazard Source", "Current Control", "Routine/Non-Routine/Emergency Situation", "Delete"];
            // --- END MODIFICATION ---
            
            // Tailwind classes for table
            const tableClasses = "w-full text-sm";
            const thClasses = "p-3 text-left font-semibold text-slate-700 uppercase tracking-wider";
            const tdClasses = "p-3 border-b border-slate-200 text-slate-700 align-top";
            
            let tableHTML = `<div class="p-6 sm:p-8"><table class="${tableClasses}">
                                <thead><tr>`;
            headers.forEach(header => { tableHTML += `<th class="${thClasses}">${header}</th>`; });
            tableHTML += "</tr></thead><tbody>";
           
data.forEach((row, index) => {
                // Ensure defaults for potentially missing AI output
                const hazardListValue = row['Hazard List'] || Object.keys(HAZARD_REGISTRY)[0];
                const consequenceValue = row['Risk/Consequences'] || CONSEQUENCE_REGISTRY[0];
                const frequencyValue = row.Frequency || 1;
                const severityValue = row.Severity;
                const likelihoodValue = row.Likelihood;
               
    const hazardDetails = HAZARD_REGISTRY[hazardListValue] || { group: 'Unknown', severity: severityValue || 1, likelihood: likelihoodValue || 1 };
    const frequency = frequencyValue;
    const severity = severityValue || hazardDetails.severity;
    const likelihood = likelihoodValue || hazardDetails.likelihood;
    const riskScore = frequency * severity * likelihood;
   
    // --- MODIFICATION: Added empty picture cell with class ---
    // --- NEW, ROBUST CODE ---
    // Extract imageId from AI data or try to match by step text
    const imageId = row.imageId || findImageByStepText(row.Steps) || '';
    console.debug(`Row ${index}: Step="${row.Steps}", imageId from AI="${row.imageId}", final imageId="${imageId}" (match method: ${row.imageId ? 'AI direct' : (imageId ? 'text match' : 'none')})`);
    const matchedImage = document.getElementById(imageId);
    const originalFileName = matchedImage ? (window.originalFileNames && window.originalFileNames.get(imageId)) : '';
    
    // --- NEW: Detect if this is an AI-added row (not matching user ratings) ---
    const userRiskData = imageId && window.riskAssessmentData ? window.riskAssessmentData.get(imageId) : null;
    const isAIAddition = userRiskData && (
        (userRiskData.userFrequency && String(userRiskData.userFrequency) !== String(frequency)) ||
        (userRiskData.userSeverity && String(userRiskData.userSeverity) !== String(severity)) ||
        (userRiskData.userLikelihood && String(userRiskData.userLikelihood) !== String(likelihood))
    );
    const rowBgClass = isAIAddition ? 'bg-blue-50' : '';
    const aiBadge = isAIAddition ? `<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-indigo-100 text-indigo-700">ü§ñ AI</span>` : '';
                   
                tableHTML += `<tr data-row-index="${index}" data-image-id="${imageId}" class="hover:bg-slate-100 transition ${rowBgClass}">
                    <td class="${tdClasses} picture-cell" data-step="${row.Steps || ''}" data-hazard="${hazardListValue}" data-filename="${originalFileName || ''}"></td>
                    <td class="${tdClasses} text-center">${aiBadge}</td>
                    <td class="${tdClasses}">${row.Steps || ''}</td>
                    <td class="${tdClasses} group">${createHazardGroupDropdown(hazardDetails.group)}</td>
                    <td class="${tdClasses}">${createTextDropdown(Object.keys(HAZARD_REGISTRY), hazardListValue, `recalculateRow(${index}, 'hazard')`)}</td>
                    <td class="${tdClasses}">${createTextDropdown(CONSEQUENCE_REGISTRY, consequenceValue, `recalculateRow(${index})`)}</td>
                    <td class="${tdClasses}">${createDropdown(FREQUENCY_SCALE, frequency, `recalculateRow(${index})`)}</td>
                    <td class="${tdClasses}">${createDropdown(SEVERITY_SCALE, severity, `recalculateRow(${index})`)}</td>
                    <td class="${tdClasses}">${createDropdown(LIKELIHOOD_SCALE, likelihood, `recalculateRow(${index})`)}</td>
                    <td class="${tdClasses} score font-bold">${riskScore.toFixed(2)}</td>
                    <td class="${tdClasses} cat font-semibold">${getRiskCategory(riskScore)}</td>
                    <td class="${tdClasses}"><input type="text" value="${DOMPurify.sanitize(row['Hazard Source'] || '')}" class="${inputClasses}"></td>
                    <td class="${tdClasses}"><input type="text" value="${DOMPurify.sanitize(row['Current Control'] || '')}" class="${inputClasses}"></td>
                    <td class="${tdClasses}"><input type="text" value="${DOMPurify.sanitize(row['Routine/Non-Routine/Emergency Situation'] || '')}" class="${inputClasses}"></td>
                    <td class="${tdClasses} text-center"><button onclick="toggleRowDelete(${index}, this)" class="delete-btn" title="Delete row">üóë</button></td>
                </tr>`;
                // --- END MODIFICATION ---
            });
            tableHTML += `</tbody></table></div>`;
            tableContainer.innerHTML = tableHTML;
            
            // Re-apply risk category colors after table build
            updateAllCategoryColors();
            
            // --- NEW: Call function to add images and ensure rows have valid imageIds ---
            populatePictureColumn(); 
            // --- END NEW ---
        }

        // Helper: Try to find a matching image by looking at step text and image descriptions
        function findImageByStepText(stepText) {
            if (!stepText) return null;
            //const normalizedStep = stepText.toLowerCase().trim();
            const normalizedStep = stepText.toLowerCase().trim().replace(/\s+/g, ' '); // Normalize whitespace
            
            // Get all gallery images and their descriptions
            const galleryImages = Array.from(document.querySelectorAll('.gallery-item img'));
            for (const img of galleryImages) {
                const imgId = img.id;
                const riskData = window.riskAssessmentData && window.riskAssessmentData.get(imgId);
                if (riskData) {
                    // Try exact matches first
                    //if (riskData.description && riskData.description.toLowerCase().trim() === normalizedStep) {
                    const normDesc = riskData.description ? riskData.description.toLowerCase().trim().replace(/\s+/g, ' ') : '';
                   if (normDesc && normDesc === normalizedStep) { // Exact after normalize
                        return imgId;
                    }
                    // Then try partial matches
                    //if (riskData.description && (
                       // riskData.description.toLowerCase().includes(normalizedStep) ||
                       // normalizedStep.includes(riskData.description.toLowerCase())
                       if (normDesc && (normDesc.includes(normalizedStep) || normalizedStep.includes(normDesc))) { // Partial
                        return imgId;
                    }
                    // If no description matches, try hazards/controls
                    const normHaz = riskData.hazards ? riskData.hazards.toLowerCase().trim().replace(/\s+/g, ' ') : '';
                    if (riskData.hazards && riskData.hazards.toLowerCase().includes(normalizedStep)) {
                        return imgId;
                    }
                }
            }
            return null;
        }

        // --- UPDATED with Debugging & Click Handler: Function to add thumbnails to the table ---
        function populatePictureColumn() {
    console.debug("Attempting to populate picture column (Robust Method)...");

    const tableRows = document.querySelectorAll('#table-container table tbody tr');
    if (tableRows.length === 0) {
        console.debug("Table not found or empty.");
        return;
    }

    tableRows.forEach((row, rowIndex) => {
        // 1. Get the imageId we stored in the row
        const imageId = row.dataset.imageId;

        // 2. If the row has no associated imageId, skip it
        if (!imageId) {
        console.debug(`Row ${rowIndex}: No imageId found, skipping.`);
            return;
        }

        // 3. Find the original image element in the gallery
        const originalImageElement = document.getElementById(imageId);
        const pictureCell = row.querySelector('.picture-cell');

        if (originalImageElement && pictureCell) {
            // 4. Found it! Get its thumbnail URL
            const thumbnailUrl = originalImageElement.src;
            const originalFileName = window.originalFileNames.get(imageId) || '';
            console.debug(`Row ${rowIndex}: Match found! Adding image ${imageId}`);
            
            // 5. Populate the cell
            pictureCell.innerHTML = `<img src="${thumbnailUrl}" 
                                         alt="Thumbnail for step" 
                                         class="w-16 h-16 object-cover rounded shadow cursor-pointer hover:scale-105 transition-transform" 
                                         onclick="openTableImageModal('${thumbnailUrl}', ${rowIndex})">`;
            pictureCell.dataset.filename = originalFileName;
        } else {
            // This might happen if the image was deleted after the AI ran
            console.debug(`Row ${rowIndex}: Had imageId ${imageId}, but could not find matching image in gallery or picture cell.`);
            if (pictureCell) pictureCell.innerHTML = ''; // Ensure cell is empty
        }
    });

    console.debug("Finished populating picture column.");
}
        // --- END UPDATED with Debugging ---
        // --- END NEW ---
        window.recalculateRow = function(rowIndex, changedType) {
            // --- MODIFICATION: This selector now correctly targets the table inside #table-container ---
            const row = document.querySelector(`#table-container tr[data-row-index="${rowIndex}"]`);
            // --- END MODIFICATION ---
            
            if (!row) {
                console.error(`recalculateRow: Could not find row with index ${rowIndex}`);
                return;
            }
            
            if (changedType === 'hazard') {
                // Find the Hazard List dropdown by looking through all select elements
                // Column order: Picture, AI, Steps, Hazard Group, Hazard List, Risk/Consequences, Frequency, Severity, Likelihood, ...
                const allSelects = Array.from(row.querySelectorAll('select'));
                
                // Get all td elements
                const allTds = Array.from(row.querySelectorAll('td'));
                
                // Find indices of important columns
                let hazardGroupIndex = -1;
                let hazardListIndex = -1;
                
                // Hazard Group column has class "group"
                hazardGroupIndex = allTds.findIndex(td => td.classList.contains('group'));
                
                // Hazard List is usually the next data column after Hazard Group
                // We'll find it by trying to identify it - it contains hazard names
                allTds.forEach((td, idx) => {
                    const select = td.querySelector('select');
                    if (select && idx > hazardGroupIndex) {
                        // Check if this select contains hazard registry keys
                        for (let i = 0; i < select.options.length; i++) {
                            if (HAZARD_REGISTRY[select.options[i].value]) {
                                hazardListIndex = idx;
                                break;
                            }
                        }
                    }
                });
                
                // Fallback to nth-child if not found (for backward compatibility)
                if (hazardListIndex === -1) {
                    hazardListIndex = 4; // 0-indexed, so this is the 5th column
                }
                
                const hazardDropdown = allTds[hazardListIndex]?.querySelector('select');
                if (!hazardDropdown) {
                    console.error(`recalculateRow: Could not find Hazard List dropdown`);
                    return;
                }
                
                const selectedHazardName = hazardDropdown.value;
                const hazardDetails = HAZARD_REGISTRY[selectedHazardName] || { group: 'Unknown', severity: 1, likelihood: 1 };
                
                const groupDropdown = allTds[hazardGroupIndex]?.querySelector('select');
                if (!groupDropdown) {
                    console.error(`recalculateRow: Could not find Hazard Group dropdown`);
                    return;
                }
                
                // Make sure the group exists in the dropdown options
                let groupExists = false;
                for (let i = 0; i < groupDropdown.options.length; i++) {
                    if (groupDropdown.options[i].value === hazardDetails.group) {
                        groupExists = true;
                        break;
                    }
                }
                if (!groupExists && hazardDetails.group !== 'Unknown') { // Add if not present and not 'Unknown'
                     const newOption = document.createElement('option');
                     newOption.value = hazardDetails.group;
                     newOption.text = t(hazardDetails.group); // Use translation function
                     groupDropdown.add(newOption);
                 }
                groupDropdown.value = hazardDetails.group;
                // Update class based on unknown status
                const selectClasses = "w-full p-2 border border-slate-300 rounded-md bg-white focus:ring-2 focus:ring-indigo-500 transition"; // Re-get base classes
                groupDropdown.className = hazardDetails.group === 'Unknown' ? `${selectClasses} border-red-500 text-red-600` : selectClasses;
                
                // Find Severity and Likelihood dropdowns by column index
                // Column order: Picture(0), AI(1), Steps(2), Hazard Group(3), Hazard List(4), Risk/Consequences(5), Frequency(6), Severity(7), Likelihood(8)
                const severityTd = allTds[7]; // 0-indexed
                const likelihoodTd = allTds[8]; // 0-indexed
                
                if (severityTd) {
                    const severitySelect = severityTd.querySelector('select');
                    if (severitySelect) {
                        severitySelect.value = hazardDetails.severity;
                    }
                }
                
                if (likelihoodTd) {
                    const likelihoodSelect = likelihoodTd.querySelector('select');
                    if (likelihoodSelect) {
                        likelihoodSelect.value = hazardDetails.likelihood;
                    }
                }
            }
            
            // Get all td elements for finding the correct columns
            const allTds = Array.from(row.querySelectorAll('td'));
            
            // Column order: Picture(0), AI(1), Steps(2), Hazard Group(3), Hazard List(4), Risk/Consequences(5), Frequency(6), Severity(7), Likelihood(8), Risk Score(9), Risk Category(10)
            const frequencyTd = allTds[6];
            const severityTd = allTds[7];
            const likelihoodTd = allTds[8];
            
            // Get the select elements
            const freqSelect = frequencyTd?.querySelector('select');
            const sevSelect = severityTd?.querySelector('select');
            const likeSelect = likelihoodTd?.querySelector('select');
            
            if (!freqSelect || !sevSelect || !likeSelect) {
                console.warn(`recalculateRow: Could not find frequency, severity, or likelihood dropdowns`);
                return;
            }
            
            // Parse the numeric values from the dropdowns
            const freq = parseFloat(freqSelect.value) || 1;
            const sev = parseFloat(sevSelect.value) || 1;
            const like = parseFloat(likeSelect.value) || 1;
            
            // Calculate new risk score
            const newScore = freq * sev * like;
            const newCategory = getRiskCategory(newScore);
            
            // Column order: Picture(0), AI(1), Steps(2), Hazard Group(3), Hazard List(4), Risk/Consequences(5), Frequency(6), Severity(7), Likelihood(8), Risk Score(9), Risk Category(10)
            const scoreCell = allTds[9];
            const categoryCell = allTds[10];
            
            if (scoreCell) {
                scoreCell.textContent = newScore.toFixed(2);
            }
            
            if (categoryCell) {
                categoryCell.textContent = newCategory;
                updateCategoryColor(categoryCell, newCategory);
            }
            
            updateDashboardMetrics();
        }
        // --- NEW: Function to recalculate RESIDUAL row ---
        window.recalculateResidualRow = function(rowIndex) {
            const row = document.querySelector(`#table-container tr[data-row-index="${rowIndex}"]`);
            if (!row) return;

            // Find cells by their new helper classes
            const freqEl = row.querySelector('.res-freq select');
            const sevEl = row.querySelector('.res-sev select');
            const likeEl = row.querySelector('.res-like select');

            if (!freqEl || !sevEl || !likeEl) {
                console.warn(`Could not find residual dropdowns for row ${rowIndex}`);
                return;
            }

            const freq = parseFloat(freqEl.value);
            const sev = parseFloat(sevEl.value);
            const like = parseFloat(likeEl.value);
            
            const newScore = freq * sev * like;
            const newCategory = getRiskCategory(newScore);
            
            // Find score/cat cells by class
            const scoreCell = row.querySelector('.res-score');
            const catCell = row.querySelector('.res-cat');

            if (scoreCell) scoreCell.textContent = newScore.toFixed(2);
            if (catCell) {
                catCell.textContent = newCategory;
                updateCategoryColor(catCell, newCategory); // Update color
            }
        }
        // --- END NEW ---
        function getRiskCategory(score) {
            if (score >= 72) return "CRITICAL"; if (score >= 50) return "HIGH"; if (score >= 20) return "MEDIUM"; return "LOW";
        }
        
        function getRiskCategoryColor(category) {
            switch(category) {
                case "CRITICAL": return "text-red-700";
                case "HIGH": return "text-orange-600";
                case "MEDIUM": return "text-amber-600";
                case "LOW": return "text-green-700";
                default: return "text-slate-700";
            }
        }

        function updateRecDropdown(riskCount) {
    const select = document.getElementById('recCountSelect');
    if (!select) return;

    const currentValue = select.value; // Save what the user last selected
    select.innerHTML = ''; // Clear all old options

    if (riskCount === 0) {
        select.options.add(new Option("No High/Medium risks", "0"));
        select.disabled = true;
        return;
    }
    
    select.disabled = false;
    
    // Add "Top 5"
    select.options.add(new Option("Top 5 Risks", "5"));
    
    // Add "Top 10"
    select.options.add(new Option("Top 10 Risks", "10"));
    
    // Add "All"
    select.options.add(new Option(`All ${riskCount} High/Medium Risks`, "all"));
    
    // Disable options that are larger than the total count
    select.querySelector('option[value="5"]').disabled = riskCount < 5;
    select.querySelector('option[value="10"]').disabled = riskCount < 10;
    
    // Try to re-select the user's last value, if it's still valid
    if (currentValue && select.querySelector(`option[value="${currentValue}"]`) && !select.querySelector(`option[value="${currentValue}"]`).disabled) {
        select.value = currentValue;
    } else if (riskCount >= 5) {
        select.value = "5"; // Default to Top 5
    } else {
        select.value = "all"; // Default to 'all' if less than 5 risks
    }
}
        
        function updateCategoryColor(element, category) {
            if (!element) return;
            const colorClasses = ["text-red-700", "text-orange-600", "text-amber-600", "text-green-700", "text-slate-700"];
            element.classList.remove(...colorClasses);
            element.classList.add(getRiskCategoryColor(category));
        }
        function updateAllCategoryColors() {
             document.querySelectorAll('#risk-generator-app .cat').forEach(el => {
                 updateCategoryColor(el, el.textContent);
             });
        }
        function initializeDashboard() {
            updateDashboardMetrics();
        }
        function updateDashboardMetrics() {
            // const tableData = extractTableData(); // Original data from AI
            // if (!tableData || tableData.rows.length === 0) return;
            const scores = [];
            const riskCategories = {};
            const hazardGroups = {};
            const currentTableRows = document.querySelectorAll('#risk-generator-app table tbody tr'); // Use current DOM state
            if (currentTableRows.length === 0) {
                 document.getElementById('avgScore').textContent = 'N/A';
                 document.getElementById('highestCard').innerHTML = 'N/A';
                 document.getElementById('lastReviewed').textContent = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
                 loadCharts({}, {}); // Clear charts
                 return;
             }
            let maxScore = -Infinity;
            let maxRowDetails = { score: 'N/A', category: 'N/A', steps: 'N/A'};
            currentTableRows.forEach((tr, index) => {
                const scoreElement = tr.querySelector('.score');
                const categoryElement = tr.querySelector('.cat');
                const groupSelectElement = tr.querySelector('td.group select');
                const stepsElement = tr.querySelector('td:first-child');
                if (scoreElement) {
                    const score = parseFloat(scoreElement.textContent);
                    if (!isNaN(score)) {
                        scores.push(score);
                        if (score > maxScore) {
                            maxScore = score;
                            maxRowDetails.score = score.toFixed(2);
                            maxRowDetails.category = categoryElement ? categoryElement.textContent.trim() : 'N/A';
                            maxRowDetails.steps = stepsElement ? stepsElement.textContent.trim() : 'N/A';
                        }
                    }
                }
                if (categoryElement) {
                    const category = categoryElement.textContent.trim();
                    if (category) riskCategories[category] = (riskCategories[category] || 0) + 1;
                }
                if (groupSelectElement) {
                    const groupValue = groupSelectElement.value;
                    if (groupValue) hazardGroups[groupValue] = (hazardGroups[groupValue] || 0) + 1;
                }
            });
            if (scores.length > 0) {
                document.getElementById('avgScore').textContent = (scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(2);
                if (maxScore > -Infinity) {
                     document.getElementById('highestCard').innerHTML = DOMPurify.sanitize(`<strong class="text-xl ${getRiskCategoryColor(maxRowDetails.category)}">${maxRowDetails.score} - ${maxRowDetails.category}</strong><br><small class="text-slate-600">${maxRowDetails.steps}</small>`);
                 } else {
                     document.getElementById('highestCard').innerHTML = 'N/A';
                 }
            } else {
                document.getElementById('avgScore').textContent = 'N/A';
                document.getElementById('highestCard').innerHTML = 'N/A';
            }
            document.getElementById('lastReviewed').textContent = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            loadCharts(riskCategories, hazardGroups);
        }
       window.generateRecommendations = async function() {
    const recBtn = document.querySelector('button[onclick="generateRecommendations()"]');    
    const recommendationsDiv = document.getElementById('recommendations');
    //recommendationsDiv.innerHTML = `<p class="text-slate-500 italic">ü§ñ Analyzing risks...</p>`;
    if (recBtn) { recBtn.disabled = true; recBtn.innerHTML = `${spinnerSVG} Analyzing...`; }
    
    try {
        const tableData = extractTableData();
        
        const getRiskInfo = (row) => {
            const score = parseFloat(row['Risk Score']);
            const category = (row['Risk Category'] || '').toUpperCase();
            // We need the data-row-index here
            return { row, score, category, isValid: !isNaN(score) };
        };

        const allRisks = tableData.rows.map(getRiskInfo).filter(r => r.isValid);

        // Filter for High/Medium/Critical
        let topRisksData = allRisks.filter(r => ['CRITICAL', 'HIGH', 'MEDIUM'].includes(r.category));
        
        // --- NEW: Call dropdown updater ---
        updateRecDropdown(topRisksData.length);
        // --- END NEW ---

        // 3. Sort the final list
        const sortedRisksData = topRisksData.sort((a, b) => b.score - a.score);

        // --- NEW: Read dropdown and determine which risks to process ---
        const riskCountSelect = document.getElementById('recCountSelect');
        const riskCount = riskCountSelect.value;
        
        if (riskCount === "0") {
            recommendationsDiv.innerHTML = `<p class="text-slate-500 italic">No 'Critical', 'High', or 'Medium' risk tasks found to generate recommendations for.</p>`;
            
            if (recBtn) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† recBtn.disabled = false;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† recBtn.innerHTML = 'Generate AI Recommendations & Visuals';
¬† ¬† ¬† ¬† ¬† ¬† }
            return;
        }

        let risksToProcessData; // This is the full list of risks that *should* have recs
        if (riskCount === 'all') {
            risksToProcessData = sortedRisksData;
        } else {
            const count = parseInt(riskCount, 10);
            risksToProcessData = sortedRisksData.slice(0, count);
        }
        
        // --- NEW: Filter this list down to only ones that need processing ---
        const headers = Array.from(document.querySelectorAll('#table-container thead th')).map(th => th.textContent.trim());
        const recColIndex = headers.indexOf("Recommendation");
        
        let risksToSendToAI; // This is the list we send to the AI
        
        if (recColIndex === -1) {
            // Recommendations haven't been run before, so process all
            risksToSendToAI = risksToProcessData;
        } else {
            // Filter out risks that *already have* a recommendation
            risksToSendToAI = risksToProcessData.filter(riskInfo => {
                const rowIndex = riskInfo.row['data-row-index'];
                if (rowIndex === undefined) return true; // Failsafe
                
                const row = document.querySelector(`#table-container tr[data-row-index="${rowIndex}"]`);
                if (!row || !row.cells[recColIndex]) return true; // Failsafe
                
                // Only process if the recommendation cell is empty
                return row.cells[recColIndex].textContent.trim() === '';
            });
        }
        
        if (risksToSendToAI.length === 0) {
            recommendationsDiv.innerHTML = `<p class="text-slate-500 italic">All selected risks (${riskCountSelect.options[riskCountSelect.selectedIndex].text}) already have recommendations.</p>`;
            // Still apply highlights to the target risks
            applyVisualsAndRecommendationsToTable([], risksToProcessData); 
            return;
        }
        // --- END NEW LOGIC ---

        // 5. --- BATCHING LOGIC (Process 'risksToSendToAI') ---
        // Batch size of 2 for more detailed AI analysis (smaller batches = deeper focus per group)
        const BATCH_SIZE = 2; 
        const allBatches = chunkArray(risksToSendToAI.map(r => r.row), BATCH_SIZE); // Map back to row data
        let allRecommendations = [];
        let failedBatches = [];
        let modelNote = '';

    console.debug(`Processing ${risksToSendToAI.length} new risks in ${allBatches.length} batches.`);

        for (let i = 0; i < allBatches.length; i++) {
            const batch = allBatches[i];
            const batchNumber = i + 1;
            recommendationsDiv.innerHTML = `<p class="text-slate-500 italic">ü§ñ Generating recommendations... (Batch ${batchNumber} of ${allBatches.length})</p>`;

            const prompt = `
                Analyze these high-risk tasks. For each, provide a concise, actionable recommendation.
                Then, estimate the new Frequency, Severity, and Likelihood values if the recommendation is implemented.
                Format your response ONLY as a JSON array of objects. Each object must have these exact keys:
                "step": "exact step name from input",
                "hazard": "exact hazard from input",
                "recommendation": "Your full recommendation text",
                "newFrequency": new_frequency_number,
                "newSeverity": new_severity_number,
                "newLikelihood": new_likelihood_number
                
                Tasks: ${JSON.stringify(batch.map(r => ({step: r.Steps, hazard: r['Hazard List'], Frequency: r.Frequency, Severity: r.Severity, Likelihood: r.Likelihood})), null, 2)}
            `;

            try {
                const paidResponse = await callAPI(PAID_MODEL, prompt);
                const parsedBatchRecs = parseAndCleanData(paidResponse);
                allRecommendations.push(...parsedBatchRecs); 
                modelNote = `(Generated using ${PAID_MODEL})`;
            } catch (error) {
                console.error(`Error processing batch ${batchNumber}:`, error);
                failedBatches.push(batchNumber);
                
            }
            if (recBtn) { recBtn.disabled = false; recBtn.innerHTML = 'Generate AI Recommendations & Visuals'; }
        }
        // --- END BATCHING LOGIC ---

        if (allRecommendations.length === 0 && failedBatches.length > 0) {
            recommendationsDiv.innerHTML = `<p class="text-red-600 font-medium">Error: AI failed to return any recommendations for ${allBatches.length} batches.</p>`;
            return;
        }

        allRecommendations.forEach(rec => {
            rec.newRiskScore = (rec.newFrequency || 1) * (rec.newSeverity || 1) * (rec.newLikelihood || 1);
        });
        
        // Find the original full task data for the summary table
        const originalTasksForSummary = risksToSendToAI.map(r => r.row);
        let summaryHtml = formatRecommendationsAsTable(allRecommendations, originalTasksForSummary) + `<p class="text-sm text-slate-500 italic mt-4">${modelNote}</p>`;
        
        if (failedBatches.length > 0) {
            summaryHtml += `<p class="text-red-600 font-medium mt-2">Warning: AI failed to process batch(es): ${failedBatches.join(', ')}. Some recommendations may be missing.</p>`;
        }
        
        recommendationsDiv.innerHTML = summaryHtml;
        
        // --- MODIFIED: Pass the full list of risks that should be highlighted ---
        applyVisualsAndRecommendationsToTable(allRecommendations, risksToProcessData);

    } catch (error) {
        recommendationsDiv.innerHTML = `<p class="text-red-600 font-medium">Error: ${error.message}.</p>`;
    }
}
        // --- MAJOR REWRITE: This function now adds new columns ---
        // --- CORRECTED LOGIC: Applies recommendations to ALL matching rows ---
        // --- CORRECTED LOGIC V2: Removed 'break' to apply to ALL matching rows ---
// --- CORRECTED LOGIC V3: Properly matches step AND hazard ---
        function applyVisualsAndRecommendationsToTable(recommendations, targetRisks) { // <-- MODIFIED ARGS
    const table = document.querySelector('#table-container table');
    if (!table) return;

    // Get column indices, including the crucial 'Hazard List'
    let headers = Array.from(table.querySelector('thead tr').children).map(th => th.textContent.trim());
    const colIndices = {
        steps: headers.indexOf('Steps'),
        hazard: headers.indexOf('Hazard List')
    };

    if (colIndices.steps === -1 || colIndices.hazard === -1) {
        console.error("Critical Error: Could not find 'Steps' or 'Hazard List' column.");
        return;
    }
    
    const thClasses = "p-3 text-left font-semibold text-slate-700 uppercase tracking-wider";
    const tdClasses = "p-3 border-b border-slate-200 text-slate-700 align-top";

    // Define new headers
    const newHeaders = [
        "Recommendation", 
        "Residual Frequency", 
        "Residual Severity", 
        "Residual Likelihood", 
        "Residual Risk Score", 
        "Residual Risk Category"
    ];

    // --- Add new headers if they don't exist (this logic is unchanged) ---
    if (!headers.includes("Recommendation")) {
        newHeaders.forEach(headerText => {
            table.querySelector('thead tr').insertAdjacentHTML('beforeend', `<th class="${thClasses}">${headerText}</th>`);
        });
        table.querySelectorAll('tbody tr').forEach(row => {
            newHeaders.forEach(() => {
                row.insertAdjacentHTML('beforeend', `<td class="${tdClasses}"></td>`);
            });
        });
        // Re-read headers *after* adding new ones
        headers = Array.from(table.querySelector('thead tr').children).map(th => th.textContent.trim());
    }

    // Find new column indices
    const recColIndex = headers.indexOf("Recommendation");
    const resFreqColIndex = headers.indexOf("Residual Frequency");
    const resSevColIndex = headers.indexOf("Residual Severity");
    const resLikeColIndex = headers.indexOf("Residual Likelihood");
    const resScoreColIndex = headers.indexOf("Residual Risk Score");
    const resCatColIndex = headers.indexOf("Residual Risk Category");
    
    // --- MODIFIED: Clear only highlights, not data ---
    const allRows = Array.from(table.querySelectorAll('tbody tr'));
    allRows.forEach(row => {
        row.classList.remove('bg-amber-50');
    });
    // --- END MODIFICATION ---

    // --- NEW: Highlight all target rows based on the targetRisks list ---
    if (targetRisks && targetRisks.length > 0) {
        // We get the set of row indices that *should* be highlighted
        const targetRowIndices = new Set(targetRisks.map(r => r.row['data-row-index']));
        allRows.forEach(row => {
            if (targetRowIndices.has(row.dataset.rowIndex)) {
                row.classList.add('bg-amber-50');
            }
        });
    }
    // --- END NEW ---

    // --- CORRECTED LOOP: Match each *new* recommendation to its specific row ---
    // This loop now only runs for *newly* generated recommendations
    recommendations.forEach(rec => {
        let rowMatched = false; 

        for (const targetRow of allRows) { 
            const stepText = targetRow.cells[colIndices.steps]?.textContent.trim();
            const hazardCell = targetRow.cells[colIndices.hazard];
            const hazardValue = hazardCell?.querySelector('select')?.value; 

            if (hazardValue !== undefined && stepText === rec.step && hazardValue === rec.hazard) {
                // targetRow.classList.add('bg-amber-50'); // Highlight is now done above
                const rowIndex = targetRow.dataset.rowIndex;

                const newFreq = rec.newFrequency || 1;
                const newSev = rec.newSeverity || 1;
                const newLike = rec.newLikelihood || 1;
                const newScore = rec.newRiskScore !== undefined ? rec.newRiskScore : (newFreq * newSev * newLike);
                const newCategory = getRiskCategory(newScore);

                // Populate all the new cells for THIS specific row
                if (recColIndex > -1 && targetRow.cells[recColIndex]) {
                    targetRow.cells[recColIndex].textContent = rec.recommendation;
                }
                if (resFreqColIndex > -1 && targetRow.cells[resFreqColIndex]) {
                    targetRow.cells[resFreqColIndex].innerHTML = createDropdown(FREQUENCY_SCALE, newFreq, `recalculateResidualRow(${rowIndex})`);
                    targetRow.cells[resFreqColIndex].className = `${tdClasses} res-freq`; // Add class
                }
                if (resSevColIndex > -1 && targetRow.cells[resSevColIndex]) {
                    targetRow.cells[resSevColIndex].innerHTML = createDropdown(SEVERITY_SCALE, newSev, `recalculateResidualRow(${rowIndex})`);
                    targetRow.cells[resSevColIndex].className = `${tdClasses} res-sev`; // Add class
                }
                if (resLikeColIndex > -1 && targetRow.cells[resLikeColIndex]) {
                    targetRow.cells[resLikeColIndex].innerHTML = createDropdown(LIKELIHOOD_SCALE, newLike, `recalculateResidualRow(${rowIndex})`);
                    targetRow.cells[resLikeColIndex].className = `${tdClasses} res-like`; // Add class
                }
                if (resScoreColIndex > -1 && targetRow.cells[resScoreColIndex]) {
                    targetRow.cells[resScoreColIndex].textContent = newScore.toFixed(2);
                    targetRow.cells[resScoreColIndex].className = `${tdClasses} res-score font-bold`; // Add class
                }
                if (resCatColIndex > -1 && targetRow.cells[resCatColIndex]) {
                    const catCell = targetRow.cells[resCatColIndex];
                    catCell.textContent = newCategory;
                    catCell.className = `${tdClasses} res-cat font-semibold`; // Add class
                    updateCategoryColor(catCell, newCategory); // Apply color
                }
                
                rowMatched = true; 
                break; 
            }
        } // End inner loop through rows

        if (!rowMatched) {
            console.warn(`Could not find a row matching step: "${rec.step}" AND hazard: "${rec.hazard}" to apply recommendation.`);
        }
    }); // End outer loop through recommendations
}
        // --- END MAJOR REWRITE ---
        function getRiskColor(score) {
            if (score >= 72) return { main: '#dc2626', light: '#fee2e2' }; // red
            if (score >= 50) return { main: '#f97316', light: '#ffedd5' }; // orange
            if (score >= 20) return { main: '#eab308', light: '#fef9c3' }; // amber
            return { main: '#16a34a', light: '#dcfce7' }; // green
        }
        function generateVisualizationCard(originalFreq, originalSev, originalLike, newFreq, newSev, newLike, riskScore, newRiskScore) {
            if (isNaN(riskScore)) return '';
            
            const formatFactor = (label, originalVal, newVal) => {
                if (originalVal != newVal && newVal !== undefined) {
                    return `${label}: ${originalVal} ‚ûî <span class="font-bold text-indigo-700">${newVal}</span>`;
                }
                return `${label}: ${originalVal}`;
            };
            const freqHtml = formatFactor('F', originalFreq, newFreq);
            const sevHtml = formatFactor('S', originalSev, newSev);
            const likeHtml = formatFactor('L', originalLike, newLike);
            const originalColor = getRiskColor(riskScore);
            const newColor = getRiskColor(newRiskScore);
            const getBarStyle = (score, max, color) => `width: ${Math.min(100, (score / max * 100))}%; background-color: ${color};`;
            const maxBarScore = Math.max(riskScore, newRiskScore, 50); // Set a reasonable max for the bar
            
            return `<div class="text-xs p-2 bg-white rounded-md shadow-inner border border-slate-200 space-y-2">
                <div>
                    <span class="font-semibold text-slate-700">${freqHtml} | ${sevHtml} | ${likeHtml}</span>
                </div>
                <div>
                    <span class="font-semibold text-slate-700">Risk: ${riskScore.toFixed(2)} ‚ûî <span class="font-bold text-indigo-700">${newRiskScore.toFixed(2)}</span></span>
                    <div class="relative h-2.5 bg-slate-200 rounded-full overflow-hidden border border-slate-300 mt-1">
                        <div class="absolute top-0 left-0 h-full transition-all" style="${getBarStyle(riskScore, maxBarScore, originalColor.light)}"></div>
                        <div class="absolute top-0 left-0 h-full transition-all" style="${getBarStyle(newRiskScore, maxBarScore, newColor.main)}"></div>
                    </div>
                </div>
            </div>`;
        }
        function formatRecommendationsAsTable(recommendations, topRisks) {
            if (!recommendations || recommendations.length === 0) return '<p class="text-slate-500 italic">No recommendations available.</p>';
            let html = `<table class="w-full text-sm mt-4"><thead class="bg-slate-100"><tr><th class="p-3 text-left">Step</th><th class="p-3 text-left">Recommendation</th><th class="p-3 text-left">Score Change</th></tr></thead><tbody>`;

            recommendations.forEach(rec => {
                // Safely compute original score from topRisks if possible
                let originalScore = 0;
                try {
                    if (Array.isArray(topRisks) && topRisks.length > 0) {
                        const matches = topRisks.filter(t => (t.Steps || t.Steps === '') && rec.step && (t.Steps === rec.step || t.Steps === rec.step));
                        const vals = matches.map(t => parseFloat(t['Risk Score']) || 0);
                        if (vals.length > 0) originalScore = Math.max(...vals);
                    }
                } catch (e) { /* ignore and leave originalScore as 0 */ }

                const newScore = typeof rec.newRiskScore === 'number' ? rec.newRiskScore : (parseFloat(rec.newRiskScore) || 0);
                html += `<tr>
                    <td class="p-3 align-top">${DOMPurify.sanitize(rec.step || '')}</td>
                    <td class="p-3 align-top">${DOMPurify.sanitize(rec.recommendation || '')}</td>
                    <td class="p-3 align-top whitespace-nowrap">Score: ${originalScore.toFixed(2)} ‚ûî <strong class="text-indigo-700">${newScore.toFixed(2)}</strong></td>
                </tr>`;
            });

            return html + '</tbody></table>';
        }
        function parseAndCleanData(rawJson) {
            try {
                // More robust JSON parsing: Find first '[' and last ']'
                 const startIndex = rawJson.indexOf('[');
                 const endIndex = rawJson.lastIndexOf(']');
                 if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
                       throw new Error("Valid JSON array boundaries not found in the AI response.");
                 }
                 const jsonString = rawJson.substring(startIndex, endIndex + 1);
                const parsed = JSON.parse(jsonString);
                return Array.isArray(parsed) ? parsed : [];
            } catch (e) {
                console.error('Failed to parse AI response. Raw data:', rawJson, 'Error:', e);
                throw new Error("AI response was in an invalid format.");
            }
        }
        async function callAPI(model, prompt) {
            if (!API_KEY || API_KEY.includes('YOUR_API_KEY')) throw new Error('API Key is not configured. Please add your key to the script, or preferably, set up a secure server-side proxy.');
            const response = await fetch(API_URL, { method: 'POST', headers: { 'Authorization': `Bearer ${API_KEY}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ model, messages: [{ role: 'user', content: prompt }], max_tokens: 2048 }), });
            if (!response.ok) { const errorText = await response.text(); throw new Error(`API request for ${model} failed: ${errorText}`); }
            const data = await response.json();
            if (!data.choices || data.choices.length === 0 || !data.choices[0].message || !data.choices[0].message.content) {
                 throw new Error(`API response for ${model} was empty or invalid.`);
             }
            return data.choices[0].message.content;
        }
        function extractTableData() {
            // --- FIX: Selector now points to the correct table inside #table-container ---
            const table = document.querySelector('#table-container table'); 
            // --- END FIX ---
            
            if (!table) return { headers: [], rows: [] };
            
            const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
            const rows = [];
            
            table.querySelectorAll('tbody tr').forEach(tr => {
                const rowData = {};
                rowData['data-row-index'] = tr.dataset.rowIndex;
                rowData['imageId'] = tr.dataset.imageId || null;
                tr.querySelectorAll('td').forEach((td, index) => {
                    const header = headers[index];
                    if (header) {
                        const select = td.querySelector('select');
                        const input = td.querySelector('input');
                        if (select) {
                            rowData[header] = select.value;
                        } else if (input) {
                            rowData[header] = input.value;
                        } else if (header === 'Risk Score') { // Make sure score is read correctly
                            rowData[header] = td.textContent.trim();
                        } else if (header === 'Risk Category') { // Make sure category is read correctly
                            rowData[header] = td.textContent.trim();
                        } else if (header === 'Steps') { // Read steps correctly
                             rowData[header] = td.textContent.trim();
                         }
                        // Add more specific reads if needed for other text-based columns
                    }
                });
                 // Add Steps if it wasn't picked up by header logic (e.g., first column)
                 if (!rowData['Steps'] && tr.cells[0]) {
                     rowData['Steps'] = tr.cells[0].textContent.trim();
                 }
                rows.push(rowData);
            });
            return { headers, rows };
        }
        function loadCharts(riskData, hazardData) {
            // Clear previous errors/charts
             document.getElementById('chartError').style.display = 'none';
             document.getElementById('hazardChartError').style.display = 'none';
             document.getElementById('riskChart').innerHTML = ''; // Clear previous chart SVG
             document.getElementById('hazardChart').innerHTML = '';
            if (typeof google === 'undefined' || !google.charts) {
                console.error("Google Charts library not loaded.");
                 document.getElementById('chartError').textContent = 'Google Charts library failed to load.';
                 document.getElementById('hazardChartError').textContent = 'Google Charts library failed to load.';
                 document.getElementById('chartError').style.display = 'block';
                 document.getElementById('hazardChartError').style.display = 'block';
                return;
            }
            // Ensure charts library is loaded before drawing
            google.charts.load('current', {'packages':['corechart']});
            google.charts.setOnLoadCallback(() => {
                try {
                    // --- MODIFIED CHART OPTIONS ---
                    const chartOptions = {
                        pieHole: 0.4,
                        backgroundColor: 'transparent',
                        chartArea: {width: '90%', height: '80%'},
                        legend: {position: 'bottom', textStyle: { color: '#475569', fontSize: 12, fontName: 'Segoe UI' }},
                        titleTextStyle: { color: '#334155', fontSize: 16, fontName: 'Segoe UI', bold: true },
                        pieSliceTextStyle: { color: '#ffffff', fontName: 'Segoe UI', bold: true, fontSize: 13 }
                    };
                    // --- END OF MODIFICATION ---

                    if (Object.keys(riskData).length > 0) {
                         drawRiskChart(riskData, chartOptions);
                    } else {
                         document.getElementById('chartError').textContent = 'No risk category data available to display.';
                         document.getElementById('chartError').style.display = 'block';
                    }
                    if (Object.keys(hazardData).length > 0) {
                        drawHazardChart(hazardData, chartOptions);
                    } else {
                         document.getElementById('hazardChartError').textContent = 'No hazard group data available to display.';
                         document.getElementById('hazardChartError').style.display = 'block';
                    }
                } catch (e) {
                    console.error("Error drawing charts:", e);
                    document.getElementById('chartError').textContent = 'Error drawing risk chart.';
                    document.getElementById('hazardChartError').textContent = 'Error drawing hazard chart.';
                    document.getElementById('chartError').style.display = 'block';
                    document.getElementById('hazardChartError').style.display = 'block';
                }
            });
        }
        function drawRiskChart(data, options) {
            try {
                const chartData = new google.visualization.DataTable();
                chartData.addColumn('string', 'Risk Category');
                chartData.addColumn('number', 'Count');
                const categories = Object.keys(data).sort((a, b) => { // Sort low to critical
                     const order = { "LOW": 1, "MEDIUM": 2, "HIGH": 3, "CRITICAL": 4 };
                     return (order[a] || 5) - (order[b] || 5);
                 });
                const colorMap = { 'LOW': '#16a34a', 'MEDIUM': '#eab308', 'HIGH': '#f97316', 'CRITICAL': '#dc2626' };
                chartData.addRows(categories.map(cat => [cat, data[cat]]));
                const riskOptions = {
                    ...options,
                    title: 'Risk Category Distribution',
                    colors: categories.map(cat => colorMap[cat.toUpperCase()] || '#6c757d')
                };
                const chartElement = document.getElementById('riskChart');
                 if (!chartElement) throw new Error("riskChart element not found");
                 chartElement.innerHTML = ''; // Clear previous chart
                const chart = new google.visualization.PieChart(chartElement);
                chart.draw(chartData, riskOptions);
             } catch (e) {
                 console.error("Error in drawRiskChart:", e);
                 const errorEl = document.getElementById('chartError');
                 if(errorEl) {
                     errorEl.textContent = 'Error drawing risk chart: ' + e.message;
                     errorEl.style.display = 'block';
                 }
             }
        }
        function drawHazardChart(data, options) {
             try {
                const chartData = new google.visualization.DataTable();
                chartData.addColumn('string', 'Hazard Group');
                chartData.addColumn('number', 'Count');
                // Sort categories alphabetically for consistency
                const categories = Object.keys(data).sort();
                const displayLabels = categories.map(cat => cat.length > 25 ? cat.substring(0, 22) + '...' : cat); // Slightly longer labels allowed
                chartData.addRows(categories.map((cat, i) => [displayLabels[i], data[cat]]));
                const hazardOptions = {
                    ...options,
                    title: 'Hazard Group Distribution',
                    colors: generateColors(categories.length),
                };
                 const chartElement = document.getElementById('hazardChart');
                 if (!chartElement) throw new Error("hazardChart element not found");
                 chartElement.innerHTML = ''; // Clear previous chart
                const chart = new google.visualization.PieChart(chartElement);
                chart.draw(chartData, hazardOptions);
             } catch (e) {
                 console.error("Error in drawHazardChart:", e);
                 const errorEl = document.getElementById('hazardChartError');
                  if(errorEl) {
                     errorEl.textContent = 'Error drawing hazard chart: ' + e.message;
                     errorEl.style.display = 'block';
                 }
             }
        }
        function generateColors(count) {
            const baseColors = ['#4f46e5', '#0ea5e9', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#3b82f6', '#22c55e', '#eab308', '#ec4899'];
            const colors = []; for (let i = 0; i < count; i++) { colors.push(baseColors[i % baseColors.length]); } return colors;
        }
        // --- NEW: Functions for Table Image Modal ---
        window.openTableImageModal = function(imageUrl, rowIndex) {
            const modal = document.getElementById('tableImageModal');
            const enlargedImage = document.getElementById('modalEnlargedImage');
            const detailsContainer = document.getElementById('modalRiskDetails');

            if (!modal || !enlargedImage || !detailsContainer) {
                console.error("Modal elements not found!");
                showCustomAlert("Error: Could not open image preview.", 'error');
                return;
            }

            // Set the image source
            enlargedImage.src = imageUrl;
            enlargedImage.alt = `Enlarged image for row ${rowIndex + 1}`;

            // Get the corresponding table row
            const row = document.querySelector(`#table-container tr[data-row-index="${rowIndex}"]`);
            if (!row) {
                detailsContainer.innerHTML = '<p class="text-red-600">Error: Could not find table row data.</p>';
                modal.style.display = 'flex';
                return;
            }

            // Extract data from the row (using current values)
            const rowData = {};
            const headers = Array.from(document.querySelectorAll('#table-container thead th')).map(th => th.textContent.trim());
            row.querySelectorAll('td').forEach((td, index) => {
                 const header = headers[index];
                 if (header && header !== 'Picture') { // Skip Picture column
                    const select = td.querySelector('select');
                    const input = td.querySelector('input');
                    if (select) {
                        // Get full text for dropdowns
                        rowData[header] = select.options[select.selectedIndex] ? select.options[select.selectedIndex].text : select.value;
                    } else if (input) {
                        rowData[header] = input.value || 'N/A';
                    } else {
                         rowData[header] = td.textContent.trim() || 'N/A';
                    }
                 }
            });

            // Format details HTML
            let detailsHtml = '<dl class="divide-y divide-slate-200">';
            const importantHeaders = [
                "Steps", "Hazard Group", "Hazard List", "Risk/Consequences", 
                "Risk Score", "Risk Category", "Hazard Source", "Current Control", 
                "Recommendation", "Residual Risk Score", "Residual Risk Category"
            ]; // Prioritize these

            importantHeaders.forEach(header => {
                if (rowData[header] && rowData[header] !== 'N/A') { // Only show if data exists
                    detailsHtml += `<div class="py-2 flex justify-between">`;
                    detailsHtml += `<dt class="font-medium text-slate-600">${header}:</dt>`;
                    // Add color styling for categories
                    let valueClass = 'text-slate-800 text-right';
                    if (header === 'Risk Category' || header === 'Residual Risk Category') {
                       valueClass += ` ${getRiskCategoryColor(rowData[header])} font-semibold`;
                    } else if (header === 'Risk Score' || header === 'Residual Risk Score') {
                       valueClass += ` font-bold`;
                    }
                     detailsHtml += `<dd class="${valueClass}">${DOMPurify.sanitize(rowData[header])}</dd>`;
                     detailsHtml += `</div>`;
                }
            });
             detailsHtml += '</dl>';


            detailsContainer.innerHTML = detailsHtml;

            // Show the modal
            modal.style.display = 'flex';
        }

        function closeTableImageModal() {
            const modal = document.getElementById('tableImageModal');
            if (modal) {
                modal.style.display = 'none';
                // Clear content to prevent old data flashing
                document.getElementById('modalEnlargedImage').src = ""; 
                document.getElementById('modalRiskDetails').innerHTML = "<p>Loading details...</p>";
            }
        }

        // Add event listeners for closing the new modal
        document.addEventListener('DOMContentLoaded', () => {
             // Set language selector to saved value and apply translations
             const langSelect = document.getElementById('langSelect');
             if (langSelect) {
                 langSelect.value = currentLang;
                 updateUIText(); // Apply translations on page load
             }

             const closeBtn = document.getElementById('closeTableImageModal');
             const modal = document.getElementById('tableImageModal');
             if (closeBtn) {
                 closeBtn.onclick = closeTableImageModal;
             }
             // Close if clicking outside the modal content
             if (modal) {
                 modal.addEventListener('click', (event) => {
                     if (event.target === modal) { // Check if the click was directly on the overlay
                         closeTableImageModal();
                     }
                 });
             }

             // --- LANGUAGE SELECTOR LISTENER ---
             const langSelect2 = document.getElementById('langSelect');
             if (langSelect2) {
                 langSelect2.addEventListener('change', (e) => {
                     currentLang = e.target.value;
                     localStorage.setItem('appLanguage', currentLang); // Save to localStorage
                     console.log(`Language changed to: ${currentLang}`);
                     updateUIText(); // Update all UI text
                     // Refresh all table dropdowns when language changes
                     const tableContainer = document.getElementById('table-container');
                     if (tableContainer) {
                         // Re-render all dropdowns by replacing their HTML
                         const allSelects = tableContainer.querySelectorAll('select');
                         allSelects.forEach(select => {
                             const parent = select.parentElement;
                             const onChange = select.getAttribute('onchange');
                             const currentValue = select.value;
                             const headerCells = tableContainer.querySelector('table thead tr').children;
                             const cellIndex = Array.from(select.closest('tr').children).indexOf(parent);
                             const headerText = cellIndex < headerCells.length ? headerCells[cellIndex].textContent.trim() : '';
                             
                             // Determine dropdown type and rebuild
                             if (parent.className.includes('group')) {
                                 // Hazard Group dropdown
                                 parent.innerHTML = window.createHazardGroupDropdown(currentValue);
                             } else if (headerText === 'Frequency') {
                                 parent.innerHTML = window.createDropdown(FREQUENCY_SCALE, currentValue, onChange);
                             } else if (headerText === 'Severity') {
                                 parent.innerHTML = window.createDropdown(SEVERITY_SCALE, currentValue, onChange);
                             } else if (headerText === 'Likelihood') {
                                 parent.innerHTML = window.createDropdown(LIKELIHOOD_SCALE, currentValue, onChange);
                             } else if (headerText === 'Hazard List') {
                                 // Hazard list dropdown - rebuild with translations
                                 parent.innerHTML = window.createTextDropdown(Object.keys(HAZARD_REGISTRY), currentValue, onChange);
                             } else if (headerText === 'Risk/Consequences') {
                                 // Risk/Consequences dropdown - rebuild with translations
                                 parent.innerHTML = window.createTextDropdown(CONSEQUENCE_REGISTRY, currentValue, onChange);
                             }
                         });
                         // Update risk category colors with current language
                         updateAllCategoryColors();
                     }
                     // Toggle "How to Use This App" sections based on language
                     const howToUseEn = document.getElementById('howToUse-en');
                     const howToUseFr = document.getElementById('howToUse-fr');
                     const howToUseDe = document.getElementById('howToUse-de');
                     if (howToUseEn && howToUseFr && howToUseDe) {
                         howToUseEn.style.display = currentLang === 'en' ? 'block' : 'none';
                         howToUseFr.style.display = currentLang === 'fr' ? 'block' : 'none';
                         howToUseDe.style.display = currentLang === 'de' ? 'block' : 'none';
                     }
                 });
             }
             // --- END LANGUAGE SELECTOR LISTENER ---
        });
        // --- END NEW Modal Functions ---
        // --- DELETE your entire window.convertToCSV function ---

/**
¬†* Reusable helper to generate the Risk Assessment Table CSV content.
 * @param {Map<string, string>} [imageNameMap=new Map()] A map of imageId -> sanitizedFileName.
¬†* @returns {string} The CSV content as a string.
¬†*/
function generateRiskTableCSV(imageNameMap = new Map()) {
    const table = document.querySelector('#table-container table');
    if (!table) {
        console.error("CSV Export Error: Could not find the risk assessment table.");
        throw new Error("Could not find the table data to export.");
    }
    // Build a merged image name map (originalFileNames + provided imageNameMap)
    try {
        const merged = new Map();
        const galleryImgs = Array.from(document.querySelectorAll('.gallery-item img'));
        if (window.originalFileNames) {
            window.originalFileNames.forEach((orig, id) => {
                const idx = Math.max(0, galleryImgs.findIndex(img => img.id === id));
                merged.set(id, createFinalFileName(orig, idx));
            });
        }
        if (imageNameMap && imageNameMap.size > 0) {
            imageNameMap.forEach((fname, id) => merged.set(id, fname));
        }
        imageNameMap = merged;
        console.log('imageNameMap for CSV:', Array.from(imageNameMap)); // Log the full map
    } catch (e) {
        console.warn('Error while building imageNameMap for CSV export:', e);
    }
    const headerCells = Array.from(table.querySelector('thead tr').querySelectorAll('th'));
    const headers = headerCells.map(th => th.innerText.trim());
    console.log('Table headers:', headers); // Log headers to check case
    const csv = [];
    csv.push(headers.map(h => `"${h.replace(/"/g, '""')}"`).join(','));
    const galleryImages = Array.from(document.querySelectorAll('.gallery-item img'));
    table.querySelectorAll('tbody tr').forEach(row => {
        // Skip rows the user has marked deleted (struck-through)
        if (row.classList.contains('deleted-row') || row.dataset.deleted === 'true') {
            console.debug(`Skipping deleted row ${row.dataset.rowIndex}`);
            return; // skip this row in CSV
        }
        const cells = row.querySelectorAll('td');
        const parts = [];
        headers.forEach((header, colIndex) => {
            const cell = cells[colIndex];
            if (!cell) { parts.push('""'); return; }
            if (header.toLowerCase() === 'picture') { // Case-insensitive
                console.log(`Processing Picture for row ${row.dataset.rowIndex}: imageId=${row.dataset.imageId}`);
                const imageId = row.dataset.imageId || '';
                let filename = '';
                // 1) direct mapping from merged map
                if (imageId && imageNameMap && imageNameMap.has(imageId)) {
                    filename = imageNameMap.get(imageId);
                    console.log(`  Fallback 1 (map): ${filename}`);
                }
                // 2) originalFileNames fallback
                if (!filename && window.originalFileNames && window.originalFileNames.has(imageId)) {
                    const orig = window.originalFileNames.get(imageId);
                    const idx = Math.max(0, galleryImages.findIndex(img => img.id === imageId));
                    filename = createFinalFileName(orig, idx);
                    console.log(`  Fallback 2 (originalFileNames): ${filename}`);
                }
                // 3) picture cell dataset (set when table was populated)
                if (!filename) {
                    const pictureCell = row.querySelector('.picture-cell');
                    if (pictureCell && pictureCell.dataset && pictureCell.dataset.filename) {
                        const orig = pictureCell.dataset.filename;
                        const idx = parseInt(row.dataset.rowIndex, 10) || 0;
                        filename = createFinalFileName(orig, idx);
                        console.log(`  Fallback 3 (cell dataset): ${filename}`);
                    }
                }
                // 4) try to match by thumbnail src
                if (!filename) {
                    const pictureCell = row.querySelector('.picture-cell');
                    const imgTag = pictureCell ? pictureCell.querySelector('img') : null;
                    if (imgTag && imgTag.src) {
                        const match = galleryImages.find(g => g.src === imgTag.src || g.src === imgTag.getAttribute('data-src'));
                        if (match) {
                            const matchedId = match.id;
                            filename = (imageNameMap && imageNameMap.get(matchedId)) || (window.originalFileNames && window.originalFileNames.get(matchedId)) || matchedId;
                            if (window.originalFileNames && window.originalFileNames.get(matchedId)) {
                                filename = createFinalFileName(window.originalFileNames.get(matchedId), Math.max(0, galleryImages.indexOf(match)));
                            }
                            console.log(`  Fallback 4 (thumbnail src): ${filename}`);
                        }
                    }
                }
                // 5) final fallback: synthesize from first gallery image or imageId
                if (!filename) {
                    if (galleryImages.length > 0) {
                        const g0 = galleryImages[0];
                        const orig = (window.originalFileNames && window.originalFileNames.get(g0.id)) || g0.id || imageId || '';
                        filename = orig ? createFinalFileName(orig, 0) : '';
                        console.log(`  Fallback 5 (synthesize from first image): ${filename}`);
                    }
                }
                // 6) ultimate fallback: use row index + cellFilename if available
                if (!filename) {
                    const pictureCell = row.querySelector('.picture-cell');
                    const orig = pictureCell?.dataset.filename || `row_${row.dataset.rowIndex}`;
                    const idx = parseInt(row.dataset.rowIndex, 10) || 0;
                    filename = createFinalFileName(orig, idx);
                    console.log(`  Fallback 6 (row index + cellFilename): ${filename}`);
                }
                parts.push(`"${(filename || '').replace(/"/g, '""')}"`);
                return;
            }
            // Generic cell types: select, input, textarea, or plain text
            let value = '';
            const sel = cell.querySelector('select');
            const inp = cell.querySelector('input');
            const ta = cell.querySelector('textarea');
            if (sel) value = sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].text : sel.value;
            else if (inp) value = inp.value;
            else if (ta) value = ta.value;
            else value = cell.innerText.trim();
            parts.push(`"${(value || '').replace(/\r?\n|\r/g, ' ').replace(/"/g, '""')}"`);
        });
        csv.push(parts.join(','));
    });
    if (csv.length <= 1) throw new Error('No data available in the table to export.');
    return csv.join('\n');
}

// New function to generate the arranged CSV
function generateArrangedRiskCSV(imageNameMap = new Map()) {
    const { headers, rows } = extractTableData();
    if (rows.length === 0) {
        return "No risk table data available.";
    }
    
    // Translate headers based on current language
    const headerTranslations = {
        "Sequence": "Sequence",
        "Task Steps": "Task Steps",
        "Hazard Group": "Hazard Group",
        "Hazard List": "Hazard List",
        "Risk/Consequences": "Risk/Consequences",
        "Picture Name": "Picture Name",
        "Hazard Source": "Hazard Source",
        "Current Controls": "Current Controls",
        "Routine": "Routine",
        "Frequency": "Frequency",
        "Severity": "Severity",
        "Likelihood": "Likelihood",
        "Risk Score": "Risk Score"
    };
    
    // Apply translations if needed
    const translatedHeaders = ["Sequence", "Task Steps", "Hazard Group", "Hazard List", "Risk/Consequences", "Picture Name", "Hazard Source", "Current Controls", "Routine", "Frequency", "Severity", "Likelihood", "Risk Score"].map(h => t(h));
    const csv = [translatedHeaders.map(h => `"${h.replace(/"/g, '""')}"`).join(',')];
    
    // Get deleted row indices to skip them
    const deletedRowIndices = new Set();
    try {
        const deletedRows = document.querySelectorAll('#table-container tbody tr.deleted-row, #table-container tbody tr[data-deleted="true"]');
        deletedRows.forEach(row => {
            const idx = row.dataset.rowIndex;
            if (idx !== undefined) deletedRowIndices.add(parseInt(idx, 10));
        });
    } catch (e) {
        console.warn('Could not determine deleted rows for arranged CSV:', e);
    }
    
    // Group rows by 'Steps' while preserving order
    let currentStep = null;
    let stepNum = 0;
    let subNum = 0;
    
    rows.forEach((row, originalRowIndex) => {
        // Skip deleted rows
        if (deletedRowIndices.has(originalRowIndex)) {
            console.debug(`Skipping deleted row ${originalRowIndex} from arranged CSV`);
            return;
        }

        const thisStep = row.Steps || '';
        if (thisStep !== currentStep) {
            stepNum++;
            subNum = 0;
            currentStep = thisStep;
        }
        subNum += 10; // Increment by 10 for sub-numbers like .10, .20
        const sequence = `${stepNum}.${subNum.toString().padStart(2, '0')}`;
        
        const imageId = row.imageId || '';
        let pictureName = '';
        if (imageId && imageNameMap.has(imageId)) {
            pictureName = imageNameMap.get(imageId);
        } else if (imageId && window.originalFileNames.has(imageId)) {
            // Fallback to original name if map misses it
            const orig = window.originalFileNames.get(imageId);
            const idx = rows.indexOf(row); // Approximate index
            pictureName = createFinalFileName(orig, idx);
        }
        
        // Translate dropdown values
        const frequency = row.Frequency ? t(row.Frequency.split(' - ')[1] || row.Frequency) : '';
        const severity = row.Severity ? t(row.Severity.split(' - ')[1] || row.Severity) : '';
        const likelihood = row.Likelihood ? t(row.Likelihood.split(' - ')[1] || row.Likelihood) : '';
        const hazardGroup = row["Hazard Group"] ? t(row["Hazard Group"]) : '';
        const hazardList = row["Hazard List"] ? t(row["Hazard List"]) : '';
        const consequence = row["Risk/Consequences"] ? t(row["Risk/Consequences"]) : '';
        
        const parts = [
            sequence,
            row.Steps || '',
            hazardGroup,
            hazardList,
            consequence,
            pictureName || '',
            row["Hazard Source"] || '',
            row["Current Control"] || '', // Assuming this is the field; adjust if named differently
            row["Routine/Non-Routine/Emergency Situation"] || '',
            frequency,
            severity,
            likelihood,
            row["Risk Score"] || ''
        ].map(v => `"${(v + '').replace(/"/g, '""')}"`).join(',');
        
        csv.push(parts);
    });
    
    return csv.join('\n');
}

/**
 * Generates CSV content from the global window.riskAssessmentData.
 * @returns {string} The CSV content as a string.
 */
/**
¬†* Generates CSV content from the provided imageDataArray.
¬†* @param {Array} imageDataArray - The array of image data objects.
¬†* @returns {string} The CSV content as a string.
¬†*/
function createImageNotesCSV(imageDataArray) {
¬† ¬† // Check if the passed array is empty or invalid
¬† ¬† if (!imageDataArray || imageDataArray.length === 0) {
¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† // --- FALLBACK ---
¬† ¬† ¬† ¬† // If the array is empty, try reading from the global state one last time.
¬† ¬† ¬† ¬† if (!window.riskAssessmentData || window.riskAssessmentData.size === 0) {
¬† ¬† ¬† ¬† ¬† ¬† return "No image notes found."; // Truly no notes
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† // If global state has data, build CSV from that
¬† ¬† ¬† ¬† let csv_fallback = [];
¬† ¬† ¬† ¬† csv_fallback.push('"ImageID","OriginalFileName","Description","Hazards","Controls"');
¬† ¬† ¬† ¬† window.riskAssessmentData.forEach((data, imgId) => {
¬† ¬† ¬† ¬† ¬† ¬† const fileName = window.originalFileNames.get(imgId) || 'N/A';
¬† ¬† ¬† ¬† ¬† ¬† const sanitize = (text) => `"${(text || '').replace(/"/g, '""').replace(/\r?\n|\r/g, " ")}"`;
¬† ¬† ¬† ¬† ¬† ¬† let row = [];
¬† ¬† ¬† ¬† ¬† ¬† row.push(`"${imgId}"`);
¬† ¬† ¬† ¬† ¬† ¬† row.push(`"${fileName.replace(/"/g, '""')}"`);
¬† ¬† ¬† ¬† ¬† ¬† row.push(sanitize(data.description));
¬† ¬† ¬† ¬† ¬† ¬† row.push(sanitize(data.hazards));
¬† ¬† ¬† ¬† ¬† ¬† row.push(sanitize(data.controls));
¬† ¬† ¬† ¬† ¬† ¬† csv_fallback.push(row.join(','));
¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† return csv_fallback.join('\n');
¬† ¬† ¬† ¬† // --- END FALLBACK ---
¬† ¬† }

¬† ¬† // --- Primary Logic (using the passed array) ---
¬† ¬† let csv = [];
¬† ¬† csv.push('"DownloadFileName","Description","Hazards","Controls"'); // <<< CHANGED
¬† ¬†¬†
¬† ¬† imageDataArray.forEach((item) => {
¬† ¬† ¬† ¬† const data = item.riskData;
¬† ¬† ¬† ¬† const fileName = item.fileName || 'N/A'; // <<< CHANGED
¬† ¬† ¬† ¬† const sanitize = (text) => `"${(text || '').replace(/"/g, '""').replace(/\r?\n|\r/g, " ")}"`;
¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† let row = [];
¬† ¬† ¬† ¬† row.push(`"${fileName.replace(/"/g, '""')}"`);
¬† ¬† ¬† ¬† row.push(sanitize(data.description));
¬† ¬† ¬† ¬† row.push(sanitize(data.hazards));
¬† ¬† ¬† ¬† row.push(sanitize(data.controls));
¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† csv.push(row.join(','));
¬† ¬† });

¬† ¬† return csv.join('\n');
}


/**
¬†* Main function to generate and download the complete project ZIP.
¬†*/
/**
 * Main function to generate and download the complete project ZIP.
 */
async function downloadProjectZip() {
    const btn = document.getElementById('downloadProjectZipBtn');
    if (!btn) return;
    
    if (typeof JSZip === 'undefined' || typeof window.addImagesToZip === 'undefined') {
        showCustomAlert("Error: Critical download libraries (JSZip, addImagesToZip) are not available.", 'error');
        return;
    }

    btn.disabled = true;
    btn.textContent = 'Zipping...';
    
    try {
        const zip = new JSZip();

        // 1. Get image data, promises, AND the new imageNameMap
        const { imageDataArray, fetchPromises, imageNameMap } = await window.addImagesToZip(zip);
        
        // 2. WAIT for all images to be fetched AND for imageDataArray to be populated
        await Promise.all(fetchPromises);

        // 3. Pass the populated imageDataArray to the image_notes.csv function
        const imageNotesCSV = createImageNotesCSV(imageDataArray); 
        // FIX: Prepend \uFEFF so Excel recognizes it as UTF-8
        zip.file("image_notes.csv", "\uFEFF" + imageNotesCSV);
        
        // 4. Add the Arranged Risk Table CSV (passing the new map, excludes deleted rows)
        try {
            zip.file("arranged_risk_table.csv", "\uFEFF" + generateArrangedRiskCSV(imageNameMap)); 
        } catch (e) {
            zip.file("arranged_risk_table.csv", `Error: ${e.message}`);
        }

        // 5. Generate and Download
        const content = await zip.generateAsync({ type: "blob" });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = "Complete_Risk_Project.zip";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => URL.revokeObjectURL(link.href), 1000);

    } catch (error) {
        console.error("Error generating project ZIP:", error);
        showCustomAlert(`An error occurred: ${error.message}`);
    } finally {
        btn.disabled = false;
        btn.textContent = 'Download Project ZIP';
    }
}

// Attach the listener for the new button
document.addEventListener('DOMContentLoaded', () => {
    const projectZipBtn = document.getElementById('downloadProjectZipBtn');
    if (projectZipBtn) {
        projectZipBtn.addEventListener('click', downloadProjectZip);
    }
});

// --- NEW: Toggle delete / restore on table rows ---
window.toggleRowDelete = function(rowIndex, btn) {
    const row = document.querySelector(`#table-container tr[data-row-index="${rowIndex}"]`);
    if (!row) return;
    const isDeleted = row.classList.toggle('deleted-row');
    row.dataset.deleted = isDeleted ? 'true' : 'false';

    // Update button UI
    try {
        if (isDeleted) {
            btn.textContent = 'Restore';
            btn.className = 'restore-btn';
            btn.title = 'Restore row';
        } else {
            btn.textContent = 'üóë';
            btn.className = 'delete-btn';
            btn.title = 'Delete row';
        }
    } catch (e) { /* ignore UI update issues */ }

    // Disable/enable interactive elements in the row except the delete/restore button
    try {
        const controls = Array.from(row.querySelectorAll('select, input, textarea, button'));
        controls.forEach(control => {
            // Skip the delete/restore button itself
            if (control === btn) return;
            if (isDeleted) {
                control.setAttribute('disabled', 'true');
                control.style.opacity = '0.6';
                control.style.pointerEvents = 'none';
            } else {
                control.removeAttribute('disabled');
                control.style.opacity = '';
                control.style.pointerEvents = '';
            }
        });
    } catch (e) {
        console.warn('Error updating row controls for delete toggle:', e);
    }
}

// --- Translation Storage to track original values ---
window.translationHistory = {};

// --- Translation Function ---
window.translateTableColumns = async function() {
    const targetLang = document.getElementById('translationLangSelect')?.value || 'en';
    const translateSteps = document.getElementById('translateSteps')?.checked;
    const translateHazardSource = document.getElementById('translateHazardSource')?.checked;
    const translateCurrentControl = document.getElementById('translateCurrentControl')?.checked;
    
    console.log(`[Translation] Starting translation: lang=${targetLang}, steps=${translateSteps}, source=${translateHazardSource}, control=${translateCurrentControl}`);
    
    if (targetLang === 'en') {
        alert('Please select a language other than English for translation.');
        return;
    }
    
    if (!translateSteps && !translateHazardSource && !translateCurrentControl) {
        alert('Please select at least one column to translate.');
        return;
    }
    
    const translationStatus = document.getElementById('translationStatus');
    const translateConfirmBtn = document.getElementById('translateConfirmBtn');
    translationStatus.classList.remove('hidden');
    translationStatus.textContent = 'Translating...';
    translateConfirmBtn.disabled = true;
    
    try {
        const rows = document.querySelectorAll('#table-container tbody tr');
        console.log(`[Translation] Found ${rows.length} rows to process`);
        let translatedCount = 0;
        let cellsUpdated = 0;
        
        for (const row of rows) {
            // Skip deleted rows
            if (row.classList.contains('deleted-row')) {
                console.log('[Translation] Skipping deleted row');
                continue;
            }
            
            const cells = row.querySelectorAll('td');
            const rowIndex = row.getAttribute('data-row-index');
            console.log(`[Translation] Row ${rowIndex} has ${cells.length} cells`);
            
            // Find column headers to dynamically locate columns
            const headerRow = document.querySelector('#table-container thead tr');
            const headers = Array.from(headerRow?.querySelectorAll('th') || []).map(th => th.textContent.trim());
            console.log(`[Translation] Headers: ${headers.join(', ')}`);
            
            const stepsIndex = headers.indexOf('Steps');
            const hazardSourceIndex = headers.indexOf('Hazard Source');
            const currentControlIndex = headers.indexOf('Current Control');
            
            console.log(`[Translation] Column indices - Steps: ${stepsIndex}, Hazard Source: ${hazardSourceIndex}, Current Control: ${currentControlIndex}`);
            
            // Initialize storage for this row if not exists
            if (!window.translationHistory[rowIndex]) {
                window.translationHistory[rowIndex] = {};
            }
            
            // Translate Steps
            if (translateSteps && stepsIndex >= 0 && cells[stepsIndex]) {
                const currentText = cells[stepsIndex].textContent.trim();
                if (currentText && currentText.length > 0) {
                    // Store original if not already stored
                    if (!window.translationHistory[rowIndex].steps) {
                        window.translationHistory[rowIndex].steps = currentText;
                    }
                    console.log(`[Translation] Translating Steps [${stepsIndex}]: "${currentText}"`);
                    const translated = await window.translateText(currentText, targetLang);
                    console.log(`[Translation] Result: "${translated}"`);
                    cells[stepsIndex].textContent = translated;
                    cellsUpdated++;
                }
            }
            
            // Translate Hazard Source (inside input field)
            if (translateHazardSource && hazardSourceIndex >= 0 && cells[hazardSourceIndex]) {
                const inputEl = cells[hazardSourceIndex].querySelector('input');
                if (inputEl) {
                    const currentText = inputEl.value.trim();
                    if (currentText && currentText.length > 0) {
                        // Store original if not already stored
                        if (!window.translationHistory[rowIndex].hazardSource) {
                            window.translationHistory[rowIndex].hazardSource = currentText;
                        }
                        console.log(`[Translation] Translating Hazard Source [${hazardSourceIndex}]: "${currentText}"`);
                        const translated = await window.translateText(currentText, targetLang);
                        console.log(`[Translation] Result: "${translated}"`);
                        inputEl.value = translated;
                        cellsUpdated++;
                    }
                }
            }
            
            // Translate Current Control (inside input field)
            if (translateCurrentControl && currentControlIndex >= 0 && cells[currentControlIndex]) {
                const inputEl = cells[currentControlIndex].querySelector('input');
                if (inputEl) {
                    const currentText = inputEl.value.trim();
                    if (currentText && currentText.length > 0) {
                        // Store original if not already stored
                        if (!window.translationHistory[rowIndex].currentControl) {
                            window.translationHistory[rowIndex].currentControl = currentText;
                        }
                        console.log(`[Translation] Translating Current Control [${currentControlIndex}]: "${currentText}"`);
                        const translated = await window.translateText(currentText, targetLang);
                        console.log(`[Translation] Result: "${translated}"`);
                        inputEl.value = translated;
                        cellsUpdated++;
                    }
                }
            }
            
            translatedCount++;
        }
        
        console.log(`[Translation] Complete: ${translatedCount} rows processed, ${cellsUpdated} cells updated`);
        translationStatus.innerHTML = `‚úì Translated ${cellsUpdated} cells in ${translatedCount} rows successfully!<br><small>You can revert using the Revert button if needed.</small>`;
        setTimeout(() => {
            document.getElementById('translationModal').style.display = 'none';
            translationStatus.classList.add('hidden');
            translationStatus.classList.remove('text-red-600');
            translationStatus.innerHTML = '';
        }, 4000);
    } catch (error) {
        console.error('[Translation] Error:', error);
        translationStatus.textContent = '‚úó Translation failed. Please check console.';
        translationStatus.classList.add('text-red-600');
    } finally {
        translateConfirmBtn.disabled = false;
    }
};

// --- Revert Translation Function ---
window.revertTranslations = function() {
    if (Object.keys(window.translationHistory).length === 0) {
        alert('No translations to revert.');
        return;
    }
    
    const confirmed = confirm('Are you sure you want to revert all translations to original values?');
    if (!confirmed) return;
    
    try {
        for (const rowIndex in window.translationHistory) {
            const row = document.querySelector(`#table-container tr[data-row-index="${rowIndex}"]`);
            if (!row) continue;
            
            const cells = row.querySelectorAll('td');
            const headerRow = document.querySelector('#table-container thead tr');
            const headers = Array.from(headerRow?.querySelectorAll('th') || []).map(th => th.textContent.trim());
            
            const stepsIndex = headers.indexOf('Steps');
            const hazardSourceIndex = headers.indexOf('Hazard Source');
            const currentControlIndex = headers.indexOf('Current Control');
            
            const history = window.translationHistory[rowIndex];
            
            // Revert Steps
            if (history.steps && stepsIndex >= 0 && cells[stepsIndex]) {
                cells[stepsIndex].textContent = history.steps;
            }
            
            // Revert Hazard Source (from input field)
            if (history.hazardSource && hazardSourceIndex >= 0 && cells[hazardSourceIndex]) {
                const inputEl = cells[hazardSourceIndex].querySelector('input');
                if (inputEl) {
                    inputEl.value = history.hazardSource;
                }
            }
            
            // Revert Current Control (from input field)
            if (history.currentControl && currentControlIndex >= 0 && cells[currentControlIndex]) {
                const inputEl = cells[currentControlIndex].querySelector('input');
                if (inputEl) {
                    inputEl.value = history.currentControl;
                }
            }
        }
        
        console.log('[Translation] All translations reverted to original values');
        alert('‚úì All translations have been reverted to original values!');
        window.translationHistory = {}; // Clear history
    } catch (error) {
        console.error('[Translation] Revert error:', error);
        alert('‚úó Revert failed. Please check console.');
    }
};

// Helper function to translate text using MyMemory Translation API (free, CORS-enabled)
window.translateText = async function(text, targetLang) {
    if (!text || text.length === 0) return text;
    
    try {
        console.log(`[Translation] Translating to ${targetLang}: "${text.substring(0, 50)}..."`);
        
        // MyMemory API endpoint - CORS enabled, free, no API key needed
        // Converts language codes: fr->fr, de->de, es->es, it->it, pt->pt
        const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=en|${targetLang}`;
        
        const response = await fetch(url);
        
        if (!response.ok) {
            console.warn(`[Translation] API error: ${response.status}`);
            return text;
        }
        
        const data = await response.json();
        
        if (data && data.responseData && data.responseData.translatedText) {
            const translated = data.responseData.translatedText;
            console.log(`[Translation] Result: "${translated.substring(0, 50)}..."`);
            return translated;
        }
        
        console.warn(`[Translation] Unexpected response:`, data);
        return text;
    } catch (error) {
        console.error(`[Translation] Translation failed:`, error);
        return text;
    }
};
// --- End Translation Function ---

window.extractTableData = extractTableData;
window.buildTableFromData = buildTableFromData;
window.initializeDashboard = initializeDashboard;
window.updateDashboardMetrics = updateDashboardMetrics;  
window.updateAllCategoryColors = updateAllCategoryColors;  
window.populatePictureColumn = populatePictureColumn;
    })(); // End of App 1's isolated scope
    // --- APP 2 (FACE BLURRER) SCRIPT ---
    (function() {
        const fileUpload = document.getElementById('imageUpload');
        const processBtn = document.getElementById('processBtn');
        const statusDiv = document.getElementById('status');
        const progressBar = document.getElementById('progressBar');
        const progressContainer = document.getElementById('progress-container');
        const resultsDiv = document.getElementById('results');
        const galleryDiv = document.getElementById('imageGallery');
        const videoSection = document.getElementById('videoSection');
        const videoGallery = document.getElementById('videoGallery');
        const manualBlurCanvas = document.getElementById('manualBlurCanvas');
        const manualBlurCtx = manualBlurCanvas.getContext('2d');
        const downloadBtn = document.getElementById('downloadBtn');
        const privacyModal = document.getElementById('privacyModal');
        const privacyBtn = document.getElementById('privacyBtn');
        const closeModal = document.getElementById('closeModal');
        const lightboxModal = document.getElementById('lightboxModal');
        const lightboxImage = document.getElementById('lightboxImage');
        const closeLightbox = document.getElementById('closeLightbox');
        const undoBlurBtn = document.getElementById('undoBlurBtn');
        const deleteLightboxBtn = document.getElementById('deleteLightboxBtn');
        // --- NEW: Replace Image References ---
        const replaceImageBtn = document.getElementById('replaceImageBtn');
        const replaceImageInput = document.getElementById('replaceImageInput');
        // --- END NEW ---
        const prevArrow = document.getElementById('prevArrow');
        const nextArrow = document.getElementById('nextArrow');
        const lightboxGallery = document.getElementById('lightboxGallery');
        const stepDescription = document.getElementById('stepDescription');
        const spotHazards = document.getElementById('spotHazards');
        const existingControls = document.getElementById('existingControls');
        const SD_MAX_WIDTH = 640;
        const MANUAL_BLUR_RADIUS = 30; // Base radius, scaling applied later
        const MANUAL_BLUR_INTENSITY = 10;
        let modelsLoaded = false;
        
        // Globally accessible for integration
        window.originalFileNames = new Map();
        window.riskAssessmentData = new Map();
        
        let undoHistory = new Map();
        let currentLightboxImageId = null;
        let imageResults = [];
        // Privacy Modal Triggers
        privacyBtn.onclick = () => privacyModal.style.display = 'flex';
        closeModal.onclick = () => privacyModal.style.display = 'none';
        window.addEventListener('click', (event) => {
            if (event.target == privacyModal) privacyModal.style.display = 'none';
        });

        // Translation Modal Triggers
        const translationModal = document.getElementById('translationModal');
        const translateTableBtn = document.getElementById('translateTableBtn');
        const translateCancelBtn = document.getElementById('translateCancelBtn');
        const translateConfirmBtn = document.getElementById('translateConfirmBtn');
        
        if (translateTableBtn) {
            translateTableBtn.onclick = () => translationModal.style.display = 'flex';
        }
        
        if (translateCancelBtn) {
            translateCancelBtn.onclick = () => translationModal.style.display = 'none';
        }
        
        window.addEventListener('click', (event) => {
            if (event.target == translationModal) translationModal.style.display = 'none';
        });

        if (translateConfirmBtn) {
            translateConfirmBtn.onclick = window.translateTableColumns;
        }
        
        const revertTranslationsBtn = document.getElementById('revertTranslationsBtn');
        if (revertTranslationsBtn) {
            revertTranslationsBtn.onclick = window.revertTranslations;
        }
        
        // --- Event listener for drag and drop feedback ---
        const fileInput = document.getElementById('imageUpload');
        const uploadLabel = fileInput.parentElement;
        
        // Show loading state on drag over
        uploadLabel.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadLabel.style.backgroundColor = '#dbeafe';
            uploadLabel.style.borderColor = '#3b82f6';
        });
        
        uploadLabel.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadLabel.style.backgroundColor = '';
            uploadLabel.style.borderColor = '';
        });
        
        uploadLabel.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadLabel.style.backgroundColor = '';
            uploadLabel.style.borderColor = '';
            console.log('Files dropped, showing loading state');
            // Files are being dropped, show loading immediately
            progressContainer.style.display = 'block';
            progressBar.value = 5;
            progressBar.max = 100;
            statusDiv.style.backgroundColor = '#fef08a';
            statusDiv.style.borderLeft = '4px solid #eab308';
            statusDiv.innerHTML = `<strong style="color: #78350f;">üìÇ Loading files into browser memory...</strong><br><span class="animate-pulse" style="color: #b45309;">‚è≥ This may take a moment depending on file size...</span>`;
            processBtn.disabled = true;
        });
        
        // --- Event listener for file selection feedback ---
        fileUpload.addEventListener('change', async (event) => {
    const files = event.target.files;
    if (!files || files.length === 0) {
        if (modelsLoaded) {
            statusDiv.innerText = 'Models loaded. Please select your images or videos.';
        } else {
            statusDiv.innerText = 'Loading AI models... üß†'; // Or error state if needed
        }
        progressContainer.style.display = 'none';
        return;
    }
    
    // IMMEDIATELY show loading state when files are selected from file browser
    console.log('Files selected from browser:', files.length);
    progressContainer.style.display = 'block';
    progressBar.value = 5;
    progressBar.max = 100;
    statusDiv.style.backgroundColor = '#fef08a';
    statusDiv.style.borderLeft = '4px solid #eab308';
    statusDiv.innerHTML = `<strong style="color: #78350f;">üìÇ Loading ${files.length} file(s) into browser memory...</strong><br><span class="animate-pulse" style="color: #b45309;">‚è≥ This may take a moment depending on file size...</span>`;
    processBtn.disabled = true;
    
    // Force browser to repaint
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Animate progress while processing
    let progressValue = 5;
    const progressInterval = setInterval(() => {
        progressValue += Math.random() * 25;
        if (progressValue < 95) {
            progressBar.value = Math.min(progressValue, 90);
        }
    }, 300);
    
    // Add another delay to show the loading state for longer
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Process file information
    let totalSize = 0;
    let videoCount = 0;
    let imageCount = 0;
    
    for (let file of files) {
        totalSize += file.size;
        if (file.type.startsWith('video/') || file.name.match(/\.(mp4|mov|avi|mkv|webm)$/i)) {
            videoCount++;
        } else if (file.type.startsWith('image/')) {
            imageCount++;
        }
    }
    
    const sizeMB = (totalSize / (1024 * 1024)).toFixed(1);
    progressBar.value = 100;
    clearInterval(progressInterval);
    
    if (modelsLoaded) {
        statusDiv.style.backgroundColor = '#dcfce7';
        statusDiv.style.borderLeft = '4px solid #22c55e';
        statusDiv.innerHTML = `<strong style="color: #166534;">‚úÖ Files Loaded Successfully!</strong><br>
                            ${files.length} file(s) loaded (${sizeMB} MB) - ${imageCount} image(s), ${videoCount} video(s)<br>
                            <span style="color: #15803d; font-weight: bold;">Click 'Process Files' to continue.</span>`;
        processBtn.disabled = false;
        setTimeout(() => { progressContainer.style.display = 'none'; }, 2000);
    } else {
        statusDiv.style.backgroundColor = '#dbeafe';
        statusDiv.style.borderLeft = '4px solid #3b82f6';
        statusDiv.innerHTML = `<strong style="color: #1e40af;">‚è≥ Models loading...</strong><br>
                            ${files.length} file(s) ready (${sizeMB} MB). Please wait for models to load.`;
    }
});
        // --- End of event listener ---
        function showLightboxImage(imageId) {
            const thumbnailElement = document.getElementById(imageId);
            if (!thumbnailElement) return;
            currentLightboxImageId = imageId;
            lightboxImage.src = thumbnailElement.src;
            // Add error handling for image loading
            lightboxImage.onerror = () => {
                 console.error(`Failed to load lightbox image for ID: ${imageId}`);
                 showCustomAlert("Error loading the preview image.", 'error');
                 closeLightboxFunc(); // Close if image fails
             }
            undoBlurBtn.disabled = !undoHistory.has(currentLightboxImageId);
            const data = window.riskAssessmentData.get(currentLightboxImageId) || {};
            stepDescription.value = data.description || '';
            spotHazards.value = data.hazards || '';
            existingControls.value = data.controls || '';
            document.getElementById('userFrequency').value = data.userFrequency || '';
            document.getElementById('userSeverity').value = data.userSeverity || '';
            document.getElementById('userLikelihood').value = data.userLikelihood || '';
            updateLightboxGallery();
        }
        function updateLightboxGallery() {
            lightboxGallery.innerHTML = '';
            const galleryImages = Array.from(galleryDiv.querySelectorAll('.gallery-item img'));
            galleryImages.forEach(img => {
                const thumb = document.createElement('img');
                thumb.src = img.src;
                thumb.id = `thumb-${img.id}`;
                thumb.className = `w-16 h-16 object-cover rounded-md cursor-pointer border-2 transition ${img.id === currentLightboxImageId ? 'border-indigo-500' : 'border-transparent hover:border-slate-400'}`;
                thumb.draggable = true;
                thumb.onclick = () => showLightboxImage(img.id);
                lightboxGallery.appendChild(thumb);
            });
        }
        function closeLightboxFunc() {
            lightboxModal.style.display = 'none';
            currentLightboxImageId = null;
            lightboxGallery.innerHTML = '';
            stepDescription.value = '';
            spotHazards.value = '';
            existingControls.value = '';
        }
        closeLightbox.onclick = closeLightboxFunc;
        function saveRiskData() {
            if (!currentLightboxImageId) return;
            const userFrequency = document.getElementById('userFrequency').value;
            const userSeverity = document.getElementById('userSeverity').value;
            const userLikelihood = document.getElementById('userLikelihood').value;
            
            window.riskAssessmentData.set(currentLightboxImageId, {
                description: stepDescription.value,
                hazards: spotHazards.value,
                controls: existingControls.value,
                userFrequency: userFrequency || null,
                userSeverity: userSeverity || null,
                userLikelihood: userLikelihood || null
            });
        }
        stepDescription.addEventListener('input', saveRiskData);
        spotHazards.addEventListener('input', saveRiskData);
        existingControls.addEventListener('input', saveRiskData);
        document.getElementById('userFrequency').addEventListener('change', saveRiskData);
        document.getElementById('userSeverity').addEventListener('change', saveRiskData);
        document.getElementById('userLikelihood').addEventListener('change', saveRiskData);
        function showNextImage() {
            if (!currentLightboxImageId) return;
            const galleryImages = Array.from(galleryDiv.querySelectorAll('.gallery-item img'));
            if (galleryImages.length === 0) return;
            const currentIndex = galleryImages.findIndex(img => img.id === currentLightboxImageId);
            const nextIndex = (currentIndex + 1) % galleryImages.length;
            showLightboxImage(galleryImages[nextIndex].id);
        }
        function showPreviousImage() {
            if (!currentLightboxImageId) return;
            const galleryImages = Array.from(galleryDiv.querySelectorAll('.gallery-item img'));
            if (galleryImages.length === 0) return;
            const currentIndex = galleryImages.findIndex(img => img.id === currentLightboxImageId);
            const prevIndex = (currentIndex - 1 + galleryImages.length) % galleryImages.length;
            showLightboxImage(galleryImages[prevIndex].id);
        }
        function getDragAfterElement(container, x, isLightbox = false) {
            const selector = isLightbox ? '#lightboxGallery img:not(.dragging)' : '.gallery-item:not(.dragging)';
            const draggableElements = [...container.querySelectorAll(selector)];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = x - box.left - box.width / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                }
                return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        // --- FIX: Load models from CDN ---
        async function loadModels() {
            // Changed MODEL_URL to point to a CDN
            const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/'; 
            try {
                if (typeof faceapi === 'undefined') throw new Error("face-api.js script not loaded. Please ensure it's included correctly, perhaps via CDN.");
                statusDiv.innerText = 'Loading AI models from CDN... Please wait.';
                // Load the specific model needed (ssdMobilenetv1)
                await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL);
                // Optional: Load other models if needed later, e.g., faceLandmark68Net, faceRecognitionNet
                // await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
                // await faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL);
                
                modelsLoaded = true;
                // Update status based on whether files are already selected
                 const files = fileUpload.files;
                 if (files && files.length > 0) {
                     statusDiv.innerText = `${files.length} file(s) selected. Click 'Process Files' to continue.`;
                 } else {
                     statusDiv.innerText = 'Models loaded. Please select your images or videos.';
                 }
                processBtn.disabled = false;
            } catch (error) {
                // Improved error message
                statusDiv.innerText = 'Error loading AI models from CDN. Check your internet connection and the browser console for details.';
                console.error("Model loading error:", error);
                // Optionally add a retry button or mechanism here
            }
        }
        // --- END FIX ---

        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                const missingLibs = [];
                // Check for faceapi again, as it might fail even if script tag exists
                if (typeof faceapi === 'undefined') missingLibs.push('face-api.js (Check script tag)'); 
                if (typeof JSZip === 'undefined') missingLibs.push('JSZip (lib/jszip.min.js)');
                if (typeof PDFDocument === 'undefined') missingLibs.push('pdfkit (lib/pdfkit.min.js)');
                if (typeof blobStream === 'undefined') missingLibs.push('blob-stream (lib/blob-stream.min.js)');
                if (missingLibs.length > 0) {
                    const errorMsg = `Error: Failed to load essential libraries: ${missingLibs.join(', ')}. Please ensure local files are in the ./lib/ directory or check CDN links, and refresh.`;
                    console.error(errorMsg);
                    statusDiv.innerText = errorMsg;
                    statusDiv.classList.add('text-red-600', 'font-bold');
                    return; // Stop further execution if libs are missing
                }
                // If all libs seem present, attempt to load models
                loadModels();
            }, 500); // Slight delay to ensure scripts might have loaded

            // Rest of the DOMContentLoaded event listeners...
           galleryDiv.addEventListener('click', async (event) => {
                if (event.target.classList.contains('delete-btn')) {
                    const item = event.target.closest('.gallery-item');
                    if (!item) return;
                    const img = item.querySelector('img');
                    if (!img) return;
                    if (!await showCustomConfirm('Are you sure you want to delete this image?')) return;
                    const imgId = img.id;
                    const imgUrl = img.src;
                    const fileName = window.originalFileNames.get(imgId);
                    if (fileName) {
                        const resultIndex = imageResults.findIndex(res => res.fileName === fileName);
                        if (resultIndex > -1) imageResults.splice(resultIndex, 1);
                    }
                    window.originalFileNames.delete(imgId);
                    const undoUrl = undoHistory.get(imgId);
                    if (undoUrl) URL.revokeObjectURL(undoUrl);
                    undoHistory.delete(imgId);
                    window.riskAssessmentData.delete(imgId);
                    item.remove();
                    updateResults();
                    if (currentLightboxImageId === imgId) closeLightboxFunc();
                    if (galleryDiv.children.length === 0 || (galleryDiv.children.length === 1 && galleryDiv.querySelector('p'))) {
                        galleryDiv.innerHTML = '<p class="text-slate-500 col-span-full text-center">Processed images/frames will appear here...</p>';
                        downloadBtn.style.display = 'none';
                        document.getElementById('generateAiReportBtn').style.display = 'none';
                        document.getElementById('manual-blur-info').style.display = 'none';
                    }
                } else if (event.target.tagName === 'IMG') {
                    lightboxModal.style.display = 'flex';
                    showLightboxImage(event.target.id);
                }
            });
            galleryDiv.addEventListener('dragstart', (event) => {
                const galleryItem = event.target.closest('.gallery-item');
                if (galleryItem) {
                    event.dataTransfer.setData('text/plain', galleryItem.id);
                    galleryItem.classList.add('dragging');
                    event.dataTransfer.effectAllowed = 'move';
                }
            });
            galleryDiv.addEventListener('dragend', (event) => {
                const galleryItem = event.target.closest('.gallery-item');
                if (galleryItem) galleryItem.classList.remove('dragging');
            });
            galleryDiv.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
            });
            galleryDiv.addEventListener('drop', (event) => {
                event.preventDefault();
                const draggedId = event.dataTransfer.getData('text/plain');
                const draggedItem = document.getElementById(draggedId);
                if (!draggedItem) return;
                const afterElement = getDragAfterElement(galleryDiv, event.clientX);
                if (afterElement) {
                    galleryDiv.insertBefore(draggedItem, afterElement);
                } else {
                    galleryDiv.appendChild(draggedItem);
                }
                updateLightboxGallery();
            });
            lightboxGallery.addEventListener('dragstart', (event) => {
                if (event.target.tagName === 'IMG') {
                    event.dataTransfer.setData('text/plain', event.target.id);
                    event.target.classList.add('dragging');
                    event.dataTransfer.effectAllowed = 'move';
                }
            });
            lightboxGallery.addEventListener('dragend', (event) => {
                if (event.target.tagName === 'IMG') event.target.classList.remove('dragging');
            });
            lightboxGallery.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
            });
            lightboxGallery.addEventListener('drop', (event) => {
                event.preventDefault();
                const draggedId = event.dataTransfer.getData('text/plain');
                const draggedThumb = document.getElementById(draggedId);
                if (!draggedThumb) return;
                const afterElement = getDragAfterElement(lightboxGallery, event.clientX, true);
                const mainGalleryItemId = draggedThumb.id.replace('thumb-', '');
                const mainGalleryItem = document.getElementById(mainGalleryItemId)?.closest('.gallery-item');
                const mainAfterElement = afterElement ? document.getElementById(afterElement.id.replace('thumb-', ''))?.closest('.gallery-item') : null;
                
                if (mainGalleryItem) {
                    if (mainAfterElement) {
                        galleryDiv.insertBefore(mainGalleryItem, mainAfterElement);
                    } else {
                        galleryDiv.appendChild(mainGalleryItem);
                    }
                }
                if (afterElement) {
                    lightboxGallery.insertBefore(draggedThumb, afterElement);
                } else {
                    lightboxGallery.appendChild(draggedThumb);
                }
                updateLightboxGallery();
            });
        });
        
        // Simple frame extraction helper
        const extractVideoFrames = async (file, numFrames = 5) => {
            return new Promise((resolve) => {
                const video = document.createElement('video');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const frames = [];
                
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    let framesExtracted = 0;
                    const duration = video.duration;
                    const interval = duration / (numFrames + 1);
                    
                    const extractFrame = (index) => {
                        if (index >= numFrames) {
                            resolve(frames);
                            return;
                        }
                        
                        video.currentTime = interval * (index + 1);
                    };
                    
                    video.onseeked = () => {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        canvas.toBlob((blob) => {
                            frames.push({
                                timestamp: video.currentTime,
                                blob: blob,
                                url: URL.createObjectURL(blob)
                            });
                            framesExtracted++;
                            extractFrame(framesExtracted);
                        });
                    };
                    
                    video.onerror = () => {
                        console.warn('Could not extract frames from video:', file.name);
                        resolve(frames);
                    };
                    
                    extractFrame(0);
                };
                
                video.onerror = () => {
                    console.warn('Could not load video:', file.name);
                    resolve([]);
                };
                
                video.src = URL.createObjectURL(file);
            });
        };
        
        // Helper to handle MOV files (Pass-through for now as client-side conversion is heavy)
        const convertMOVtoMP4 = async (file) => {
            console.log('Pass-through MOV file:', file.name);
            // In a real app, we might use ffmpeg.wasm here, but it's heavy.
            // We rely on browser support for QuickTime/MP4 containers.
            return file;
        };

        processBtn.addEventListener('click', async () => {
            const files = fileUpload.files;
            // Max file check moved to the 'change' event listener
            if (!files.length) { statusDiv.innerText = 'Please select at least one file.'; return; }
            if (!modelsLoaded) { statusDiv.innerText = 'AI models not loaded.'; return; }
            processBtn.disabled = true; processBtn.innerText = 'Processing...';
            downloadBtn.style.display = 'none';
            document.getElementById('generateAiReportBtn').style.display = 'none';
            progressContainer.style.display = 'block';
            resultsDiv.style.display = 'none'; resultsDiv.innerHTML = '';
           // galleryDiv.innerHTML = '<p class="text-slate-500 col-span-full text-center">Processing files...</p>';
            videoGallery.innerHTML = '<p class="text-slate-500">Uploaded videos will appear here...</p>';
            document.getElementById('manual-blur-info').style.display = 'none';
            progressBar.value = 0;
            let imageFiles = [];
            let videoFiles = [];
            
            // Check if file is a video by MIME type or file extension
            const isVideoFile = (file) => {
                const videoExtensions = ['mp4', 'mov', 'avi', 'mkv', 'webm', 'flv', 'wmv', 'm4v', '3gp'];
                const extension = file.name.split('.').pop().toLowerCase();
                return file.type.startsWith('video/') || videoExtensions.includes(extension);
            };
            
            for (let file of files) {
                if (file.type.startsWith('image/')) {
                    imageFiles.push(file);
                } else if (isVideoFile(file)) {
                    // Convert MOV files to MP4
                    const extension = file.name.split('.').pop().toLowerCase();
                    if (extension === 'mov' || file.type === 'video/quicktime') {
                        const convertedFile = await convertMOVtoMP4(file);
                        videoFiles.push(convertedFile);
                    } else {
                        videoFiles.push(file);
                    }
                }
            }
            progressBar.max = imageFiles.length;
            let processedCount = 0;
            imageResults = [];
           // window.originalFileNames.clear();
           // undoHistory.clear();
           // window.riskAssessmentData.clear();
            const processingPromises = imageFiles.length > 0 ? imageFiles.map(async (file, i) => {
                const fileId = `img-${Date.now()}-${i}`;
                statusDiv.innerText = `Processing image ${i + 1} of ${imageFiles.length}...`;
                try {
                    const result = await processImage(file);
                    imageResults.push({ fileName: file.name, faceCount: result.faceCount });
                    if (result.blob) {
                        const imageUrl = URL.createObjectURL(result.blob);
                        window.originalFileNames.set(fileId, file.name);
                        const container = document.createElement('div');
                        container.className = 'gallery-item relative w-full pt-[100%] h-0 cursor-grab';
                        container.id = `gallery-item-${fileId}`;
                        container.draggable = true;
                        
                        const imgElement = document.createElement('img');
                        imgElement.src = imageUrl;
                        imgElement.alt = `Processed ${file.name}`;
                        imgElement.id = fileId;
                        imgElement.className = "absolute top-0 left-0 w-full h-full object-cover rounded-lg shadow-md cursor-pointer transition-transform duration-200 hover:scale-105";
                        
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'delete-btn absolute top-1.5 right-1.5 z-10 bg-black/60 text-white w-5 h-5 rounded-full text-xs font-bold leading-none flex items-center justify-center hover:bg-red-600 transition';
                        deleteBtn.innerHTML = '&times;';
                        deleteBtn.title = 'Delete this image';
                        
                        container.appendChild(imgElement);
                        container.appendChild(deleteBtn);
                        if (galleryDiv.querySelector('p')) galleryDiv.innerHTML = '';
                        galleryDiv.appendChild(container);
                    }
                } catch (error) {
                    console.error(`Error processing file ${file.name}:`, error);
                    imageResults.push({ fileName: file.name, faceCount: 'Error' });
                }
                processedCount++;
                progressBar.value = processedCount;
            }) : [];
            await Promise.all(processingPromises);
            if (videoFiles.length > 0) {
                videoSection.style.display = 'block';
                videoGallery.innerHTML = '';
                videoFiles.forEach((file, i) => {
                    const vidContainer = document.createElement('div');
                    vidContainer.className = 'vid-container flex flex-col items-center max-w-md mx-auto p-4 bg-white rounded-lg border border-slate-200 relative';
                    
                    const title = document.createElement('h3');
                    title.className = 'font-semibold text-slate-800 mb-2 w-full';
                    title.textContent = `üìπ ${file.name}`;
                    vidContainer.appendChild(title);
                    
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(file);
                    video.controls = true;
                    video.controlsList = 'nodownload';
                    video.preload = 'metadata';
                    video.id = `vid-${Date.now()}-${i}`;
                    video.className = "w-full h-auto rounded-lg shadow-md bg-black";
                    video.style.minHeight = '300px';
                    
                    // Store file name for reference
                    video.dataset.fileName = file.name;
                    
                    vidContainer.appendChild(video);
                    
                    const btnContainer = document.createElement('div');
                    btnContainer.className = 'mt-3 flex gap-3 w-full';
                    
                    const captureBtn = document.createElement('button');
                    captureBtn.textContent = 'üì∏ Capture Frame';
                    captureBtn.className = "flex-1 bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-indigo-700 transition duration-300";
                    captureBtn.onclick = () => captureAndProcessFrame(video, file.name);
                    
                    const fullscreenCaptureBtn = document.createElement('button');
                    fullscreenCaptureBtn.textContent = '‚õ∂ Fullscreen Capture';
                    fullscreenCaptureBtn.className = "flex-1 bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-blue-700 transition duration-300";
                    fullscreenCaptureBtn.onclick = () => openFullscreenCapture(file, file.name);
                    
                    btnContainer.appendChild(captureBtn);
                    btnContainer.appendChild(fullscreenCaptureBtn);
                    vidContainer.appendChild(btnContainer);
                    
                    videoGallery.appendChild(vidContainer);
                });
            } else {
                videoSection.style.display = 'none';
            }
            
            // Custom fullscreen capture interface
            const openFullscreenCapture = (videoFile, fileName) => {
                // Remove any existing fullscreen modal first
                const existingModal = document.getElementById('fullscreen-capture-modal');
                if (existingModal) {
                    existingModal.remove();
                }
                
                const modal = document.createElement('div');
                modal.id = 'fullscreen-capture-modal';
                modal.className = 'fixed inset-0 bg-black z-50 flex flex-col';
                modal.style.padding = '20px';
                
                // Create container for video and controls
                const container = document.createElement('div');
                container.className = 'flex flex-col h-full w-full max-w-6xl mx-auto';
                
                // Header with title and close button
                const header = document.createElement('div');
                header.className = 'flex justify-between items-center mb-4 text-white';
                
                const title = document.createElement('h2');
                title.className = 'text-2xl font-bold';
                title.textContent = `üìπ ${fileName} - Fullscreen Capture`;
                
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '‚úï';
                closeBtn.className = 'text-3xl hover:text-red-400 transition';
                closeBtn.onclick = () => {
                    modal.remove();
                    // Clean up blob URL when modal closes
                    if (video.src && video.src.startsWith('blob:')) {
                        URL.revokeObjectURL(video.src);
                    }
                };
                
                header.appendChild(title);
                header.appendChild(closeBtn);
                container.appendChild(header);
                
                // Main content area (video + thumbnails)
                const contentArea = document.createElement('div');
                contentArea.className = 'flex gap-4 flex-1 overflow-hidden';
                
                // Left side - Video player
                const videoContainer = document.createElement('div');
                videoContainer.className = 'flex-1 flex flex-col';
                
                // Create fresh video element with new blob URL
                const video = document.createElement('video');
                const blobURL = URL.createObjectURL(videoFile);
                video.controls = true;
                video.controlsList = 'nodownload';
                video.preload = 'auto';
                video.muted = false;
                video.playsInline = true;
                video.className = 'flex-1 rounded-lg shadow-lg bg-black';
                video.style.objectFit = 'contain';
                video.style.maxHeight = '100%';
                video.style.width = '100%';
                
                // Use source element for better codec handling
                const source = document.createElement('source');
                source.src = blobURL;
                source.type = videoFile.type || 'video/quicktime';
                video.appendChild(source);
                
                // Fallback error message
                const errorText = document.createTextNode('Your browser does not support this video format.');
                video.appendChild(errorText);
                
                // Ensure video loads properly before attempting playback
                video.onloadedmetadata = () => {
                    console.log('Video metadata loaded:', fileName, 'Dimensions:', video.videoWidth, 'x', video.videoHeight, 'Duration:', video.duration);
                };
                
                video.oncanplay = () => {
                    console.log('Video can play:', fileName);
                    video.play().catch(err => console.warn('Autoplay prevented:', err));
                };
                
                video.onerror = (e) => {
                    console.error('Video load error:', e, fileName);
                    statusDiv.innerText = `Error loading video: ${fileName}`;
                };
                
                videoContainer.appendChild(video);
                contentArea.appendChild(videoContainer);
                
                // Right side - Captured frames thumbnails
                const thumbnailContainer = document.createElement('div');
                thumbnailContainer.className = 'w-32 flex flex-col gap-2 overflow-y-auto bg-slate-900 p-2 rounded-lg';
                
                const thumbTitle = document.createElement('p');
                thumbTitle.className = 'text-white text-sm font-semibold text-center';
                thumbTitle.textContent = 'Captured Frames';
                thumbnailContainer.appendChild(thumbTitle);
                
                const thumbGrid = document.createElement('div');
                thumbGrid.id = 'thumbnail-grid';
                thumbGrid.className = 'flex flex-col gap-2';
                thumbnailContainer.appendChild(thumbGrid);
                
                contentArea.appendChild(thumbnailContainer);
                container.appendChild(contentArea);
                
                // Bottom control panel
                const controls = document.createElement('div');
                controls.className = 'mt-4 flex gap-3 justify-center flex-wrap text-center';
                
                const captureBtn = document.createElement('button');
                captureBtn.textContent = 'üì∏ Capture Current Frame';
                captureBtn.className = 'bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-200';
                captureBtn.onclick = async () => {
                    captureBtn.disabled = true;
                    captureBtn.textContent = '‚è≥ Capturing...';
                    
                    try {
                        // Wait for video to be ready
                        if (!video.videoWidth || !video.videoHeight) {
                            await new Promise((resolve, reject) => {
                                const checkReady = () => {
                                    if (video.videoWidth && video.videoHeight) {
                                        resolve();
                                    } else {
                                        setTimeout(checkReady, 100);
                                    }
                                };
                                checkReady();
                                setTimeout(() => reject(new Error('Video dimensions not available')), 3000);
                            });
                        }
                        
                        // Create a promise that rejects after 5 seconds
                        const timeoutPromise = new Promise((_, reject) => {
                            setTimeout(() => reject(new Error('Frame capture timeout - MOV files may not be supported in fullscreen mode')), 5000);
                        });

                        // Create the capture promise
                        const capturePromise = (async () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            canvas.width = video.videoWidth;
                            canvas.height = video.videoHeight;
                            
                            console.log('Capturing frame - Canvas size:', canvas.width, 'x', canvas.height);
                            
                            // Attempt to draw image with error handling and createImageBitmap
                            try {
                                if (window.createImageBitmap) {
                                    const bitmap = await createImageBitmap(video);
                                    ctx.drawImage(bitmap, 0, 0);
                                    bitmap.close();
                                } else {
                                    ctx.drawImage(video, 0, 0);
                                }
                            } catch (canvasError) {
                                console.warn('Bitmap capture failed, trying fallback:', canvasError);
                                ctx.drawImage(video, 0, 0);
                            }
                            
                            return new Promise((resolve, reject) => {
                                canvas.toBlob((blob) => {
                                    if (blob) resolve(blob);
                                    else reject(new Error('Failed to create image blob from canvas'));
                                });
                            });
                        })();
                        
                        // Race the capture against the timeout
                        const blob = await Promise.race([capturePromise, timeoutPromise]);
                        
                        // If we get here, capture was successful
                        const thumb = document.createElement('img');
                        thumb.className = 'rounded border-2 border-indigo-400 cursor-pointer hover:border-indigo-300 transition';
                        thumb.style.objectFit = 'contain';
                        thumb.style.width = '100%';
                        thumb.style.height = 'auto';
                        thumb.style.maxHeight = '100px';
                        thumb.title = `Frame at ${Math.round(video.currentTime)}s`;
                        thumb.src = URL.createObjectURL(blob);
                        document.getElementById('thumbnail-grid').appendChild(thumb);
                        
                        // Also process the frame for face detection
                        await captureAndProcessFrame(video, fileName);
                        
                        captureBtn.textContent = 'üì∏ Capture Current Frame';
                    } catch (error) {
                        console.warn('Capture failed:', error.message);
                        
                        // Show error message to user
                        const errorMsg = document.createElement('div');
                        errorMsg.className = 'absolute inset-0 flex items-center justify-center bg-black/70 rounded-lg p-4';
                        errorMsg.innerHTML = `
                            <div class="bg-red-900 text-white rounded p-4 text-center max-w-sm">
                                <p class="font-bold mb-2">‚ö†Ô∏è Capture Not Supported</p>
                                <p class="text-sm mb-3">${error.message}</p>
                                <p class="text-xs text-red-300 mb-3">Try using the regular "Capture Frame" button or convert the video to MP4 format.</p>
                                <button onclick="this.parentElement.parentElement.remove()" class="bg-red-700 hover:bg-red-800 px-4 py-2 rounded text-sm font-semibold">Dismiss</button>
                            </div>
                        `;
                        
                        const modal = document.getElementById('fullscreen-capture-modal');
                        if (modal) {
                            modal.appendChild(errorMsg);
                            setTimeout(() => errorMsg.remove(), 5000);
                        }
                    } finally {
                        captureBtn.disabled = false;
                        captureBtn.textContent = 'üì∏ Capture Current Frame';
                    }
                };
                
                const spaceHint = document.createElement('p');
                spaceHint.className = 'text-white text-sm w-full';
                spaceHint.textContent = 'üí° Press SPACE to capture | ESC to close';
                
                controls.appendChild(captureBtn);
                controls.appendChild(spaceHint);
                container.appendChild(controls);
                
                modal.appendChild(container);
                document.body.appendChild(modal);
                
                // Add keyboard shortcuts - capture on space
                const handleKeyDown = (e) => {
                    const modal = document.getElementById('fullscreen-capture-modal');
                    if (!modal) {
                        document.removeEventListener('keydown', handleKeyDown);
                        return;
                    }
                    
                    if (e.code === 'Space') {
                        e.preventDefault();
                        // Trigger the capture button click
                        captureBtn.click();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        modal.remove();
                        document.removeEventListener('keydown', handleKeyDown);
                    }
                };
                
                // Use setTimeout to ensure the event listener is properly attached
                setTimeout(() => {
                    document.addEventListener('keydown', handleKeyDown);
                }, 100);
                
                video.focus();
            };
            if (processedCount === 0 && videoFiles.length === 0) {
                 galleryDiv.innerHTML = '<p class="text-slate-500 col-span-full text-center">No image files were processed. Upload videos will appear above.</p>';
            }
            updateResults();
            statusDiv.innerText = 'Processing Complete.';
            document.getElementById('manual-blur-info').style.display = 'block';
            progressContainer.style.display = 'none';
            processBtn.disabled = false;
            processBtn.innerText = 'Process More Files';
            fileUpload.value = ""; // Clear file input after processing
            if (galleryDiv.querySelectorAll('.gallery-item img').length > 0) {
                downloadBtn.style.display = 'block';
                document.getElementById('generateAiReportBtn').style.display = 'block';
                document.getElementById('saveProjectBtn').style.display = 'block';
            }
        });
        function updateResults() {
            let resultsHTML = '<ul class="space-y-1">' + imageResults.map(res => {
                let countText = res.faceCount === 'Error' ? '<span class="font-semibold text-red-600">Error</span>' : `<span class="font-semibold text-indigo-700">${res.faceCount} face(s) detected</span>`;
                let displayName = res.fileName.length > 40 ? res.fileName.substring(0, 37) + '...' : res.fileName;
                return `<li class="flex justify-between items-center text-slate-700"><span>${displayName}:</span> ${countText}</li>`;
            }).join('') + '</ul>';
            resultsDiv.innerHTML = resultsHTML;
            resultsDiv.style.display = 'block';
        }
        async function processImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => {
                    const img = new Image();
                    img.onload = async () => {
                        try {
                            let newWidth = img.width;
                            let newHeight = img.height;
                            if (newWidth > SD_MAX_WIDTH) {
                                const aspectRatio = img.height / img.width;
                                newWidth = SD_MAX_WIDTH;
                                newHeight = Math.round(newWidth * aspectRatio);
                            }
                            const canvas = document.createElement('canvas');
                            canvas.width = newWidth; canvas.height = newHeight;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, newWidth, newHeight);
                            const detections = await faceapi.detectAllFaces(canvas, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.4 }));
                            if (detections.length > 0) {
                                detections.forEach(detection => {
                                    const { x, y, width, height } = detection.box;
                                    if (width <= 0 || height <= 0) return;
                                    const blurAmount = Math.max(5, Math.round(Math.max(width, height) / 5));
                                    ctx.save();
                                    ctx.filter = `blur(${blurAmount}px)`;
                                    ctx.drawImage(canvas, x, y, width, height, x, y, width, height);
                                    ctx.restore();
                                });
                            }
                            canvas.toBlob(blob => {
                                resolve({ blob, faceCount: detections.length, width: newWidth, height: newHeight });
                            }, 'image/jpeg', 0.9);
                        } catch (error) { reject(error); }
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        async function processCanvas(inputCanvas) {
            return new Promise(async (resolve, reject) => {
                try {
                    const imgWidth = inputCanvas.width;
                    const imgHeight = inputCanvas.height;
                    const aspectRatio = imgHeight / imgWidth;
                    let newWidth = imgWidth;
                    let newHeight = imgHeight;
                    if (newWidth > SD_MAX_WIDTH) {
                        newWidth = SD_MAX_WIDTH;
                        newHeight = Math.round(newWidth * aspectRatio);
                    }
                    const resizedCanvas = document.createElement('canvas');
                    resizedCanvas.width = newWidth;
                    resizedCanvas.height = newHeight;
                    const ctx = resizedCanvas.getContext('2d');
                    ctx.drawImage(inputCanvas, 0, 0, newWidth, newHeight);
                    const detections = await faceapi.detectAllFaces(resizedCanvas, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.4 }));
                    if (detections.length > 0) {
                        detections.forEach(detection => {
                            const { x, y, width, height } = detection.box;
                            if (width <= 0 || height <= 0) return;
                            const blurAmount = Math.max(5, Math.round(Math.max(width, height) / 5));
                            ctx.save();
                            ctx.filter = `blur(${blurAmount}px)`;
                            ctx.drawImage(resizedCanvas, x, y, width, height, x, y, width, height);
                            ctx.restore();
                        });
                    }
                    resizedCanvas.toBlob(blob => {
                        resolve({ blob, faceCount: detections.length });
                    }, 'image/jpeg', 0.9);
                } catch (error) { reject(error); }
            });
        }
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        async function captureAndProcessFrame(video, videoName) {
            video.pause();
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = video.videoWidth;
            captureCanvas.height = video.videoHeight;
            
            try {
                // Try using createImageBitmap for better compatibility with some video formats
                if (window.createImageBitmap) {
                    const bitmap = await createImageBitmap(video);
                    captureCanvas.getContext('2d').drawImage(bitmap, 0, 0);
                    bitmap.close();
                } else {
                    captureCanvas.getContext('2d').drawImage(video, 0, 0);
                }
            } catch (canvasError) {
                console.warn(`Canvas frame capture failed for ${videoName}:`, canvasError);
                // Fallback to standard drawImage if bitmap fails
                try {
                     captureCanvas.getContext('2d').drawImage(video, 0, 0);
                } catch (e) {
                    statusDiv.innerText = 'Frame capture not supported for this video format.';
                    return;
                }
            }
            
            statusDiv.innerText = 'Processing captured frame...';
            try {
                // Add timeout to processCanvas to prevent infinite hangs
                const processPromise = processCanvas(captureCanvas);
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Processing timeout')), 10000)
                );
                
                const result = await Promise.race([processPromise, timeoutPromise]);
                
                const fileId = `frame-${Date.now()}`;
                const now = new Date();
                const timestamp = now.toISOString().replace(/:/g, '-').replace(/\./g, '_');
                const baseName = videoName.replace(/\.[^/.]+$/, "");
                const frameNumber = now.getTime();
                const frameName = `${baseName}_frame_${timestamp}_${frameNumber}.jpg`;
                imageResults.push({ fileName: frameName, faceCount: result.faceCount });
                if (result.blob) {
                    const imageUrl = URL.createObjectURL(result.blob);
                    window.originalFileNames.set(fileId, frameName);
                    
                    const container = document.createElement('div');
                    container.className = 'gallery-item relative w-full pt-[100%] h-0 cursor-grab';
                    container.id = `gallery-item-${fileId}`;
                    container.draggable = true;
                    
                    const imgElement = document.createElement('img');
                    imgElement.src = imageUrl;
                    imgElement.alt = `Processed frame from ${videoName}`;
                    imgElement.id = fileId;
                    imgElement.className = "absolute top-0 left-0 w-full h-full object-cover rounded-lg shadow-md cursor-pointer transition-transform duration-200 hover:scale-105";
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn absolute top-1.5 right-1.5 z-10 bg-black/60 text-white w-5 h-5 rounded-full text-xs font-bold leading-none flex items-center justify-center hover:bg-red-600 transition';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.title = 'Delete this image';
                    
                    container.appendChild(imgElement);
                    container.appendChild(deleteBtn);
                    
                    if (galleryDiv.querySelector('p')) galleryDiv.innerHTML = '';
                    galleryDiv.appendChild(container);
                    downloadBtn.style.display = 'block';
                    document.getElementById('generateAiReportBtn').style.display = 'block';
                    document.getElementById('saveProjectBtn').style.display = 'block';
                }
                updateResults();
                statusDiv.innerText = 'Frame processed and added to gallery.';
            } catch (error) {
                console.error(`Error processing frame from ${videoName}:`, error);
                statusDiv.innerText = 'Error processing frame.';
            }
        }
        
        // --- FIX: This function now correctly calculates coordinates for 'object-contain' ---
        async function handleManualBlurOnLightbox(event) {
            const largeImage = event.target;
            const thumbnail = document.getElementById(currentLightboxImageId);
            
            // Ensure image and its natural dimensions are loaded/available
            if (!thumbnail || !largeImage.naturalWidth || largeImage.naturalWidth === 0) {
                console.warn("Manual blur cancelled: Lightbox image not fully loaded or has zero dimensions.");
                return;
            }

            // --- NEW COORDINATE LOGIC for 'object-contain' ---
            
            const {
                naturalWidth, naturalHeight, // Actual dimensions of the image file
                clientWidth, clientHeight     // Dimensions of the <img> element on screen
            } = largeImage;

            const rect = largeImage.getBoundingClientRect(); // Position of the <img> element

            // 1. Get aspect ratios
            const imageAspectRatio = naturalWidth / naturalHeight;
            const boxAspectRatio = clientWidth / clientHeight;

            let renderedWidth, renderedHeight, offsetX, offsetY;

            // 2. Compare ratios to find rendered size and offsets (letterboxing/pillarboxing)
            if (imageAspectRatio > boxAspectRatio) {
                // Image is wider than the box, constrained by width (letterboxed)
                renderedWidth = clientWidth;
                renderedHeight = clientWidth / imageAspectRatio;
                offsetX = 0;
                offsetY = (clientHeight - renderedHeight) / 2;
            } else {
                // Image is taller than or same as the box, constrained by height (pillarboxed)
                renderedHeight = clientHeight;
                renderedWidth = clientHeight * imageAspectRatio;
                offsetX = (clientWidth - renderedWidth) / 2;
                offsetY = 0;
            }

            // 3. Get click relative to the <img> element's box
            const clickX_relativeToBox = event.clientX - rect.left;
            const clickY_relativeToBox = event.clientY - rect.top;

            // 4. Get click relative to the *rendered image* inside the box
            const clickX_relativeToImage = clickX_relativeToBox - offsetX;
            const clickY_relativeToImage = clickY_relativeToBox - offsetY;

            // 5. Check if click was in the letterbox/pillarbox (outside the image)
            if (clickX_relativeToImage < 0 || clickX_relativeToImage > renderedWidth ||
                clickY_relativeToImage < 0 || clickY_relativeToImage > renderedHeight) {
                console.debug("Click was outside the image (in the letterbox area).");
                return; // Don't blur
            }

            // 6. Calculate scaling factor (from rendered image to natural image)
            // (We only need one, as aspect ratio is maintained)
            const scale = naturalWidth / renderedWidth; 
            
            // 7. Calculate final coordinates on the *natural, full-res* image
            const x = clickX_relativeToImage * scale;
            const y = clickY_relativeToImage * scale;

            // --- END NEW COORDINATE LOGIC ---
            
            // Save current state for undo
            const urlToRevoke = undoHistory.get(currentLightboxImageId);
            undoHistory.set(currentLightboxImageId, largeImage.src);
            undoBlurBtn.disabled = false;
            
            // Perform blur on canvas
            const tempImg = new Image();
            tempImg.crossOrigin = "anonymous"; // Handle potential canvas tainting if using object URLs
            
            tempImg.onload = () => {
                 try { // Wrap canvas operations in try-catch
                     manualBlurCanvas.width = tempImg.naturalWidth;
                     manualBlurCanvas.height = tempImg.naturalHeight;
                     manualBlurCtx.drawImage(tempImg, 0, 0); // Draw current image onto canvas
                     manualBlurCtx.filter = `blur(${MANUAL_BLUR_INTENSITY}px)`;
                     
                     // Use the UNscaled blur radius for drawing on the full-res canvas
                     const blurRadius = MANUAL_BLUR_RADIUS;
                     const effectiveX = Math.max(0, x - blurRadius);
                     const effectiveY = Math.max(0, y - blurRadius);
                     const effectiveWidth = Math.min(blurRadius * 2, tempImg.naturalWidth - effectiveX);
                     const effectiveHeight = Math.min(blurRadius * 2, tempImg.naturalHeight - effectiveY);
                     
                     if (effectiveWidth > 0 && effectiveHeight > 0) {
                         // Draw the blurred portion from the already-blurred canvas *back onto itself*
                         // This applies the blur only to the target area
                         manualBlurCtx.drawImage(manualBlurCanvas,
                            effectiveX, effectiveY, effectiveWidth, effectiveHeight,
                            effectiveX, effectiveY, effectiveWidth, effectiveHeight);
                     }
                     manualBlurCtx.filter = 'none'; // Reset filter IMPORTANT!
                     
                     // Update images
                     manualBlurCanvas.toBlob(newBlob => {
                          if (!newBlob) {
                               throw new Error("Canvas toBlob failed to create a blob.");
                          }
                         const newUrl = URL.createObjectURL(newBlob);
                         largeImage.src = newUrl; // Update lightbox image
                         thumbnail.src = newUrl; // Update gallery thumbnail
                         updateLightboxGallery(); // Update lightbox gallery thumbnail
                         if (urlToRevoke) {
                             URL.revokeObjectURL(urlToRevoke); // Clean up old undo URL
                         }
                     }, 'image/jpeg', 0.9); // Quality setting for JPEG
                 } catch (canvasError) {
                      console.error("Error during canvas blur operation:", canvasError);
                      showCustomAlert("An error occurred while applying the blur.",'error');
                      // Revert undo state if canvas fails
                      undoHistory.delete(currentLightboxImageId);
                      if (urlToRevoke) undoHistory.set(currentLightboxImageId, urlToRevoke); // Put old one back
                      undoBlurBtn.disabled = !undoHistory.has(currentLightboxImageId);
                 }
            };
            tempImg.onerror = () => {
                 console.error("Failed to load image into temp canvas for blurring.");
                  showCustomAlert("Error loading image for manual blur.",'error');
                 // Revert undo state if load fails
                 undoHistory.delete(currentLightboxImageId);
                 if (urlToRevoke) undoHistory.set(currentLightboxImageId, urlToRevoke); // Put old one back
                 undoBlurBtn.disabled = !undoHistory.has(currentLightboxImageId);
            }
            tempImg.src = largeImage.src; // Must set src AFTER onload/onerror are defined
        }
        
        function handleUndoBlur() {
            const lastStateUrl = undoHistory.get(currentLightboxImageId);
            if (lastStateUrl) {
                const largeImage = document.getElementById('lightboxImage');
                const thumbnail = document.getElementById(currentLightboxImageId);
                if (!thumbnail) return;
                const currentUrl = thumbnail.src; // URL to revoke AFTER applying the old one
                largeImage.src = lastStateUrl;
                thumbnail.src = lastStateUrl;
                undoHistory.delete(currentLightboxImageId); // Remove the undone state
                undoBlurBtn.disabled = true; // Disable undo until next blur
                updateLightboxGallery();
                // Revoke the URL that is no longer used
                setTimeout(() => URL.revokeObjectURL(currentUrl), 100);
            }
        }
        async function handleDeleteLightboxImage() {
            if (!currentLightboxImageId) return;
            if (!await showCustomConfirm('Are you sure you want to delete this image?')) return;
            const item = document.getElementById(currentLightboxImageId)?.closest('.gallery-item');
            const img = document.getElementById(currentLightboxImageId);
            if (!item || !img) return;
            const imgUrl = img.src;
            const fileName = window.originalFileNames.get(currentLightboxImageId);
            if (fileName) {
                const resultIndex = imageResults.findIndex(res => res.fileName === fileName);
                if (resultIndex > -1) imageResults.splice(resultIndex, 1);
            }
            window.originalFileNames.delete(currentLightboxImageId);
            // Clean up undo history for the deleted image
            const undoUrl = undoHistory.get(currentLightboxImageId);
            if (undoUrl) URL.revokeObjectURL(undoUrl);
            undoHistory.delete(currentLightboxImageId);
            // Clean up risk data
            window.riskAssessmentData.delete(currentLightboxImageId);
            // Remove from gallery
            item.remove();
            updateResults();
            
            // Try to show next image, if not possible, close lightbox
            const galleryImages = Array.from(galleryDiv.querySelectorAll('.gallery-item img'));
            if(galleryImages.length > 0) {
                 const currentIndex = galleryImages.findIndex(gImg => gImg.id === currentLightboxImageId); // Find index *before* removing
                 const nextIndex = currentIndex >= galleryImages.length ? 0 : currentIndex; // Show next or first if last was deleted
                 showLightboxImage(galleryImages[nextIndex].id);
             } else {
                 closeLightboxFunc();
             }
            // Update main gallery display if it becomes empty
            if (galleryDiv.children.length === 0 || (galleryDiv.children.length === 1 && galleryDiv.querySelector('p'))) {
                galleryDiv.innerHTML = '<p class="text-slate-500 col-span-full text-center">Processed images/frames will appear here...</p>';
                downloadBtn.style.display = 'none';
                document.getElementById('generateAiReportBtn').style.display = 'none';
                document.getElementById('manual-blur-info').style.display = 'none';
            }
        }
        async function generateLatexReport(imageDataArray) {
            // LaTeX generation remains the same
            let latexContent = `\\documentclass[a4paper,12pt]{article}
\\usepackage[utf8]{inputenc}
\\usepackage{graphicx}
\\usepackage{geometry}
\\geometry{margin=1in}
\\usepackage{parskip}
\\usepackage{titlesec}
\\usepackage{enumitem}
\\usepackage{xcolor}
\\usepackage{hyperref}
\\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}
\\titleformat{\\section}{\\Large\\bfseries}{\\thesection}{1em}{}
\\titleformat{\\subsection}{\\large\\bfseries}{\\thesubsection}{1em}{}
\\begin{document}
\\title{Risk Assessment Report}
\\author{}
\\date{${new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })}}
\\maketitle
\\tableofcontents
\\newpage
`;
            for (let i = 0; i < imageDataArray.length; i++) {
                const { fileName, base64, riskData } = imageDataArray[i];
                const escapeLatex = (text) => {
                    if (!text) return '';
                    return text.replace(/([\\{}#$%&_^~])/g, '\\$1')
                               .replace(/\n/g, '\\\\\\newline ');
                };
                const description = escapeLatex(riskData.description || 'No description provided.');
                const hazards = escapeLatex(riskData.hazards || 'No hazards identified.');
                const controls = escapeLatex(riskData.controls || 'No controls specified.');
                const sanitizedFileName = escapeLatex(fileName);
                latexContent += `\\section{Image ${i + 1}: ${sanitizedFileName}}
\\begin{figure}[h]
    \\centering
    \\includegraphics[width=0.9\\textwidth]{${base64}}
    \\caption{${sanitizedFileName}}
\\end{figure}
\\subsection{Description of Step}
${description}
\\subsection{What Can Go Wrong / Spot Hazards}
${hazards}
\\subsection{Existing Control Measures}
${controls}
\\newpage
`;
            }
            latexContent += `\\end{document}`;
            return latexContent;
        }
        async function generatePDFReport(imageDataArray) {
            return new Promise((resolve, reject) => {
                try {
                    const doc = new PDFDocument({ size: 'A4', margin: 50 });
                    const stream = doc.pipe(blobStream());
                    doc.fontSize(20).text('Risk Assessment Report', { align: 'center' });
                    doc.moveDown();
                    doc.fontSize(12).text(`Date: ${new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })}`, { align: 'center' });
                    doc.moveDown(2);
                    doc.fontSize(16).text('Table of Contents', { align: 'left' });
                    doc.moveDown();
                    imageDataArray.forEach((item, i) => {
                        doc.fontSize(12).text(`${i + 1}. ${item.fileName}`, { align: 'left', indent: 20 });
                        doc.moveDown(0.5);
                    });
                    
                    imageDataArray.forEach((item, i) => {
                        doc.addPage();
                        const { fileName, base64, riskData } = item;
                        const sanitizeText = (text) => text ? text.replace(/\n/g, '\n') : '';
                        const description = sanitizeText(riskData.description || 'No description provided.');
                        const hazards = sanitizeText(riskData.hazards || 'No hazards identified.');
                        const controls = sanitizeText(riskData.controls || 'No controls specified.');
                        doc.fontSize(16).text(`Image ${i + 1}: ${fileName}`, { align: 'left' });
                        doc.moveDown();
                        
                        // Use a try-catch for image embedding
                        try {
                            const maxWidth = doc.page.width - 100;
                            const maxHeight = 300;
                           
                            // --- BUG FIX ---
                            // The 'Buffer' object is from Node.js and not available in the browser.
                            // pdfkit.js in the browser can accept the base64 data URL directly.
                           
                            // REMOVED: const imageBuffer = Buffer.from(base64.split(',')[1], 'base64');
                           
                            // We need to get the image dimensions to scale it correctly.
                            // We can't do this synchronously, but we can make a best-effort guess
                            // or use the fact that the image is already loaded in the DOM.
                            // For simplicity here, we'll try to create a new image to read dimensions.
                            // A better way would be to pass dimensions from the canvas generation.
                           
                            const tempImg = new Image();
                            tempImg.src = base64; // The base64 data URL
                            
                            let imgWidth, imgHeight;

                            if (tempImg.naturalWidth && tempImg.naturalHeight) {
                               // This might work if the image is cached by the browser
                                imgWidth = tempImg.naturalWidth;
                                imgHeight = tempImg.naturalHeight;
                            } else {
                                // Fallback dimensions if naturalWidth isn't available
                                // (e.g., if this runs before the img object fully loads,
                                // though setting .src should be blocking in this context)
                                // Let's assume a standard 4:3-ish ratio if we can't read it.
                                imgWidth = 640;
                                imgHeight = 480;
                            }
                                
                            // Scale image to fit PDF
                            const aspectRatio = imgHeight / imgWidth;
                            if (imgWidth > maxWidth) {
                                imgWidth = maxWidth;
                                imgHeight = imgWidth * aspectRatio;
                            }
                            if (imgHeight > maxHeight) {
                                imgHeight = maxHeight;
                                imgWidth = imgHeight / aspectRatio;
                            }

                           // CHANGED: Pass the base64 string directly instead of a Buffer
                           doc.image(base64, { fit: [imgWidth, imgHeight], align: 'center' });
                            // --- END BUG FIX ---

                        } catch (imgError) {
                            console.error("Error embedding image in PDF:", imgError);
                            doc.text(`[Error: Could not embed image ${fileName}]`, {color: 'red'});
                        }
                        doc.moveDown();
                        doc.fontSize(14).text('Description of Step:', { align: 'left' });
                        doc.fontSize(12).text(description, { align: 'left', indent: 20 });
                        doc.moveDown();
                        doc.fontSize(14).text('What Can Go Wrong / Spot Hazards:', { align: 'left' });
                        doc.fontSize(12).text(hazards, { align: 'left', indent: 20 });
                        doc.moveDown();
                        doc.fontSize(14).text('Existing Control Measures:', { align: 'left' });
                        doc.fontSize(12).text(controls, { align: 'left', indent: 20 });
                    });
                    doc.end();
                    stream.on('finish', () => {
                        resolve(stream.toBlob('application/pdf'));
                    });
                    stream.on('error', reject);
                } catch (error) {
                    reject(error);
                }
            });
        }
        lightboxImage.addEventListener('click', handleManualBlurOnLightbox);
        undoBlurBtn.addEventListener('click', handleUndoBlur);
        deleteLightboxBtn.addEventListener('click', handleDeleteLightboxImage);
        // --- NEW: Handle Replace Image ---
        if (replaceImageBtn && replaceImageInput) {
            replaceImageBtn.addEventListener('click', () => replaceImageInput.click());

            replaceImageInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file || !currentLightboxImageId) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const newBase64 = event.target.result;

                    // 1. Update the Lightbox Preview
                    lightboxImage.src = newBase64;

                    // 2. Update the Gallery Thumbnail
                    const galleryThumb = document.getElementById(currentLightboxImageId);
                    if (galleryThumb) galleryThumb.src = newBase64;

                    // 3. Update Filename (for export)
                    if (window.originalFileNames) {
                        window.originalFileNames.set(currentLightboxImageId, file.name);
                    }
                    
                    // 4. Clear Undo History (since it's a new image)
                    undoHistory.delete(currentLightboxImageId);
                    undoBlurBtn.disabled = true;

                    // 5. Success Message
                    if(window.showCustomAlert) window.showCustomAlert("Image replaced successfully!", "success");
                };
                reader.readAsDataURL(file);
                e.target.value = ''; // Reset input
            });
        }
        // --- END NEW ---
        prevArrow.addEventListener('click', showPreviousImage);
        nextArrow.addEventListener('click', showNextImage);
        document.addEventListener('keydown', (event) => {
            if (lightboxModal.style.display === 'flex') {
                if (event.key === 'ArrowRight') showNextImage();
                else if (event.key === 'ArrowLeft') showPreviousImage();
                else if (event.key === 'Escape') closeLightboxFunc();
                else if (event.key === 'Delete') handleDeleteLightboxImage();
            }
        });
        // --- DELETE your entire, long downloadBtn.addEventListener('click', ...) function ---


/**
¬†* Reusable helper to add all gallery images to a JSZip object.
¬†* @param {JSZip} zip - An initialized JSZip instance.
¬†* @returns {Promise<{imageDataArray: Array, fetchPromises: Array, imageNameMap: Map<string, string>}>}
¬†*/
async function addImagesToZip(zip) {
    const galleryImages = Array.from(galleryDiv.querySelectorAll('.gallery-item img'));
    if (galleryImages.length === 0) {
        return { imageDataArray: [], fetchPromises: [], imageNameMap: new Map() };
    }

    // Get list of imageIds that ARE USED by NON-DELETED rows (only include these images)
    const usedImageIds = new Set();
    try {
        const allRows = document.querySelectorAll('#table-container tbody tr');
        allRows.forEach(row => {
            // Only include images from non-deleted rows
            if (!row.classList.contains('deleted-row') && row.dataset.deleted !== 'true') {
                const imageId = row.dataset.imageId;
                if (imageId) {
                    usedImageIds.add(imageId);
                    console.debug(`Adding image ${imageId} (used by non-deleted row)`);
                }
            }
        });
    } catch (e) {
        console.warn('Could not determine used images from non-deleted rows:', e);
    }

    const fetchPromises = [];
    const imageDataArray = []; // Still needed for the original PDF/LaTeX reports
    const imageNameMap = new Map(); // <<< NEW: Create the map
    const imageFolder = zip.folder("edited_images"); // Put images in a subfolder

    for (let i = 0; i < galleryImages.length; i++) {
        const imgElement = galleryImages[i];
        const imgUrl = imgElement.src;
        const originalFileName = window.originalFileNames.get(imgElement.id) || `image_${i}.jpg`;
        
    // Deterministic download filename (consistent with CSV) using helper
    const downloadFileName = createFinalFileName(originalFileName, i);

        const imgId = imgElement.id;
        const riskData = window.riskAssessmentData.get(imgId) || {};
        
        // Only include this image if it's used by at least one non-deleted row
        if (!usedImageIds.has(imgId)) {
            console.debug(`Skipping image ${downloadFileName} (not used by any non-deleted row)`);
            continue;
        }
        
        imageNameMap.set(imgId, downloadFileName); // <<< NEW: Populate the map

        const promise = fetch(imgUrl)
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return response.blob();
            })
            .then(async blob => {
                imageFolder.file(downloadFileName, blob); // Add to zip's subfolder
                
                // This part is for the old PDF/LaTeX reports
                const base64 = await new Promise((resolve, reject) => {
                   const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = (error) => reject(error);
                    reader.readAsDataURL(blob);
                });
                
                imageDataArray.push({
                    imgId: imgId,
                    fileName: downloadFileName,
                    originalFileName: originalFileName,
                    base64: base64,
                    riskData: {
                        description: riskData.description || '',
                        hazards: riskData.hazards || '',
                        controls: riskData.controls || ''
                    }
               });
            })
            .catch(error => console.error(`Failed to fetch or process ${downloadFileName}:`, error));
        
        fetchPromises.push(promise);
    }
    
    return { imageDataArray, fetchPromises, imageNameMap }; // <<< RETURN THE MAP
}// NEW, simplified listener for the ORIGINAL download button
downloadBtn.addEventListener('click', async () => {
    if (typeof JSZip === 'undefined') { 
        showCustomAlert("Error: JSZip library not loaded.", 'error'); 
        return; 
    }
    
    statusDiv.innerText = 'Preparing images and reports for download...';
    downloadBtn.disabled = true; downloadBtn.innerText = 'Zipping...';
    
    const zip = new JSZip();
    
    try {
        // 1. Add all images to the zip
        const { imageDataArray, fetchPromises } = await addImagesToZip(zip);
        await Promise.all(fetchPromises);
        
        // 2. Add the specific reports for THIS download button (LaTeX, old PDF, etc.)
        if (imageDataArray.length > 0) {
            // (Your existing code for generating LaTeX, JSON, and the *image-notes* PDF)
            try {
                const latexContent = await generateLatexReport(imageDataArray);
                zip.file("risk_assessment_report.tex", latexContent);
            } catch (latexError) {
                console.error("Error generating LaTeX report:", latexError);
                zip.file("ERROR_generating_latex_report.txt", `Error: ${latexError.message}`);
            }

            const jsonData = JSON.stringify(
                imageDataArray.reduce((acc, item) => {
                    acc[item.fileName] = {
                        originalName: window.originalFileNames.get(item.fileName.replace(/^final_\d+_/, '').replace(/(\.[^.]+)$/, '')) || item.fileName,
                        description: item.riskData.description,
                        hazards: item.riskData.hazards,
                        controls: item.riskData.controls
                    };
                    return acc;
                }, {}),
                null, 2
            );
            zip.file("risk_assessment_data.json", jsonData);
            
            if (typeof PDFDocument !== 'undefined' && typeof blobStream !== 'undefined') {
                try {
                    const pdfBlob = await generatePDFReport(imageDataArray);
                    zip.file("risk_assessment_report.pdf", pdfBlob);
                } catch (error) {
                    console.error("Error generating PDF:", error);
                    zip.file("ERROR_generating_pdf_report.txt", `Error: ${error.message}`);
                }
            }
        }
        
        // 3. Generate and download the zip
        if (Object.keys(zip.files).length === 0) {
            statusDiv.innerText = `Failed to prepare any files for download.`;
            return;
        }

        const content = await zip.generateAsync({ type: "blob" });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = "risk_assessment_package.zip";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => URL.revokeObjectURL(link.href), 1000);
        statusDiv.innerText = 'ZIP download started!';

    } catch (error) {
        console.error("Error generating download ZIP:", error);
        statusDiv.innerText = 'Error generating ZIP file.';
    } finally {
        downloadBtn.disabled = false; downloadBtn.innerText = 'Download All Images and Reports as ZIP';
    }
});
// EXPOSE THE HELPER FUNCTION GLOBALLY
    window.addImagesToZip = addImagesToZip;
    // --- Speech-to-Text Feature ---
let recognition = null;
let currentTarget = null;
const speechBtns = document.querySelectorAll('.speech-btn');

function initSpeechRecognition() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
        speechBtns.forEach(btn => btn.style.display = 'none');
        console.warn("Speech Recognition not supported in this browser.");
        showCustomAlert("Speech-to-text is not supported in your browser. Try Chrome for best results.", 'info');
        return false;
    }
    recognition = new SpeechRecognition();
    recognition.lang = 'en-US'; // Default to English; can be changed based on translate if needed
    recognition.interimResults = false; // Only final results
    recognition.maxAlternatives = 1;

    recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        if (currentTarget) {
            currentTarget.value += (currentTarget.value ? ' ' : '') + transcript;
            // Trigger input event to save (your existing saveRiskData)
            currentTarget.dispatchEvent(new Event('input'));
        }
    };

    recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        showCustomAlert('Speech recognition error: ' + event.error, 'error');
        stopRecognition();
    };

    recognition.onend = () => {
        stopRecognition();
    };

    return true;
}

function startRecognition(targetTextarea) {
    if (!recognition) return;
    currentTarget = targetTextarea;
    recognition.start();
    // Update all buttons (only the active one changes)
    speechBtns.forEach(btn => {
        if (btn.dataset.target === targetTextarea.id) {
            btn.classList.add('bg-red-600', 'hover:bg-red-700');
            // Change to stop icon
            btn.querySelector('svg').innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z" />';
        }
    });
}

function stopRecognition() {
    if (!recognition) return;
    recognition.stop();
    currentTarget = null;
    // Reset buttons
    speechBtns.forEach(btn => {
        btn.classList.remove('bg-red-600', 'hover:bg-red-700');
        // Reset to mic icon
        btn.querySelector('svg').innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />';
    });
}

// Attach click handlers to buttons
speechBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        const targetId = btn.dataset.target;
        const targetTextarea = document.getElementById(targetId);
        if (!targetTextarea) return;

        if (currentTarget === targetTextarea) {
            stopRecognition();
        } else {
            if (currentTarget) stopRecognition(); // Stop any active
            startRecognition(targetTextarea);
        }
    });
});

// Initialize speech recognition when DOM is ready (or lightbox opens)
document.addEventListener('DOMContentLoaded', initSpeechRecognition);

// --- Save/Load Project Feature ---
async function saveProject() {
    if (galleryDiv.querySelectorAll('.gallery-item img').length === 0) {
        showCustomAlert("No images or notes to save.", 'info');
        return;
    }
    const projectData = {
        version: '1.0',
        images: [],
        riskData: Array.from(window.riskAssessmentData),
        tableData: window.extractTableData ? window.extractTableData() : null
    };
    
    const galleryImages = Array.from(galleryDiv.querySelectorAll('.gallery-item img'));
    const imagePromises = galleryImages.map(async (img) => {
        const response = await fetch(img.src);
        const blob = await response.blob();
        const base64 = await new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
        });
        return {
            id: img.id,
            originalName: window.originalFileNames.get(img.id) || 'unknown.jpg',
            base64: base64
        };
    });
    
    projectData.images = await Promise.all(imagePromises);

    // Persist deleted-row state if table exists
    try {
        const tableState = projectData.tableData;
        if (tableState && document.querySelector('#table-container table')) {
            const deleted = [];
            document.querySelectorAll('#table-container tbody tr').forEach(tr => {
                if (tr.classList.contains('deleted-row') || tr.dataset.deleted === 'true') {
                    deleted.push(tr.dataset.rowIndex);
                }
            });
            tableState.deletedRows = deleted;
            projectData.tableData = tableState;
        }
    } catch (e) {
        console.warn('Could not persist deleted rows state:', e);
    }
    
    const jsonBlob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(jsonBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'risk_project.json';
    link.click();
    URL.revokeObjectURL(url);
    showCustomAlert("Project saved as JSON!", 'success');
}

async function loadProject(file) {
    try {
        const text = await file.text();
        const projectData = JSON.parse(text);
        
        galleryDiv.innerHTML = '';
        window.originalFileNames.clear();
        window.riskAssessmentData.clear();
        undoHistory.clear();
        imageResults = [];
        
        for (const imgData of projectData.images) {
            const blob = await fetch(imgData.base64).then(res => res.blob());
            const imageUrl = URL.createObjectURL(blob);
            window.originalFileNames.set(imgData.id, imgData.originalName);
            
            const container = document.createElement('div');
            container.className = 'gallery-item relative w-full pt-[100%] h-0 cursor-grab';
            container.id = `gallery-item-${imgData.id}`;
            container.draggable = true;
            
            const imgElement = document.createElement('img');
            imgElement.src = imageUrl;
            imgElement.alt = `Loaded ${imgData.originalName}`;
            imgElement.id = imgData.id;
            imgElement.className = "absolute top-0 left-0 w-full h-full object-cover rounded-lg shadow-md cursor-pointer transition-transform duration-200 hover:scale-105";
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-btn absolute top-1.5 right-1.5 z-10 bg-black/60 text-white w-5 h-5 rounded-full text-xs font-bold leading-none flex items-center justify-center hover:bg-red-600 transition';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.title = 'Delete this image';
            
            container.appendChild(imgElement);
            container.appendChild(deleteBtn);
            galleryDiv.appendChild(container);
            
            imageResults.push({ fileName: imgData.originalName, faceCount: 'Loaded' });
        }
        
        projectData.riskData.forEach(([id, data]) => {
            window.riskAssessmentData.set(id, data);
        });
        
        if (projectData.tableData && window.buildTableFromData) {
    const dashboardContainer = document.getElementById('dashboard-container');
    if (dashboardContainer) dashboardContainer.style.display = 'block';
    window.buildTableFromData(projectData.tableData.rows);
    if (window.populatePictureColumn) window.populatePictureColumn();
    if (window.initializeDashboard) window.initializeDashboard();
    if (window.updateAllCategoryColors) window.updateAllCategoryColors();
    if (window.updateDashboardMetrics) window.updateDashboardMetrics();
    // Restore deleted-row state saved in project JSON
    try {
        const deleted = projectData.tableData && projectData.tableData.deletedRows ? projectData.tableData.deletedRows : [];
        if (Array.isArray(deleted) && deleted.length > 0) {
            deleted.forEach(idx => {
                const row = document.querySelector(`#table-container tr[data-row-index="${idx}"]`);
                if (row) {
                    row.classList.add('deleted-row');
                    row.dataset.deleted = 'true';
                    // Update the button UI in the Delete cell (last td)
                    const delBtn = row.querySelector('td:last-child button');
                    if (delBtn) {
                        delBtn.textContent = 'Restore';
                        delBtn.className = 'restore-btn';
                        delBtn.title = 'Restore row';
                    }
                    // Also disable row controls so struck appearance is accurate
                    try {
                        const controls = Array.from(row.querySelectorAll('select, input, textarea, button'));
                        controls.forEach(control => {
                            if (control === delBtn) return;
                            control.setAttribute('disabled', 'true');
                            control.style.opacity = '0.6';
                            control.style.pointerEvents = 'none';
                        });
                    } catch (e) {
                        console.warn('Error restoring deleted row controls:', e);
                    }
                }
            });
        }
    } catch (e) {
        console.warn('Could not restore deleted rows from project file:', e);
    }
}
        
        updateResults();
        downloadBtn.style.display = 'block';
        document.getElementById('generateAiReportBtn').style.display = 'block';
        document.getElementById('manual-blur-info').style.display = 'block';
        document.getElementById('saveProjectBtn').style.display = 'block';
        
        // Switch to Rich Media tab to show loaded images
        if (window.switchTab) {
            window.switchTab('rich-media');
        }
        
        showCustomAlert("Project loaded successfully!", 'success');
    } catch (error) {
        console.error("Error loading project:", error);
        showCustomAlert("Failed to load project: Invalid file.", 'error');
    }
}

// Attach listeners
document.getElementById('saveProjectBtn').addEventListener('click', saveProject);
document.getElementById('loadProjectBtn').addEventListener('click', () => document.getElementById('projectFileInput').click());
document.getElementById('projectFileInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) loadProject(file);
    e.target.value = '';
});



    })(); // End of App 2's isolated scope

// Debug helper to see image matching status
window.debugImageMatching = function() {
    const results = {
        galleryImages: [],
        tableRows: [],
        matches: []
    };
    
    // 1. Gallery status
    const gallery = Array.from(document.querySelectorAll('.gallery-item img'));
    gallery.forEach(img => {
        results.galleryImages.push({
            id: img.id,
            originalName: window.originalFileNames.get(img.id),
            hasRiskData: window.riskAssessmentData.has(img.id),
            description: window.riskAssessmentData.get(img.id)?.description || ''
        });
    });
    
    // 2. Table row status
    const rows = Array.from(document.querySelectorAll('#table-container tbody tr'));
    rows.forEach(row => {
        const pictureCell = row.querySelector('.picture-cell');
        const stepCell = row.querySelector('td:nth-child(2)');
        results.tableRows.push({
            dataImageId: row.dataset.imageId,
            stepText: stepCell?.textContent || '',
            pictureCellDataFilename: pictureCell?.dataset.filename,
            hasThumbnail: !!pictureCell?.querySelector('img')
        });
    });

    // 3. Check matches
    rows.forEach((row, idx) => {
        const imageId = row.dataset.imageId;
        const stepText = row.querySelector('td:nth-child(2)')?.textContent || '';
        const match = {
            rowIndex: idx,
            stepText: stepText,
            imageId: imageId,
            matchType: '',
            foundImage: false
        };

        if (imageId && document.getElementById(imageId)) {
            match.matchType = 'direct';
            match.foundImage = true;
        } else if (stepText) {
            // Try matching by description
            for (const img of gallery) {
                const riskData = window.riskAssessmentData.get(img.id);
                if (riskData?.description && (
                    riskData.description.toLowerCase().includes(stepText.toLowerCase()) ||
                    stepText.toLowerCase().includes(riskData.description.toLowerCase())
                )) {
                    match.matchType = 'description';
                    match.foundImage = true;
                    match.matchedImageId = img.id;
                    break;
                }
            }
        }
        results.matches.push(match);
    });

    console.log('=== Image Matching Debug Info ===');
    console.log('Gallery Images:', results.galleryImages);
    console.log('Table Rows:', results.tableRows);
    console.log('Matches:', results.matches);
    return results;
};

// --- Compatibility override: Robust CSV generator to ensure Picture column is populated ---
// This wrapper will replace earlier implementations at runtime and provide multiple
// fallbacks when imageId mappings are missing (match by thumbnail src, picture cell
// dataset, or synthesize a deterministic filename).
window.generateRiskTableCSV = function(imageNameMap = new Map()) {
    const table = document.querySelector('#table-container table');
    if (!table) {
        console.error('CSV Export Error: Could not find the risk assessment table.');
        throw new Error('Could not find the table data to export.');
    }

    // Build a merged image name map (originalFileNames + provided imageNameMap)
    try {
        const merged = new Map();
        const galleryImgs = Array.from(document.querySelectorAll('.gallery-item img'));

        if (window.originalFileNames) {
            window.originalFileNames.forEach((orig, id) => {
                const idx = Math.max(0, galleryImgs.findIndex(img => img.id === id));
                merged.set(id, createFinalFileName(orig, idx));
            });
        }

        if (imageNameMap && imageNameMap.size > 0) {
            imageNameMap.forEach((fname, id) => merged.set(id, fname));
        }

        imageNameMap = merged;
        console.log('imageNameMap for CSV:', Array.from(imageNameMap));
    } catch (e) {
        console.warn('Error while building imageNameMap for CSV:', e);
    }

    const headerCells = Array.from(table.querySelector('thead tr').querySelectorAll('th'));
    const headers = headerCells.map(th => th.innerText.trim());

    const csv = [];
    csv.push(headers.map(h => `"${h.replace(/"/g, '""')}"`).join(','));

    const galleryImages = Array.from(document.querySelectorAll('.gallery-item img'));

    table.querySelectorAll('tbody tr').forEach(row => {
        const cells = row.querySelectorAll('td');
        const parts = [];

        headers.forEach((header, colIndex) => {
            const cell = cells[colIndex];
            if (!cell) { parts.push('""'); return; }

            if (header === 'Picture') {
                const imageId = row.dataset.imageId || '';
                let filename = '';

                // 1) direct mapping from merged map
                if (imageId && imageNameMap && imageNameMap.has(imageId)) {
                    filename = imageNameMap.get(imageId);
                }

                // 2) originalFileNames fallback
                if (!filename && window.originalFileNames && window.originalFileNames.has(imageId)) {
                    const orig = window.originalFileNames.get(imageId);
                    const idx = Math.max(0, galleryImages.findIndex(img => img.id === imageId));
                    filename = createFinalFileName(orig, idx);
                }

                // 3) picture cell dataset (set when table was populated)
                if (!filename) {
                    const pictureCell = row.querySelector('.picture-cell');
                    if (pictureCell && pictureCell.dataset && pictureCell.dataset.filename) {
                        const orig = pictureCell.dataset.filename;
                        const idx = parseInt(row.dataset.rowIndex, 10) || 0;
                        filename = createFinalFileName(orig, idx);
                    }
                }

                // 4) try to match by thumbnail src
                if (!filename) {
                    const pictureCell = row.querySelector('.picture-cell');
                    const imgTag = pictureCell ? pictureCell.querySelector('img') : null;
                    if (imgTag && imgTag.src) {
                        const match = galleryImages.find(g => g.src === imgTag.src || g.src === imgTag.getAttribute('data-src'));
                        if (match) {
                            const matchedId = match.id;
                            filename = (imageNameMap && imageNameMap.get(matchedId)) || (window.originalFileNames && window.originalFileNames.get(matchedId)) || matchedId;
                            if (window.originalFileNames && window.originalFileNames.get(matchedId)) {
                                filename = createFinalFileName(window.originalFileNames.get(matchedId), Math.max(0, galleryImages.indexOf(match)));
                            }
                        }
                    }
                }

                // 5) final fallback: synthesize from first gallery image or imageId
                if (!filename) {
                    if (galleryImages.length > 0) {
                        const g0 = galleryImages[0];
                        const orig = (window.originalFileNames && window.originalFileNames.get(g0.id)) || g0.id || imageId || '';
                        filename = orig ? createFinalFileName(orig, 0) : '';
                    }
                }

                parts.push(`"${(filename || '').replace(/"/g, '""')}"`);
                return;
            }

            // Generic cell types: select, input, textarea, or plain text
            let value = '';
            const sel = cell.querySelector('select');
            const inp = cell.querySelector('input');
            const ta = cell.querySelector('textarea');
            if (sel) value = sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].text : sel.value;
            else if (inp) value = inp.value;
            else if (ta) value = ta.value;
            else value = cell.innerText.trim();

            parts.push(`"${(value || '').replace(/\r?\n|\r/g, ' ').replace(/"/g, '""')}"`);
        });

        csv.push(parts.join(','));
    });

    if (csv.length <= 1) throw new Error('No data available in the table to export.');
    return csv.join('\n');
};
    // --- !!! INTEGRATION SCRIPT ---
downloadBtn.addEventListener('click', async () => {
});
    document.getElementById('generateAiReportBtn').addEventListener('click', async () => {  // Add 'async' for awaits
    if (!window.riskAssessmentData || window.riskAssessmentData.size === 0) {
        showCustomAlert("No risk assessment notes found. Please add notes to your images in the lightbox preview first.");
        return;
    }

    const galleryImages = Array.from(document.querySelectorAll('#face-blurrer-app #imageGallery .gallery-item img'));
    const entries = [];  // Array of per-image entries
    galleryImages.forEach(imgElement => {
        const imgId = imgElement.id;
        const riskData = window.riskAssessmentData.get(imgId);
        if (riskData && (riskData.description?.trim() || riskData.hazards?.trim() || riskData.controls?.trim())) {
            // Build user ratings context if available
            let userRatingsContext = '';
            if (riskData.userFrequency || riskData.userSeverity || riskData.userLikelihood) {
                userRatingsContext = `\nUSER RATINGS (Keep these as primary values): Frequency=${riskData.userFrequency || 'not set'}, Severity=${riskData.userSeverity || 'not set'}, Likelihood=${riskData.userLikelihood || 'not set'}\n`;
            }
            
            const entryText = `--- ENTRY (ImageID: ${imgId}) ---\n` +
                              `STEP/DESCRIPTION: ${riskData.description || 'N/A'}\n` +
                              `HAZARDS: ${riskData.hazards || 'N/A'}\n` +
                              `CONTROLS: ${riskData.controls || 'N/A'}` +
                              userRatingsContext + '\n';
            entries.push(entryText);
        }
    });

    if (entries.length === 0) {
        showCustomAlert("No risk assessment notes found. Please add notes (description, hazards, or controls) to your images.");
        return;
    }

    // Chunk the entries (e.g., 5 per batch)
    const BATCH_SIZE = 2;
    const batches = [];
    for (let i = 0; i < entries.length; i += BATCH_SIZE) {
        batches.push(entries.slice(i, i + BATCH_SIZE).join(''));
    }

    // Show the risk section
    const dashboardContainer = document.getElementById('dashboard-container');
    if (dashboardContainer) dashboardContainer.style.display = 'block';
    
    // Now process batches and populate table
    await processBatchesAndPopulateTable(batches);
});
    // --- Custom Alert/Confirm Functions ---
¬† ¬† // (Replace native alert/confirm for better UX and consistency)
¬† ¬† 
¬† ¬† /**
¬† ¬†  * Shows a non-blocking toast notification.
¬† ¬†  * @param {string} message The text to display.
¬† ¬†  * @param {string} type 'info' (default), 'success', or 'error'.
¬† ¬†  */
    function showCustomAlert(message, type = 'info') {
        const container = document.getElementById('toast-container');
        if (!container) return; // Fail silently if container not found

        let bgColor, iconSVG;
        switch (type) {
            case 'success':
                bgColor = 'bg-green-100 border-green-400 text-green-800';
                iconSVG = `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>`;
                break;
            case 'error':
                bgColor = 'bg-red-100 border-red-400 text-red-800';
                iconSVG = `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>`;
                break;
            default: // 'info'
                bgColor = 'bg-blue-100 border-blue-400 text-blue-800';
                iconSVG = `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>`;
                break;
        }

        const toast = document.createElement('div');
        toast.className = `flex items-center p-4 rounded-lg shadow-lg border ${bgColor} transition-all duration-300 opacity-0 translate-x-10`;
        toast.innerHTML = `
            <div class="flex-shrink-0">${iconSVG}</div>
            <div class="ml-3 text-sm font-medium flex-1">${message}</div>
            <button type="button" class="ml-auto -mx-1.5 -my-1.5 p-1.5 rounded-full inline-flex hover:bg-black/10 transition" onclick="this.parentElement.remove()" title="Close">
                <span class="sr-only">Close</span>
                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
            </button>
        `;
        
        container.appendChild(toast);
        
        // Animate in
        setTimeout(() => {
            toast.classList.remove('opacity-0', 'translate-x-10');
        }, 10);

        // Auto-dismiss after 5 seconds
        setTimeout(() => {
            toast.classList.add('opacity-0');
            setTimeout(() => toast.remove(), 500); // Remove from DOM after fade out
        }, 5000);
    }¬† ¬† /**
¬† ¬†  * Shows a blocking confirmation modal.
¬† ¬†  * @param {string} message The confirmation question.
¬† ¬†  * @returns {Promise<boolean>} Resolves true if confirmed, false if canceled.
¬† ¬†  */
¬† ¬† function showCustomConfirm(message) {
¬† ¬† ¬† ¬† return new Promise(resolve => {
¬† ¬† ¬† ¬† ¬† ¬† const modal = document.getElementById('confirmModal');
¬† ¬† ¬† ¬† ¬† ¬† const msgEl = document.getElementById('confirmMessage');
¬† ¬† ¬† ¬† ¬† ¬† const okBtn = document.getElementById('confirmOkBtn');
¬† ¬† ¬† ¬† ¬† ¬† const cancelBtn = document.getElementById('confirmCancelBtn');

¬† ¬† ¬† ¬† ¬† ¬† if (!modal || !msgEl || !okBtn || !cancelBtn) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.error("Confirm modal elements not found!");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† resolve(false); // Failsafe
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† msgEl.textContent = message;
¬† ¬† ¬† ¬† ¬† ¬† modal.style.display = 'flex';

¬† ¬† ¬† ¬† ¬† ¬† // We must clone and replace buttons to remove old listeners
¬† ¬† ¬† ¬† ¬† ¬† const newOkBtn = okBtn.cloneNode(true);
¬† ¬† ¬† ¬† ¬† ¬† okBtn.parentNode.replaceChild(newOkBtn, okBtn);

¬† ¬† ¬† ¬† ¬† ¬† const newCancelBtn = cancelBtn.cloneNode(true);
¬† ¬† ¬† ¬† ¬† ¬† cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

¬† ¬† ¬† ¬† ¬† ¬† newOkBtn.onclick = () => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† modal.style.display = 'none';
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† resolve(true);
¬† ¬† ¬† ¬† ¬† ¬† };
¬† ¬† ¬† ¬† ¬† ¬† 
¬† ¬† ¬† ¬† ¬† ¬† newCancelBtn.onclick = () => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† modal.style.display = 'none';
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† resolve(false);
¬† ¬† ¬† ¬† ¬† ¬† };
¬† ¬† ¬† ¬† ¬† ¬† 
¬† ¬† ¬† ¬† ¬† ¬† // Also allow closing by clicking overlay
¬† ¬† ¬† ¬† ¬† ¬† modal.onclick = (e) => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (e.target === modal) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† modal.style.display = 'none';
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† resolve(false);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† };
¬† ¬† ¬† ¬† });
¬† ¬† }
</script>
<div id="excelImportModal" class="gy-modal-overlay" style="display:none;">
    <div class="gy-modal-content">
        <button class="gy-close-modal" onclick="document.getElementById('excelImportModal').style.display='none'">√ó</button>
        
        <h2 style="text-align:center; color:#2c3e50; margin-top:0;">Goodyear RA ‚Üí JSON Converter</h2>
        <p style="text-align:center; color:#7f8c8d; margin-bottom:20px;">Universal Tool: Images, Text-Only & Manual Uploads</p>

        <div class="gy-dashboard">
            <div id="gyDropZone" class="gy-dropzone">
                <div style="font-size: 40px;">üìÇ</div>
                <h3>Drop Excel File</h3>
                <p>Drag & Drop here</p>
                <p class="text-emerald-600/70 text-sm">.xlsx, .csv or .json (Project)</p>
            </div>



            <div class="gy-mapper-box">
                <div class="gy-mapper-header">
                    <h4>Column Mapping</h4>
                    <button id="gyRefreshBtn" type="button">‚Üª Refresh Data</button>
                </div>
                <div class="gy-mapper-grid">
                    <div class="gy-map-field"><label>Step No</label><input type="text" id="gyColStep" placeholder="A" oninput="this.value=this.value.toUpperCase()"></div>
                    <div class="gy-map-field"><label>Desc</label><input type="text" id="gyColDesc" placeholder="B" oninput="this.value=this.value.toUpperCase()"></div>
                    <div class="gy-map-field"><label>Haz Group</label><input type="text" id="gyColHazGroup" placeholder="C" oninput="this.value=this.value.toUpperCase()"></div>
                    <div class="gy-map-field"><label>Haz List</label><input type="text" id="gyColHazList" placeholder="D" oninput="this.value=this.value.toUpperCase()"></div>
                    <div class="gy-map-field"><label>Risk</label><input type="text" id="gyColRisk" placeholder="E" oninput="this.value=this.value.toUpperCase()"></div>
                    <div class="gy-map-field"><label>Controls</label><input type="text" id="gyColControl" placeholder="H" oninput="this.value=this.value.toUpperCase()"></div>
                    <div class="gy-map-field"><label>Frequency</label><input type="text" id="gyColFrequency" placeholder="" oninput="this.value=this.value.toUpperCase()"></div>
                    <div class="gy-map-field"><label>Severity</label><input type="text" id="gyColSeverity" placeholder="" oninput="this.value=this.value.toUpperCase()"></div>
                    <div class="gy-map-field"><label>Likelihood</label><input type="text" id="gyColLikelihood" placeholder="" oninput="this.value=this.value.toUpperCase()"></div>
                </div>
            </div>
        </div>

<input type="file" id="gyFileInput" accept=".xlsx, .xls, .json" style="display:none">
        <div id="gyStatus" class="text-center text-sm font-semibold text-slate-500 py-2"></div>

        <div class="gy-split-container">
            
            <div class="gy-source-panel" id="gySourcePanel" style="display:none;">
                <div class="flex justify-between items-center mb-2">
                    <h4 class="font-bold text-slate-700 text-sm">Source Images <span id="gyImgCount" class="font-normal text-xs text-slate-500"></span></h4>
                    <button onclick="gyDownloadAllImages()" class="text-xs text-emerald-600 hover:underline">Download All</button>
                </div>
                <p class="text-xs text-slate-400 mb-3">Drag & Drop to cards on the right</p>
                
                <div id="gySourceGrid" class="gy-source-scroll">
                    </div>
            </div>

            <div class="gy-cards-panel" id="gyCardsPanel">
                <div class="flex justify-between items-center px-2 mb-4 sticky top-0 bg-white z-10 pb-2 border-b border-slate-100">
                    <h4 class="font-bold text-slate-700 text-sm uppercase tracking-wider">Steps Preview</h4>
                    <button onclick="gyAddEmptyStep()" class="btn-indigo py-1.5 px-3 text-xs shadow-sm flex items-center">
                        <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M12 4v16m8-8H4"></path></svg>
                        Add Step
                    </button>
                </div>
                
                <div class="scroll-zone scroll-top"></div>
                <div id="gyResult" class="gy-grid-container"></div> <div class="scroll-zone scroll-bottom"></div>
            </div>

        </div>
        <div class="pt-8 mt-auto border-t-2 border-slate-200 flex justify-end gap-4 items-center">
            <button id="gyExportBtn" style="display:none;" class="btn-white">üíæ Save Project (JSON)</button>
            <button id="gyForwardBtn" style="display:none;" class="btn-indigo">‚úì Load as New Project</button>
        </div>
    </div>
</div>

<script>
(function() { // Enclose in IIFE to protect existing app scope
    let gyZip = null;
    let gySheetDoc = null;
    let gyStrings = [];
    let gyFilename = "";
    let gyImagesByRow = {}; 
    let gyFullData = [];
    let gyAllSourceImages = []; // Store all found images

    const dropZone = document.getElementById('gyDropZone');
    const fileInput = document.getElementById('gyFileInput');
    const statusEl = document.getElementById('gyStatus');
    const refreshBtn = document.getElementById('gyRefreshBtn');
    const exportBtn = document.getElementById('gyExportBtn');
    const forwardBtn = document.getElementById('gyForwardBtn');

    // Event Listeners
    dropZone.onclick = () => fileInput.click();
    fileInput.onchange = e => loadFile(e.target.files[0]);
    dropZone.ondragover = e => { e.preventDefault(); dropZone.style.background = '#e1f0fa'; };
    dropZone.ondragleave = e => { e.preventDefault(); dropZone.style.background = '#f0f8ff'; };
    dropZone.ondrop = e => { e.preventDefault(); loadFile(e.dataTransfer.files[0]); };
    refreshBtn.onclick = () => reprocessData();
    exportBtn.onclick = () => downloadJSON();

    // Connect Excel Tab file input to modal
    const excelUploadInput = document.getElementById('excelUpload');
    if (excelUploadInput) {
        excelUploadInput.addEventListener('change', e => {
            if (e.target.files && e.target.files[0]) {
                // Open the modal
                document.getElementById('excelImportModal').style.display = 'flex';
                // Trigger the file load through gyFileInput
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(e.target.files[0]);
                fileInput.files = dataTransfer.files;
                loadFile(e.target.files[0]);
            }
        });
    }

    // Expose global helpers for HTML onClick attributes
    window.gyRemoveRow = (id) => {
        gyFullData = gyFullData.filter(i => i.id !== id);
        document.getElementById(`card-${id}`).remove();
        statusEl.textContent = `‚úì ${gyFullData.length} steps remaining.`;
    };
    
    window.gyUpdateItem = (id, key, val) => {
        const item = gyFullData.find(i => i.id === id);
        if(item) item[key] = val;
    };

    window.gyManualUpload = (id, input) => {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const item = gyFullData.find(i => i.id === id);
                if(item) {
                    item.base64 = e.target.result;
                    item.originalName = input.files[0].name;
                    renderCardImage(item);
                }
            };
            reader.readAsDataURL(input.files[0]);
        }
    };

    // --- NEW: Add Empty Step Function ---
    window.gyAddEmptyStep = () => {
        const newId = `manual-${Date.now()}`;
        // Calculate next row number
        const maxRow = gyFullData.length > 0 
            ? Math.max(...gyFullData.map(i => parseInt(i.row) || 0)) 
            : 0;
        const nextRow = maxRow + 1;

        // Add empty item
        gyFullData.push({
            id: newId,
            row: nextRow,
            step: "",
            desc: "",
            hazards: "",
            controls: "",
            base64: null, // Triggers "Add Photo" placeholder
            originalName: `manual_step_${nextRow}.jpg`
        });

        renderUI(); // Update view

        // Scroll to bottom
        const container = document.getElementById('gyResult');
        setTimeout(() => container.scrollTop = container.scrollHeight, 50);
        
        // Update status and buttons
        if(statusEl) statusEl.textContent = `‚úì Added new step. Total: ${gyFullData.length}`;
        const hasData = true;
        if(exportBtn) exportBtn.style.display = 'block';
        if(forwardBtn) forwardBtn.style.display = 'block';
    };

async function loadFile(file) {
        if(!file) return;
        gyFilename = file.name;

        // 1. NEW: Handle Project JSON File
        if (file.name.toLowerCase().endsWith('.json')) {
            statusEl.textContent = 'Loading Project...';
            statusEl.style.color = '#3b82f6'; // Blue
            await loadGyProject(file);
            return;
        }

        // 2. Existing Excel Logic
        statusEl.textContent = 'Parsing Excel file...';
        statusEl.style.color = '#333';
        gyImagesByRow = {}; 
        gyFullData = []; 
        gyAllSourceImages = []; // Clear gallery
        
        try {
            gyZip = await JSZip.loadAsync(file);
            const strXml = await gyZip.file("xl/sharedStrings.xml")?.async("text") || "";
            gyStrings = parseSharedStrings(strXml);
            
            const parser = new DOMParser();
            let bestSheetIdx = 1, maxScore = -1;
            for(let i=1; i<=10; i++) {
                const path = `xl/worksheets/sheet${i}.xml`;
                if(gyZip.file(path)) {
                    const xml = await gyZip.file(path).async("text");
                    const doc = parser.parseFromString(xml, "text/xml");
                    let score = scoreSheet(doc, gyStrings);
                    if(score > maxScore) { maxScore = score; bestSheetIdx = i; gySheetDoc = doc; }
                    if(i===1 && !gySheetDoc) gySheetDoc = doc;
                }
            }
            
            statusEl.textContent = 'Extracting images...';
            await loadSourceImages(); // Populate Left Gallery
            await extractImagesToMap(bestSheetIdx); // Map to rows
            
            detectColumns(gySheetDoc);
            reprocessData();
        } catch(e) { console.error(e); statusEl.textContent = "Error: "+e.message; }
    }

    async function loadGyProject(file) {
        try {
            const text = await file.text();
            const json = JSON.parse(text);
            
            if (!json.riskData || !json.images) throw new Error("Invalid Project File Structure");

            gyFullData = [];
            
            // Reconstruct Cards
            json.riskData.forEach((item, index) => {
                const id = item[0];
                const data = item[1];
                const imgObj = json.images.find(img => img.id === id);
                
                gyFullData.push({
                    id: id,
                    row: index + 1,
                    step: data.step || "",
                    desc: data.description || "",
                    hazards: data.hazards || "",
                    controls: data.controls || "",
                    base64: imgObj ? imgObj.base64 : null,
                    originalName: imgObj ? imgObj.originalName : `step_${index+1}.jpg`
                });
            });

            // Hide Source Gallery (since we are in Edit Mode, not Import Mode)
            document.getElementById('gySourcePanel').style.display = 'none';
            
            renderUI();
            statusEl.textContent = `‚úì Project Loaded: ${gyFullData.length} steps restored.`;
            statusEl.style.color = '#27ae60';

        } catch (e) {
            console.error(e);
            statusEl.textContent = "Error loading project: " + e.message;
            statusEl.style.color = 'red';
        }
    }

    function scoreSheet(doc, strings) {
        let score = 0;
        const rows = doc.getElementsByTagName("row");
        for(let i=0; i<Math.min(rows.length, 20); i++) {
            const cells = rows[i].getElementsByTagName("c");
            for(let j=0; j<cells.length; j++) {
                const txt = getCellText(cells[j], strings);
                if(txt.includes("Job") || txt.includes("Task") || txt.includes("Hazard")) score += 2;
            }
        }
        return score;
    }

    function detectColumns(xmlDoc) {
        const keywords = {
            step: ["Step No", "Task Step", "Task/Step"],
            desc: ["Job Step", "Task Description", "Job Description"],
            hGrp: ["Hazard Group"],
            hList: ["Hazard List"],
            risk: ["Risk/Consequences", "Risk / Consequences"],
            ctrl: ["Current Control", "Counter Measure"],
            freq: ["Frequency", "Freq"],
            sev: ["Severity", "Sev"],
            like: ["Likelihood", "Like"]
        };
        let map = {};
        const rows = xmlDoc.getElementsByTagName("row");
        for(let i=0; i<Math.min(rows.length, 50); i++) {
            const cells = rows[i].getElementsByTagName("c");
            for(let j=0; j<cells.length; j++) {
                const cell = cells[j];
                const txt = getCellText(cell, gyStrings);
                const rAttr = cell.getAttribute("r");
                if(!rAttr || !txt) continue;
                const colLetter = rAttr.replace(/[0-9]/g, '');
                
                if(keywords.step.some(k => txt.includes(k))) map.step = colLetter;
                if(keywords.desc.some(k => txt.includes(k))) map.desc = colLetter;
                if(keywords.hGrp.some(k => txt.includes(k))) map.hGrp = colLetter;
                if(keywords.hList.some(k => txt.includes(k))) map.hList = colLetter;
                if(keywords.risk.some(k => txt.includes(k))) map.risk = colLetter;
                if(keywords.ctrl.some(k => txt.includes(k))) map.ctrl = colLetter;
                if(keywords.freq.some(k => txt.includes(k))) map.freq = colLetter;
                if(keywords.sev.some(k => txt.includes(k))) map.sev = colLetter;
                if(keywords.like.some(k => txt.includes(k))) map.like = colLetter;
            }
            if(map.desc) break;
        }
        document.getElementById('gyColStep').value = map.step || "A";
        document.getElementById('gyColDesc').value = map.desc || "B";
        document.getElementById('gyColHazGroup').value = map.hGrp || "C";
        document.getElementById('gyColHazList').value = map.hList || "D";
        document.getElementById('gyColRisk').value = map.risk || "E";
        document.getElementById('gyColControl').value = map.ctrl || "H";
        document.getElementById('gyColFrequency').value = map.freq || "";
        document.getElementById('gyColSeverity').value = map.sev || "";
        document.getElementById('gyColLikelihood').value = map.like || "";
    }

    function reprocessData() {
        if(!gySheetDoc) return;
        const colMap = {
            step: document.getElementById('gyColStep').value.toUpperCase(),
            desc: document.getElementById('gyColDesc').value.toUpperCase(),
            hGrp: document.getElementById('gyColHazGroup').value.toUpperCase(),
            hList: document.getElementById('gyColHazList').value.toUpperCase(),
            risk: document.getElementById('gyColRisk').value.toUpperCase(),
            ctrl: document.getElementById('gyColControl').value.toUpperCase(),
            freq: document.getElementById('gyColFrequency').value.toUpperCase(),
            sev: document.getElementById('gyColSeverity').value.toUpperCase(),
            like: document.getElementById('gyColLikelihood').value.toUpperCase(),
        };
        gyFullData = [];
        const rows = gySheetDoc.getElementsByTagName("row");
        for(let i=0; i<rows.length; i++) {
            const row = rows[i];
            const rowNum = parseInt(row.getAttribute("r"));
            const cells = row.getElementsByTagName("c");
            let d = { step:"", desc:"", hGrp:"", hList:"", risk:"", ctrl:"", freq:"", sev:"", like:"" };
            
            for(let j=0; j<cells.length; j++) {
                const cell = cells[j];
                const rAttr = cell.getAttribute("r");
                if(!rAttr) continue;
                const col = rAttr.replace(/[0-9]/g, '');
                const val = getCellText(cell, gyStrings);
                if(col===colMap.step) d.step = val;
                if(col===colMap.desc) d.desc = val;
                if(col===colMap.hGrp) d.hGrp = val;
                if(col===colMap.hList) d.hList = val;
                if(col===colMap.risk) d.risk = val;
                if(col===colMap.ctrl) d.ctrl = val;
                if(col===colMap.freq) d.freq = val;
                if(col===colMap.sev) d.sev = val;
                if(col===colMap.like) d.like = val;
            }
            
            let haz = "";
            if(d.hGrp || d.hList) haz += `${d.hGrp} ${d.hGrp && d.hList ? '-' : ''} ${d.hList}`;
            if(haz && d.risk) haz += "\n";
            if(d.risk) haz += `Risk: ${d.risk}`;

            const img = gyImagesByRow[rowNum];
            if(d.desc || d.step || img) {
                gyFullData.push({
                    id: `gy-${rowNum}-${Date.now()}`, row: rowNum,
                    step: d.step, desc: d.desc, hazards: haz.trim(), controls: d.ctrl,
                    userFrequency: d.freq || null, userSeverity: d.sev || null, userLikelihood: d.like || null,
                    base64: img ? img.base64 : null, originalName: img ? img.originalName : null
                });
            }
        }
        renderUI();
        statusEl.textContent = `‚úì Found ${gyFullData.length} steps.`;
        statusEl.style.color = '#27ae60';
    }

    function renderUI() {
        const res = document.getElementById('gyResult');
        res.innerHTML = '';
        gyFullData.forEach(item => {
            const card = document.createElement('div');
            card.className = 'gy-card';
            card.id = `card-${item.id}`;
            
            card.innerHTML = `
                <div class="gy-card-img" id="img-wrap-${item.id}"></div>
                <div class="gy-card-body">
                    <div style="display:flex; gap:10px;">
                        <div style="flex:0 0 60px"><label style="font-size:0.7rem; font-weight:bold; color:#999;">STEP</label><textarea class="gy-textarea" style="text-align:center; font-weight:bold; background:#e8f6f3;" oninput="gyUpdateItem('${item.id}','step',this.value)">${item.step}</textarea></div>
                        <div style="flex:1"><label style="font-size:0.7rem; font-weight:bold; color:#999;">DESCRIPTION</label><textarea class="gy-textarea" oninput="gyUpdateItem('${item.id}','desc',this.value)">${item.desc}</textarea></div>
                    </div>
                    <div><label style="font-size:0.7rem; font-weight:bold; color:#999;">HAZARDS</label><textarea class="gy-textarea" style="background:#fff5f5; border-color:#f5c6cb;" oninput="gyUpdateItem('${item.id}','hazards',this.value)">${item.hazards}</textarea></div>
                    <div><label style="font-size:0.7rem; font-weight:bold; color:#999;">CONTROLS</label><textarea class="gy-textarea" oninput="gyUpdateItem('${item.id}','controls',this.value)">${item.controls}</textarea></div>
                    <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; margin-top:8px; padding-top:8px; border-top:1px solid #e5e7eb;">
                        <div><label style="font-size:0.7rem; font-weight:bold; color:#999;">FREQUENCY</label><select class="gy-textarea" style="padding:4px; height:auto;" onchange="gyUpdateItem('${item.id}','userFrequency',this.value)">
                            <option value="">${item.userFrequency || 'Not set'}</option>
                            <option value="1">1 - RARELY</option>
                            <option value="1.25">1.25 - OCCASIONAL</option>
                            <option value="1.5">1.5 - INTERMEDIATE</option>
                            <option value="1.75">1.75 - FREQUENTLY</option>
                            <option value="2">2 - PERMANENT</option>
                        </select></div>
                        <div><label style="font-size:0.7rem; font-weight:bold; color:#999;">SEVERITY</label><select class="gy-textarea" style="padding:4px; height:auto;" onchange="gyUpdateItem('${item.id}','userSeverity',this.value)">
                            <option value="">${item.userSeverity || 'Not set'}</option>
                            <option value="1">1 - No potential of injury</option>
                            <option value="3">3 - Potential of FIRST AID</option>
                            <option value="5">5 - Potential of MEDICAL TREATMENT</option>
                            <option value="7">7 - Potential of DART</option>
                            <option value="9">9 - Potential of SIA</option>
                            <option value="10">10 - Potential of Fatality</option>
                        </select></div>
                        <div><label style="font-size:0.7rem; font-weight:bold; color:#999;">LIKELIHOOD</label><select class="gy-textarea" style="padding:4px; height:auto;" onchange="gyUpdateItem('${item.id}','userLikelihood',this.value)">
                            <option value="">${item.userLikelihood || 'Not set'}</option>
                            <option value="1">1 - Almost impossible</option>
                            <option value="3">3 - Very unlikely</option>
                            <option value="5">5 - Possible to happen</option>
                            <option value="8">8 - Likely to happen</option>
                            <option value="10">10 - Very likely to happen</option>
                        </select></div>
                    </div>
                </div>
            `;
            res.appendChild(card);
            renderCardImage(item);
        });
        const hasData = gyFullData.length > 0;
        if(exportBtn) exportBtn.style.display = hasData ? 'block' : 'none';
        if(forwardBtn) forwardBtn.style.display = hasData ? 'block' : 'none'; // Safe check
    }

    function renderCardImage(item) {
        const wrapper = document.getElementById(`img-wrap-${item.id}`);
        // Add Drag & Drop attributes to the wrapper
        wrapper.setAttribute("ondragover", "gyAllowDrop(event)");
        wrapper.setAttribute("ondrop", `gyDrop(event, '${item.id}')`);
        
        if(item.base64) {
            wrapper.innerHTML = `
                <div class="gy-row-badge">Row ${item.row}</div>
                <button class="gy-action-btn gy-del-btn" onclick="gyRemoveRow('${item.id}')" title="Delete Step">√ó</button>
                <label class="gy-action-btn gy-rep-btn" title="Replace Image">‚Üª<input type="file" accept="image/*" hidden onchange="gyManualUpload('${item.id}', this)"></label>
                <img src="${item.base64}" style="pointer-events:none;"> `;
        } else {
            wrapper.innerHTML = `
                <div class="gy-row-badge">Row ${item.row}</div>
                <button class="gy-action-btn gy-del-btn" onclick="gyRemoveRow('${item.id}')" title="Delete Step">√ó</button>
                <label class="add-photo-btn" style="width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; color:#999; cursor:pointer; border:2px dashed #e2e8f0;">
                    <div style="font-size:36px; color:#27ae60;">+</div><div style="font-weight:600">Drop Image Here</div>
                    <input type="file" accept="image/*" hidden onchange="gyManualUpload('${item.id}', this)">
                </label>
            `;
        }
    }

    // --- Utilities ---
    function getCellText(cell, strings) {
        const tAttr = cell.getAttribute("t");
        const isTag = cell.getElementsByTagName("is")[0];
        if(isTag) {
            let t = "";
            const tTags = isTag.getElementsByTagName("t");
            for(let k=0; k<tTags.length; k++) t += tTags[k].textContent;
            return t;
        }
        const vTag = cell.getElementsByTagName("v")[0];
        if(vTag) {
            const val = vTag.textContent;
            if(tAttr === "s") return strings[parseInt(val)] || "";
            return val;
        }
        return "";
    }

    function parseSharedStrings(xml) {
        if(!xml) return [];
        const parser = new DOMParser();
        const doc = parser.parseFromString(xml, "text/xml");
        return Array.from(doc.getElementsByTagName("si")).map(si => {
            return Array.from(si.getElementsByTagName("t")).map(t => t.textContent).join("");
        });
    }

    async function extractImagesToMap(sheetIndex) {
        const relsPath = `xl/worksheets/_rels/sheet${sheetIndex}.xml.rels`;
        const relsXml = await gyZip.file(relsPath)?.async("text") || "";
        const addToMap = (row, base64, ext) => {
            gyImagesByRow[row] = { base64: `data:image/${ext};base64,${base64}`, originalName: `${gyFilename.split('.')[0]}_row${row}.${ext}` };
        };
        const sheetXmlStr = new XMLSerializer().serializeToString(gySheetDoc);
        const drawMatch = sheetXmlStr.match(/drawing r:id="([^"]+)"/);
        if(drawMatch) await processDrawingML(getTarget(relsXml, drawMatch[1]), addToMap);
        const vmlMatch = sheetXmlStr.match(/legacyDrawing r:id="([^"]+)"/);
        if(vmlMatch) await processVML(getTarget(relsXml, vmlMatch[1]), addToMap);
    }

    async function processDrawingML(path, callback) {
        const fullPath = resolvePath(path);
        if(!gyZip.file(fullPath)) return;
        const xml = await gyZip.file(fullPath).async("text");
        const relsPath = fullPath.replace(/(.*)\/([^\/]+)$/, "$1/_rels/$2.rels");
        const rels = await gyZip.file(relsPath)?.async("text") || "";
        const anchors = xml.matchAll(/<xdr:twoCellAnchor[^>]*>(.*?)<\/xdr:twoCellAnchor>/gs);
        for(const a of anchors) {
            const from = a[1].match(/<xdr:from>.*?<xdr:row>(\d+)<\/xdr:row>.*?<\/xdr:from>/s);
            const blip = a[1].match(/r:embed="([^"]*)"/);
            if(from && blip) {
                const imgTarget = getTarget(rels, blip[1]);
                if(imgTarget) await extractAndCallback(imgTarget, parseInt(from[1]) + 1, callback);
            }
        }
    }

    async function processVML(path, callback) {
        const fullPath = resolvePath(path);
        if(!gyZip.file(fullPath)) return;
        const xml = await gyZip.file(fullPath).async("text");
        const relsPath = fullPath.replace(/(.*)\/([^\/]+)$/, "$1/_rels/$2.rels");
        const rels = await gyZip.file(relsPath)?.async("text") || "";
        const shapes = xml.matchAll(/<(\w+:)?shape[^>]*>(.*?)<\/\1shape>/gs);
        for(const s of shapes) {
            const content = s[2];
            const rowMatch = content.match(/<(\w+:)?Row>(\d+)<\/\1Row>/) || s[0].match(/row="(\d+)"/);
            if(!rowMatch) continue;
            let imgId = content.match(/(?:r:id|o:relid)="([^"]+)"/)?.[1];
            if(imgId && rels) await extractAndCallback(getTarget(rels, imgId), parseInt(rowMatch[2] || rowMatch[1]) + 1, callback);
        }
    }

    async function extractAndCallback(path, row, callback) {
        const fullPath = resolvePath(path);
        if(!gyZip.file(fullPath)) return;
        const base64 = await gyZip.file(fullPath).async("base64");
        const ext = fullPath.split('.').pop();
        callback(row, base64, ext);
    }

    function getTarget(rels, rid) {
        const match = rels.match(new RegExp(`Id="${rid}".*?Target="([^"]+)"`));
        return match ? match[1] : null;
    }

    function resolvePath(p) {
        if(!p) return "";
        let clean = p.replace(/^\//, '').replace('../', '');
        if(gyZip.file(clean)) return clean;
        if(gyZip.file("xl/"+clean)) return "xl/"+clean;
        const fname = clean.split('/').pop();
        if(gyZip.file("xl/media/"+fname)) return "xl/media/"+fname;
        return "";
    }

    function downloadJSON() {
        const riskData = gyFullData.map(i => [i.id, { step: i.step, description: i.desc, hazards: i.hazards || "Nil", controls: i.controls || "" }]);
        const json = { version: "1.0", images: gyFullData.map(i => ({ id: i.id, originalName: i.originalName || `manual_upload_${i.row}.jpg`, base64: i.base64 || "" })), riskData: riskData, tableData: { headers: [], rows: [] } };
        const blob = new Blob([JSON.stringify(json, null, 2)], {type: "application/json"});
        saveAs(blob, `RA_Export_${new Date().toISOString().slice(0,10)}.json`);
    }

    // --- Forward to App Logic ---
// --- UPDATED: Forward to App Logic with Placeholders ---
    if (forwardBtn) {
        forwardBtn.onclick = () => {
            // 1. Helper to create a placeholder image for text-only rows
            function getPlaceholderB64() {
                const cvs = document.createElement('canvas');
                cvs.width = 800; cvs.height = 600;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = "#f1f5f9"; // Slate-100 background
                ctx.fillRect(0,0,800,600);
                ctx.fillStyle = "#94a3b8"; // Slate-400 text
                ctx.font = "bold 40px sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("No Image Available", 400, 280);
                ctx.font = "24px sans-serif";
                ctx.fillText("Click 'Replace Image' to Add Photo", 400, 330);
                return cvs.toDataURL('image/jpeg', 0.6);
            }
            const placeholder = getPlaceholderB64();

            // 2. Generate JSON (Inject placeholder if base64 is missing)
            const riskData = gyFullData.map(i => [
                i.id,
                { 
                    step: i.step,
                    description: i.desc, 
                    hazards: i.hazards || "Nil", 
                    controls: i.controls || "",
                    userFrequency: i.userFrequency || null,
                    userSeverity: i.userSeverity || null,
                    userLikelihood: i.userLikelihood || null
                }
            ]);

            const jsonObj = {
                version: "1.0",
                images: gyFullData.map(i => ({ 
                    id: i.id, 
                    originalName: i.originalName || `step_${i.row}_placeholder.jpg`, 
                    base64: i.base64 || placeholder // <--- THE CRITICAL FIX
                })),
                riskData: riskData,
                tableData: { headers: [], rows: [] }
            };

            // 3. Create virtual file and feed to Main App
            const jsonString = JSON.stringify(jsonObj, null, 2);
            const file = new File([jsonString], "imported_project.json", { type: "application/json" });

            const mainAppInput = document.getElementById('projectFileInput');
            if(mainAppInput) {
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                mainAppInput.files = dataTransfer.files;
                mainAppInput.dispatchEvent(new Event('change', { bubbles: true }));
                document.getElementById('excelImportModal').style.display = 'none';
                if(window.showCustomAlert) window.showCustomAlert("Excel data imported! Click any placeholder image to add a real photo.", "success");
            } else {
                alert("Error: Could not find main project loader (projectFileInput).");
            }
        };
    }

    // --- NEW: Download Image Helper ---
    window.gyDownloadImage = (id) => {
        const item = gyFullData.find(i => i.id === id);
        if (item && item.base64) {
            const link = document.createElement('a');
            link.href = item.base64;
            link.download = item.originalName || `step_image_${item.row}.jpg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    };

    // --- NEW: Gallery & Drag-Drop Logic ---

async function loadSourceImages() {
        const grid = document.getElementById('gySourceGrid');
        grid.innerHTML = '';
        let count = 0;
        
        console.log("--- DEBUG: Starting Image Scan ---");
        
        // Debug: List all files in ZIP to console
        const allFiles = Object.keys(gyZip.files);
        console.log("Files found in ZIP:", allFiles.filter(f => f.includes('media')));

        for (let filename in gyZip.files) {
            // Regex matches png, jpg, jpeg, gif, bmp, webp
            if (filename.match(/xl\/media\/.*\.(png|jpg|jpeg|gif|bmp|webp)$/i)) {
                console.log("Processing image:", filename); // Debug Log
                
                try {
                    const blob = await gyZip.files[filename].async("blob");
                    const b64 = await blobToBase64(blob);
                    const name = filename.split('/').pop();
                    gyAllSourceImages.push({name, blob});
                    
                    const div = document.createElement('div');
                    div.className = "gy-source-item";
                    div.draggable = true;
                    // Use object-contain to ensure full image visibility in gallery
                    div.innerHTML = `<img src="${b64}" class="w-full h-full object-contain pointer-events-none bg-slate-100" title="${name}">`;
                    
                    div.ondragstart = (e) => {
                        e.dataTransfer.setData("text/base64", b64);
                        e.dataTransfer.setData("text/filename", name);
                        e.dataTransfer.effectAllowed = "copy";
                    };
                    grid.appendChild(div);
                    count++;
                } catch(err) {
                    console.error("Error reading image:", filename, err);
                }
            }
        }
        
        console.log(`--- DEBUG: Total Images Added to Gallery: ${count} ---`);
        
        document.getElementById('gySourcePanel').style.display = count > 0 ? 'flex' : 'none';
        document.getElementById('gyImgCount').innerText = `(${count})`;
    }
    // --- NEW: Auto-Scroll Logic for Drag & Drop ---
    const cardsPanel = document.getElementById('gyCardsPanel');
    let autoScrollInterval;
    
    // Detect when dragging over the cards panel
    cardsPanel.addEventListener('dragover', (e) => {
        e.preventDefault();
        const { top, bottom, height } = cardsPanel.getBoundingClientRect();
        const mouseY = e.clientY;
        
        // Sensitivity zones (top 10% and bottom 10% of the panel)
        const threshold = height * 0.15; 
        
        clearInterval(autoScrollInterval); // Clear previous to prevent stacking

        if (mouseY < top + threshold) {
            // Scroll Up
            autoScrollInterval = setInterval(() => { cardsPanel.scrollTop -= 10; }, 16);
        } else if (mouseY > bottom - threshold) {
            // Scroll Down
            autoScrollInterval = setInterval(() => { cardsPanel.scrollTop += 10; }, 16);
        }
    });

    // Stop scrolling when drag leaves or drops
    cardsPanel.addEventListener('dragleave', () => clearInterval(autoScrollInterval));
    cardsPanel.addEventListener('drop', () => clearInterval(autoScrollInterval));
    // --- End Auto-Scroll ---

    // Download All Button Logic
    window.gyDownloadAllImages = () => {
        if(gyAllSourceImages.length === 0) return;
        const zip = new JSZip();
        gyAllSourceImages.forEach(img => zip.file(img.name, img.blob));
        zip.generateAsync({type:"blob"}).then(content => saveAs(content, "All_Extracted_Images.zip"));
    };

    // Global Drag & Drop Handlers
    window.gyAllowDrop = (e) => {
        e.preventDefault();
        e.currentTarget.style.backgroundColor = "#f0fff4"; // Highlight green
        e.currentTarget.style.borderColor = "#27ae60";
    };

    window.gyDrop = (e, itemId) => {
        e.preventDefault();
        e.currentTarget.style.backgroundColor = ""; // Reset styles
        e.currentTarget.style.borderColor = "";

        // 1. Handle Drop from Gallery (Base64)
        const base64 = e.dataTransfer.getData("text/base64");
        const filename = e.dataTransfer.getData("text/filename");

        // 2. Handle Drop from Desktop (File)
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            gyManualUpload(itemId, { files: e.dataTransfer.files });
            return;
        }

        // Apply Gallery Drop
        if(base64) {
            const item = gyFullData.find(i => i.id === itemId);
            if(item) {
                item.base64 = base64;
                item.originalName = filename || "gallery_image.jpg";
                renderCardImage(item);
            }
        }
    };

    function blobToBase64(blob) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
        });
    }

})(); // End IIFE
</script>

</body>
</html>
